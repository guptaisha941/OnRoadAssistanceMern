{"ast":null,"code":"/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport { getUid } from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { listen, unlisten } from '../../events.js';\nimport EventType from '../../events/EventType.js';\nimport rbush from 'rbush';\nimport { buffer, containsCoordinate, equals, getIntersection, getTopLeft, intersects } from '../../extent.js';\nimport VectorTileRenderType from '../../layer/VectorTileRenderType.js';\nimport { equivalent as equivalentProjection } from '../../proj.js';\nimport Units from '../../proj/Units.js';\nimport ReplayType from '../../render/ReplayType.js';\nimport { labelCache, rotateAtOffset } from '../../render/canvas.js';\nimport CanvasReplayGroup, { replayDeclutter } from '../../render/canvas/ReplayGroup.js';\nimport { ORDER } from '../../render/replay.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport { getSquaredTolerance as getSquaredRenderTolerance, renderFeature } from '../vector.js';\nimport { create as createTransform, compose as composeTransform, reset as resetTransform, scale as scaleTransform, translate as translateTransform } from '../../transform.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/ReplayType.js\").default>>}\n */\nvar IMAGE_REPLAYS = {\n  'image': [ReplayType.POLYGON, ReplayType.CIRCLE, ReplayType.LINE_STRING, ReplayType.IMAGE, ReplayType.TEXT],\n  'hybrid': [ReplayType.POLYGON, ReplayType.LINE_STRING]\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/ReplayType.js\").default>>}\n */\nvar VECTOR_REPLAYS = {\n  'image': [ReplayType.DEFAULT],\n  'hybrid': [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT],\n  'vector': ORDER\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n */\nvar CanvasVectorTileLayerRenderer = /*@__PURE__*/function (CanvasTileLayerRenderer) {\n  function CanvasVectorTileLayerRenderer(layer) {\n    CanvasTileLayerRenderer.call(this, layer, true);\n\n    /**\n     * Declutter tree.\n     * @private\n     */\n    this.declutterTree_ = layer.getDeclutter() ? rbush(9, undefined) : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.dirty_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n    var renderMode = layer.getRenderMode();\n\n    // Use lower resolution for pure vector rendering. Closest resolution otherwise.\n    this.zDirection = renderMode === VectorTileRenderType.VECTOR ? 1 : 0;\n    if (renderMode !== VectorTileRenderType.VECTOR) {\n      this.context = createCanvasContext2D();\n    }\n    listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n  }\n  if (CanvasTileLayerRenderer) CanvasVectorTileLayerRenderer.__proto__ = CanvasTileLayerRenderer;\n  CanvasVectorTileLayerRenderer.prototype = Object.create(CanvasTileLayerRenderer && CanvasTileLayerRenderer.prototype);\n  CanvasVectorTileLayerRenderer.prototype.constructor = CanvasVectorTileLayerRenderer;\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.disposeInternal = function disposeInternal() {\n    unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n    CanvasTileLayerRenderer.prototype.disposeInternal.call(this);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.getTile = function getTile(z, x, y, pixelRatio, projection) {\n    var tile = CanvasTileLayerRenderer.prototype.getTile.call(this, z, x, y, pixelRatio, projection);\n    if (tile.getState() === TileState.LOADED) {\n      this.createReplayGroup_( /** @type {import(\"../../VectorImageTile.js\").default} */tile, pixelRatio, projection);\n      if (this.context) {\n        this.renderTileImage_( /** @type {import(\"../../VectorImageTile.js\").default} */tile, pixelRatio, projection);\n      }\n    }\n    return tile;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.getTileImage = function getTileImage(tile) {\n    var tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */this.getLayer();\n    return (/** @type {import(\"../../VectorImageTile.js\").default} */tile.getImage(tileLayer)\n    );\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n    var layer = /** @type {import(\"../../layer/Vector.js\").default} */this.getLayer();\n    var layerRevision = layer.getRevision();\n    if (this.renderedLayerRevision_ != layerRevision) {\n      this.renderedTiles.length = 0;\n    }\n    this.renderedLayerRevision_ = layerRevision;\n    return CanvasTileLayerRenderer.prototype.prepareFrame.call(this, frameState, layerState);\n  };\n\n  /**\n   * @param {import(\"../../VectorImageTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.createReplayGroup_ = function createReplayGroup_(tile, pixelRatio, projection) {\n    var this$1 = this;\n    var layer = /** @type {import(\"../../layer/Vector.js\").default} */this.getLayer();\n    var revision = layer.getRevision();\n    var renderOrder = /** @type {import(\"../../render.js\").OrderFunction} */layer.getRenderOrder() || null;\n    var replayState = tile.getReplayState(layer);\n    if (!replayState.dirty && replayState.renderedRevision == revision && replayState.renderedRenderOrder == renderOrder) {\n      return;\n    }\n    var source = /** @type {import(\"../../source/VectorTile.js\").default} */layer.getSource();\n    var sourceTileGrid = source.getTileGrid();\n    var tileGrid = source.getTileGridForProjection(projection);\n    var resolution = tileGrid.getResolution(tile.tileCoord[0]);\n    var tileExtent = tile.extent;\n    var loop = function (t, tt) {\n      var sourceTile = tile.getTile(tile.tileKeys[t]);\n      if (sourceTile.getState() != TileState.LOADED) {\n        return;\n      }\n      var sourceTileCoord = sourceTile.tileCoord;\n      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      var sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      var bufferedExtent = equals(sourceTileExtent, sharedExtent) ? null : buffer(sharedExtent, layer.getRenderBuffer() * resolution, this$1.tmpExtent);\n      var tileProjection = sourceTile.getProjection();\n      var reproject = false;\n      if (!equivalentProjection(projection, tileProjection)) {\n        reproject = true;\n        sourceTile.setProjection(projection);\n      }\n      replayState.dirty = false;\n      var replayGroup = new CanvasReplayGroup(0, sharedExtent, resolution, pixelRatio, source.getOverlaps(), this$1.declutterTree_, layer.getRenderBuffer());\n      var squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      var render = function (feature) {\n        var styles;\n        var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);\n          this.dirty_ = this.dirty_ || dirty;\n          replayState.dirty = replayState.dirty || dirty;\n        }\n      };\n      var features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        var feature = features[i];\n        if (reproject) {\n          if (tileProjection.getUnits() == Units.TILE_PIXELS) {\n            // projected tile extent\n            tileProjection.setWorldExtent(sourceTileExtent);\n            // tile extent in tile pixel space\n            tileProjection.setExtent(sourceTile.getExtent());\n          }\n          feature.getGeometry().transform(tileProjection, projection);\n        }\n        if (!bufferedExtent || intersects(bufferedExtent, feature.getGeometry().getExtent())) {\n          render.call(this$1, feature);\n        }\n      }\n      replayGroup.finish();\n      sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);\n    };\n    for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) loop(t, tt);\n    replayState.renderedRevision = revision;\n    replayState.renderedRenderOrder = renderOrder;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    var resolution = frameState.viewState.resolution;\n    var rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    var layer = this.getLayer();\n    /** @type {!Object<string, boolean>} */\n    var features = {};\n    var renderedTiles = /** @type {Array<import(\"../../VectorImageTile.js\").default>} */this.renderedTiles;\n    var bufferedExtent, found;\n    var i, ii;\n    for (i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      var tile = renderedTiles[i];\n      bufferedExtent = buffer(tile.extent, hitTolerance * resolution, bufferedExtent);\n      if (!containsCoordinate(bufferedExtent, coordinate)) {\n        continue;\n      }\n      for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n        var sourceTile = tile.getTile(tile.tileKeys[t]);\n        if (sourceTile.getState() != TileState.LOADED) {\n          continue;\n        }\n        var replayGroup = /** @type {CanvasReplayGroup} */sourceTile.getReplayGroup(layer, tile.tileCoord.toString());\n        found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\n        /**\n         * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n         * @return {?} Callback result.\n         */\n        function (feature) {\n          var key = getUid(feature);\n          if (!(key in features)) {\n            features[key] = true;\n            return callback.call(thisArg, feature, layer);\n          }\n        }, null);\n      }\n    }\n    return found;\n  };\n\n  /**\n   * @param {import(\"../../VectorTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../transform.js\").Transform} transform Transform.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.getReplayTransform_ = function getReplayTransform_(tile, frameState) {\n    var layer = this.getLayer();\n    var source = /** @type {import(\"../../source/VectorTile.js\").default} */layer.getSource();\n    var tileGrid = source.getTileGrid();\n    var tileCoord = tile.tileCoord;\n    var tileResolution = tileGrid.getResolution(tileCoord[0]);\n    var viewState = frameState.viewState;\n    var pixelRatio = frameState.pixelRatio;\n    var renderResolution = viewState.resolution / pixelRatio;\n    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    var center = viewState.center;\n    var origin = getTopLeft(tileExtent);\n    var size = frameState.size;\n    var offsetX = Math.round(pixelRatio * size[0] / 2);\n    var offsetY = Math.round(pixelRatio * size[1] / 2);\n    return composeTransform(this.tmpTransform_, offsetX, offsetY, tileResolution / renderResolution, tileResolution / renderResolution, viewState.rotation, (origin[0] - center[0]) / tileResolution, (center[1] - origin[1]) / tileResolution);\n  };\n\n  /**\n   * @param {import(\"../../events/Event.js\").default} event Event.\n   */\n  CanvasVectorTileLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_(event) {\n    var layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  };\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorTileLayerRenderer.prototype.postCompose = function postCompose(context, frameState, layerState) {\n    var layer = /** @type {import(\"../../layer/Vector.js\").default} */this.getLayer();\n    var renderMode = layer.getRenderMode();\n    if (renderMode != VectorTileRenderType.IMAGE) {\n      var declutterReplays = layer.getDeclutter() ? {} : null;\n      var source = /** @type {import(\"../../source/VectorTile.js\").default} */layer.getSource();\n      var replayTypes = VECTOR_REPLAYS[renderMode];\n      var pixelRatio = frameState.pixelRatio;\n      var rotation = frameState.viewState.rotation;\n      var size = frameState.size;\n      var offsetX, offsetY;\n      if (rotation) {\n        offsetX = Math.round(pixelRatio * size[0] / 2);\n        offsetY = Math.round(pixelRatio * size[1] / 2);\n        rotateAtOffset(context, -rotation, offsetX, offsetY);\n      }\n      if (declutterReplays) {\n        this.declutterTree_.clear();\n      }\n      var viewHints = frameState.viewHints;\n      var snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n      var tiles = this.renderedTiles;\n      var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n      var clips = [];\n      var zs = [];\n      for (var i = tiles.length - 1; i >= 0; --i) {\n        var tile = /** @type {import(\"../../VectorImageTile.js\").default} */tiles[i];\n        if (tile.getState() == TileState.ABORT) {\n          continue;\n        }\n        var tileCoord = tile.tileCoord;\n        var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tile.extent[0];\n        var transform = undefined;\n        for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n          var sourceTile = tile.getTile(tile.tileKeys[t]);\n          if (sourceTile.getState() != TileState.LOADED) {\n            continue;\n          }\n          var replayGroup = /** @type {CanvasReplayGroup} */sourceTile.getReplayGroup(layer, tileCoord.toString());\n          if (!replayGroup || !replayGroup.hasReplays(replayTypes)) {\n            // sourceTile was not yet loaded when this.createReplayGroup_() was\n            // called, or it has no replays of the types we want to render\n            continue;\n          }\n          if (!transform) {\n            transform = this.getTransform(frameState, worldOffset);\n          }\n          var currentZ = sourceTile.tileCoord[0];\n          var currentClip = replayGroup.getClipCoords(transform);\n          context.save();\n          context.globalAlpha = layerState.opacity;\n          // Create a clip mask for regions in this low resolution tile that are\n          // already filled by a higher resolution tile\n          for (var j = 0, jj = clips.length; j < jj; ++j) {\n            var clip = clips[j];\n            if (currentZ < zs[j]) {\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher resolution tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n          replayGroup.replay(context, transform, rotation, {}, snapToPixel, replayTypes, declutterReplays);\n          context.restore();\n          clips.push(currentClip);\n          zs.push(currentZ);\n        }\n      }\n      if (declutterReplays) {\n        replayDeclutter(declutterReplays, context, rotation, snapToPixel);\n      }\n      if (rotation) {\n        rotateAtOffset(context, rotation, /** @type {number} */offsetX, /** @type {number} */offsetY);\n      }\n    }\n    CanvasTileLayerRenderer.prototype.postCompose.call(this, context, frameState, layerState);\n  };\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/ReplayGroup.js\").default} replayGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n  CanvasVectorTileLayerRenderer.prototype.renderFeature = function renderFeature$1(feature, squaredTolerance, styles, replayGroup) {\n    if (!styles) {\n      return false;\n    }\n    var loading = false;\n    if (Array.isArray(styles)) {\n      for (var i = 0, ii = styles.length; i < ii; ++i) {\n        loading = renderFeature(replayGroup, feature, styles[i], squaredTolerance, this.handleStyleImageChange_, this) || loading;\n      }\n    } else {\n      loading = renderFeature(replayGroup, feature, styles, squaredTolerance, this.handleStyleImageChange_, this);\n    }\n    return loading;\n  };\n\n  /**\n   * @param {import(\"../../VectorImageTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function renderTileImage_(tile, pixelRatio, projection) {\n    var layer = /** @type {import(\"../../layer/Vector.js\").default} */this.getLayer();\n    var replayState = tile.getReplayState(layer);\n    var revision = layer.getRevision();\n    var replays = IMAGE_REPLAYS[layer.getRenderMode()];\n    if (replays && replayState.renderedTileRevision !== revision) {\n      replayState.renderedTileRevision = revision;\n      var tileCoord = tile.wrappedTileCoord;\n      var z = tileCoord[0];\n      var source = /** @type {import(\"../../source/VectorTile.js\").default} */layer.getSource();\n      var tileGrid = source.getTileGridForProjection(projection);\n      var resolution = tileGrid.getResolution(z);\n      var context = tile.getContext(layer);\n      var size = source.getTilePixelSize(z, pixelRatio, projection);\n      context.canvas.width = size[0];\n      context.canvas.height = size[1];\n      var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n      for (var i = 0, ii = tile.tileKeys.length; i < ii; ++i) {\n        var sourceTile = tile.getTile(tile.tileKeys[i]);\n        if (sourceTile.getState() != TileState.LOADED) {\n          continue;\n        }\n        var pixelScale = pixelRatio / resolution;\n        var transform = resetTransform(this.tmpTransform_);\n        scaleTransform(transform, pixelScale, -pixelScale);\n        translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n        var replayGroup = /** @type {CanvasReplayGroup} */sourceTile.getReplayGroup(layer, tile.tileCoord.toString());\n        replayGroup.replay(context, transform, 0, {}, true, replays);\n      }\n    }\n  };\n  return CanvasVectorTileLayerRenderer;\n}(CanvasTileLayerRenderer);\n\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\nCanvasVectorTileLayerRenderer['handles'] = function (layer) {\n  return layer.getType() === LayerType.VECTOR_TILE;\n};\n\n/**\n * Create a layer renderer.\n * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n * @return {CanvasVectorTileLayerRenderer} The layer renderer.\n */\nCanvasVectorTileLayerRenderer['create'] = function (mapRenderer, layer) {\n  return new CanvasVectorTileLayerRenderer( /** @type {import(\"../../layer/VectorTile.js\").default} */layer);\n};\nexport default CanvasVectorTileLayerRenderer;","map":{"version":3,"names":["getUid","LayerType","TileState","ViewHint","createCanvasContext2D","listen","unlisten","EventType","rbush","buffer","containsCoordinate","equals","getIntersection","getTopLeft","intersects","VectorTileRenderType","equivalent","equivalentProjection","Units","ReplayType","labelCache","rotateAtOffset","CanvasReplayGroup","replayDeclutter","ORDER","CanvasTileLayerRenderer","getSquaredTolerance","getSquaredRenderTolerance","renderFeature","create","createTransform","compose","composeTransform","reset","resetTransform","scale","scaleTransform","translate","translateTransform","IMAGE_REPLAYS","POLYGON","CIRCLE","LINE_STRING","IMAGE","TEXT","VECTOR_REPLAYS","DEFAULT","CanvasVectorTileLayerRenderer","layer","call","declutterTree_","getDeclutter","undefined","dirty_","renderedLayerRevision_","tmpTransform_","renderMode","getRenderMode","zDirection","VECTOR","context","CLEAR","handleFontsChanged_","disposeInternal","prototype","getTile","z","x","y","pixelRatio","projection","tile","getState","LOADED","createReplayGroup_","renderTileImage_","getTileImage","tileLayer","getLayer","getImage","prepareFrame","frameState","layerState","layerRevision","getRevision","renderedTiles","length","revision","renderOrder","getRenderOrder","replayState","getReplayState","dirty","renderedRevision","renderedRenderOrder","source","getSource","sourceTileGrid","getTileGrid","tileGrid","getTileGridForProjection","resolution","getResolution","tileCoord","tileExtent","extent","sourceTile","tileKeys","t","sourceTileCoord","sourceTileExtent","getTileCoordExtent","sharedExtent","bufferedExtent","getRenderBuffer","this$1","tmpExtent","tileProjection","getProjection","reproject","setProjection","replayGroup","getOverlaps","squaredTolerance","render","feature","styles","styleFunction","getStyleFunction","features","getFeatures","sort","i","ii","getUnits","TILE_PIXELS","setWorldExtent","setExtent","getExtent","getGeometry","transform","finish","setReplayGroup","toString","tt","loop","forEachFeatureAtCoordinate","coordinate","hitTolerance","callback","thisArg","viewState","rotation","found","getReplayGroup","key","getReplayTransform_","tileResolution","renderResolution","center","origin","size","offsetX","Math","round","offsetY","event","getVisible","changed","handleStyleImageChange_","renderIfReadyAndVisible","postCompose","declutterReplays","replayTypes","clear","viewHints","snapToPixel","ANIMATING","INTERACTING","tiles","clips","zs","ABORT","worldOffset","hasReplays","getTransform","currentZ","currentClip","getClipCoords","save","globalAlpha","opacity","j","jj","clip","beginPath","moveTo","lineTo","replay","restore","push","renderFeature$1","loading","Array","isArray","replays","renderedTileRevision","wrappedTileCoord","getContext","getTilePixelSize","canvas","width","height","pixelScale","getType","VECTOR_TILE","mapRenderer"],"sources":["../../../../src/ol/renderer/canvas/VectorTileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport {getUid} from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {listen, unlisten} from '../../events.js';\nimport EventType from '../../events/EventType.js';\nimport rbush from 'rbush';\nimport {buffer, containsCoordinate, equals, getIntersection, getTopLeft, intersects} from '../../extent.js';\nimport VectorTileRenderType from '../../layer/VectorTileRenderType.js';\nimport {equivalent as equivalentProjection} from '../../proj.js';\nimport Units from '../../proj/Units.js';\nimport ReplayType from '../../render/ReplayType.js';\nimport {labelCache, rotateAtOffset} from '../../render/canvas.js';\nimport CanvasReplayGroup, {replayDeclutter} from '../../render/canvas/ReplayGroup.js';\nimport {ORDER} from '../../render/replay.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport {getSquaredTolerance as getSquaredRenderTolerance, renderFeature} from '../vector.js';\nimport {\n  create as createTransform,\n  compose as composeTransform,\n  reset as resetTransform,\n  scale as scaleTransform,\n  translate as translateTransform\n} from '../../transform.js';\n\n\n/**\n * @type {!Object<string, Array<import(\"../../render/ReplayType.js\").default>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': [ReplayType.POLYGON, ReplayType.CIRCLE,\n    ReplayType.LINE_STRING, ReplayType.IMAGE, ReplayType.TEXT],\n  'hybrid': [ReplayType.POLYGON, ReplayType.LINE_STRING]\n};\n\n\n/**\n * @type {!Object<string, Array<import(\"../../render/ReplayType.js\").default>>}\n */\nconst VECTOR_REPLAYS = {\n  'image': [ReplayType.DEFAULT],\n  'hybrid': [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT],\n  'vector': ORDER\n};\n\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   */\n  constructor(layer) {\n\n    super(layer, true);\n\n    /**\n     * Declutter tree.\n     * @private\n     */\n    this.declutterTree_ = layer.getDeclutter() ? rbush(9, undefined) : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.dirty_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n\n    const renderMode = layer.getRenderMode();\n\n    // Use lower resolution for pure vector rendering. Closest resolution otherwise.\n    this.zDirection = renderMode === VectorTileRenderType.VECTOR ? 1 : 0;\n\n    if (renderMode !== VectorTileRenderType.VECTOR) {\n      this.context = createCanvasContext2D();\n    }\n\n\n    listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n\n  }\n\n  /**\n   * @inheritDoc\n   */\n  disposeInternal() {\n    unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n    super.disposeInternal();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tile = super.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() === TileState.LOADED) {\n      this.createReplayGroup_(/** @type {import(\"../../VectorImageTile.js\").default} */ (tile), pixelRatio, projection);\n      if (this.context) {\n        this.renderTileImage_(/** @type {import(\"../../VectorImageTile.js\").default} */ (tile), pixelRatio, projection);\n      }\n    }\n    return tile;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getTileImage(tile) {\n    const tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */ (this.getLayer());\n    return /** @type {import(\"../../VectorImageTile.js\").default} */ (tile).getImage(tileLayer);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  prepareFrame(frameState, layerState) {\n    const layer = /** @type {import(\"../../layer/Vector.js\").default} */ (this.getLayer());\n    const layerRevision = layer.getRevision();\n    if (this.renderedLayerRevision_ != layerRevision) {\n      this.renderedTiles.length = 0;\n    }\n    this.renderedLayerRevision_ = layerRevision;\n    return super.prepareFrame(frameState, layerState);\n  }\n\n  /**\n   * @param {import(\"../../VectorImageTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  createReplayGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/Vector.js\").default} */ (this.getLayer());\n    const revision = layer.getRevision();\n    const renderOrder = /** @type {import(\"../../render.js\").OrderFunction} */ (layer.getRenderOrder()) || null;\n\n    const replayState = tile.getReplayState(layer);\n    if (!replayState.dirty && replayState.renderedRevision == revision &&\n        replayState.renderedRenderOrder == renderOrder) {\n      return;\n    }\n\n    const source = /** @type {import(\"../../source/VectorTile.js\").default} */ (layer.getSource());\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const resolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const tileExtent = tile.extent;\n\n    for (let t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n      const sourceTile = tile.getTile(tile.tileKeys[t]);\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n\n      const sourceTileCoord = sourceTile.tileCoord;\n      const sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent) ? null :\n        buffer(sharedExtent, layer.getRenderBuffer() * resolution, this.tmpExtent);\n      const tileProjection = sourceTile.getProjection();\n      let reproject = false;\n      if (!equivalentProjection(projection, tileProjection)) {\n        reproject = true;\n        sourceTile.setProjection(projection);\n      }\n      replayState.dirty = false;\n      const replayGroup = new CanvasReplayGroup(0, sharedExtent, resolution,\n        pixelRatio, source.getOverlaps(), this.declutterTree_, layer.getRenderBuffer());\n      const squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function(feature) {\n        let styles;\n        const styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);\n          this.dirty_ = this.dirty_ || dirty;\n          replayState.dirty = replayState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        const feature = features[i];\n        if (reproject) {\n          if (tileProjection.getUnits() == Units.TILE_PIXELS) {\n            // projected tile extent\n            tileProjection.setWorldExtent(sourceTileExtent);\n            // tile extent in tile pixel space\n            tileProjection.setExtent(sourceTile.getExtent());\n          }\n          feature.getGeometry().transform(tileProjection, projection);\n        }\n        if (!bufferedExtent || intersects(bufferedExtent, feature.getGeometry().getExtent())) {\n          render.call(this, feature);\n        }\n      }\n      replayGroup.finish();\n      sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);\n    }\n    replayState.renderedRevision = revision;\n    replayState.renderedRenderOrder = renderOrder;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    /** @type {!Object<string, boolean>} */\n    const features = {};\n\n    const renderedTiles = /** @type {Array<import(\"../../VectorImageTile.js\").default>} */ (this.renderedTiles);\n\n    let bufferedExtent, found;\n    let i, ii;\n    for (i = 0, ii = renderedTiles.length; i < ii; ++i) {\n      const tile = renderedTiles[i];\n      bufferedExtent = buffer(tile.extent, hitTolerance * resolution, bufferedExtent);\n      if (!containsCoordinate(bufferedExtent, coordinate)) {\n        continue;\n      }\n      for (let t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n        const sourceTile = tile.getTile(tile.tileKeys[t]);\n        if (sourceTile.getState() != TileState.LOADED) {\n          continue;\n        }\n        const replayGroup = /** @type {CanvasReplayGroup} */ (sourceTile.getReplayGroup(layer,\n          tile.tileCoord.toString()));\n        found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\n          /**\n           * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n           * @return {?} Callback result.\n           */\n          function(feature) {\n            const key = getUid(feature);\n            if (!(key in features)) {\n              features[key] = true;\n              return callback.call(thisArg, feature, layer);\n            }\n          }, null);\n      }\n    }\n    return found;\n  }\n\n  /**\n   * @param {import(\"../../VectorTile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../transform.js\").Transform} transform Transform.\n   * @private\n   */\n  getReplayTransform_(tile, frameState) {\n    const layer = this.getLayer();\n    const source = /** @type {import(\"../../source/VectorTile.js\").default} */ (layer.getSource());\n    const tileGrid = source.getTileGrid();\n    const tileCoord = tile.tileCoord;\n    const tileResolution = tileGrid.getResolution(tileCoord[0]);\n    const viewState = frameState.viewState;\n    const pixelRatio = frameState.pixelRatio;\n    const renderResolution = viewState.resolution / pixelRatio;\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n    const center = viewState.center;\n    const origin = getTopLeft(tileExtent);\n    const size = frameState.size;\n    const offsetX = Math.round(pixelRatio * size[0] / 2);\n    const offsetY = Math.round(pixelRatio * size[1] / 2);\n    return composeTransform(this.tmpTransform_,\n      offsetX, offsetY,\n      tileResolution / renderResolution, tileResolution / renderResolution,\n      viewState.rotation,\n      (origin[0] - center[0]) / tileResolution,\n      (center[1] - origin[1]) / tileResolution);\n  }\n\n  /**\n   * @param {import(\"../../events/Event.js\").default} event Event.\n   */\n  handleFontsChanged_(event) {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  postCompose(context, frameState, layerState) {\n    const layer = /** @type {import(\"../../layer/Vector.js\").default} */ (this.getLayer());\n    const renderMode = layer.getRenderMode();\n    if (renderMode != VectorTileRenderType.IMAGE) {\n      const declutterReplays = layer.getDeclutter() ? {} : null;\n      const source = /** @type {import(\"../../source/VectorTile.js\").default} */ (layer.getSource());\n      const replayTypes = VECTOR_REPLAYS[renderMode];\n      const pixelRatio = frameState.pixelRatio;\n      const rotation = frameState.viewState.rotation;\n      const size = frameState.size;\n      let offsetX, offsetY;\n      if (rotation) {\n        offsetX = Math.round(pixelRatio * size[0] / 2);\n        offsetY = Math.round(pixelRatio * size[1] / 2);\n        rotateAtOffset(context, -rotation, offsetX, offsetY);\n      }\n      if (declutterReplays) {\n        this.declutterTree_.clear();\n      }\n      const viewHints = frameState.viewHints;\n      const snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n      const tiles = this.renderedTiles;\n      const tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n      const clips = [];\n      const zs = [];\n      for (let i = tiles.length - 1; i >= 0; --i) {\n        const tile = /** @type {import(\"../../VectorImageTile.js\").default} */ (tiles[i]);\n        if (tile.getState() == TileState.ABORT) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n        const worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tile.extent[0];\n        let transform = undefined;\n        for (let t = 0, tt = tile.tileKeys.length; t < tt; ++t) {\n          const sourceTile = tile.getTile(tile.tileKeys[t]);\n          if (sourceTile.getState() != TileState.LOADED) {\n            continue;\n          }\n          const replayGroup = /** @type {CanvasReplayGroup} */ (sourceTile.getReplayGroup(layer, tileCoord.toString()));\n          if (!replayGroup || !replayGroup.hasReplays(replayTypes)) {\n            // sourceTile was not yet loaded when this.createReplayGroup_() was\n            // called, or it has no replays of the types we want to render\n            continue;\n          }\n          if (!transform) {\n            transform = this.getTransform(frameState, worldOffset);\n          }\n          const currentZ = sourceTile.tileCoord[0];\n          const currentClip = replayGroup.getClipCoords(transform);\n          context.save();\n          context.globalAlpha = layerState.opacity;\n          // Create a clip mask for regions in this low resolution tile that are\n          // already filled by a higher resolution tile\n          for (let j = 0, jj = clips.length; j < jj; ++j) {\n            const clip = clips[j];\n            if (currentZ < zs[j]) {\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher resolution tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n          replayGroup.replay(context, transform, rotation, {}, snapToPixel, replayTypes, declutterReplays);\n          context.restore();\n          clips.push(currentClip);\n          zs.push(currentZ);\n        }\n      }\n      if (declutterReplays) {\n        replayDeclutter(declutterReplays, context, rotation, snapToPixel);\n      }\n      if (rotation) {\n        rotateAtOffset(context, rotation,\n          /** @type {number} */ (offsetX), /** @type {number} */ (offsetY));\n      }\n    }\n    super.postCompose(context, frameState, layerState);\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/ReplayGroup.js\").default} replayGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(feature, squaredTolerance, styles, replayGroup) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading = renderFeature(\n          replayGroup, feature, styles[i], squaredTolerance,\n          this.handleStyleImageChange_, this) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        replayGroup, feature, styles, squaredTolerance,\n        this.handleStyleImageChange_, this);\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorImageTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  renderTileImage_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/Vector.js\").default} */ (this.getLayer());\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const replays = IMAGE_REPLAYS[layer.getRenderMode()];\n    if (replays && replayState.renderedTileRevision !== revision) {\n      replayState.renderedTileRevision = revision;\n      const tileCoord = tile.wrappedTileCoord;\n      const z = tileCoord[0];\n      const source = /** @type {import(\"../../source/VectorTile.js\").default} */ (layer.getSource());\n      const tileGrid = source.getTileGridForProjection(projection);\n      const resolution = tileGrid.getResolution(z);\n      const context = tile.getContext(layer);\n      const size = source.getTilePixelSize(z, pixelRatio, projection);\n      context.canvas.width = size[0];\n      context.canvas.height = size[1];\n      const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);\n      for (let i = 0, ii = tile.tileKeys.length; i < ii; ++i) {\n        const sourceTile = tile.getTile(tile.tileKeys[i]);\n        if (sourceTile.getState() != TileState.LOADED) {\n          continue;\n        }\n        const pixelScale = pixelRatio / resolution;\n        const transform = resetTransform(this.tmpTransform_);\n        scaleTransform(transform, pixelScale, -pixelScale);\n        translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n        const replayGroup = /** @type {CanvasReplayGroup} */ (sourceTile.getReplayGroup(layer,\n          tile.tileCoord.toString()));\n        replayGroup.replay(context, transform, 0, {}, true, replays);\n      }\n    }\n  }\n}\n\n\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\nCanvasVectorTileLayerRenderer['handles'] = function(layer) {\n  return layer.getType() === LayerType.VECTOR_TILE;\n};\n\n\n/**\n * Create a layer renderer.\n * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n * @return {CanvasVectorTileLayerRenderer} The layer renderer.\n */\nCanvasVectorTileLayerRenderer['create'] = function(mapRenderer, layer) {\n  return new CanvasVectorTileLayerRenderer(/** @type {import(\"../../layer/VectorTile.js\").default} */ (layer));\n};\n\n\nexport default CanvasVectorTileLayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}