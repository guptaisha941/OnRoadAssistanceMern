{"ast":null,"code":"/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport { getUid } from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { containsExtent, createEmpty, equals, getIntersection, isEmpty } from '../../extent.js';\nimport IntermediateCanvasRenderer from './IntermediateCanvas.js';\nimport { create as createTransform, compose as composeTransform } from '../../transform.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n */\nvar CanvasTileLayerRenderer = /*@__PURE__*/function (IntermediateCanvasRenderer) {\n  function CanvasTileLayerRenderer(tileLayer, opt_noContext) {\n    IntermediateCanvasRenderer.call(this, tileLayer);\n\n    /**\n     * @protected\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = opt_noContext ? null : createCanvasContext2D();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.oversampling_;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.imageTransform_ = createTransform();\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.zDirection = 0;\n  }\n  if (IntermediateCanvasRenderer) CanvasTileLayerRenderer.__proto__ = IntermediateCanvasRenderer;\n  CanvasTileLayerRenderer.prototype = Object.create(IntermediateCanvasRenderer && IntermediateCanvasRenderer.prototype);\n  CanvasTileLayerRenderer.prototype.constructor = CanvasTileLayerRenderer;\n\n  /**\n   * @private\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  CanvasTileLayerRenderer.prototype.isDrawableTile_ = function isDrawableTile_(tile) {\n    var tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */this.getLayer();\n    var tileState = tile.getState();\n    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;\n  };\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  CanvasTileLayerRenderer.prototype.getTile = function getTile(z, x, y, pixelRatio, projection) {\n    var tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */this.getLayer();\n    var tileSource = /** @type {import(\"../../source/Tile.js\").default} */tileLayer.getSource();\n    var tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (!tileLayer.getUseInterimTilesOnError()) {\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\n        tile.setState(TileState.LOADED);\n      } else if (tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile_(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasTileLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n    var pixelRatio = frameState.pixelRatio;\n    var size = frameState.size;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var viewResolution = viewState.resolution;\n    var viewCenter = viewState.center;\n    var tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */this.getLayer();\n    var tileSource = /** @type {import(\"../../source/Tile.js\").default} */tileLayer.getSource();\n    var sourceRevision = tileSource.getRevision();\n    var tileGrid = tileSource.getTileGridForProjection(projection);\n    var z = tileGrid.getZForResolution(viewResolution, this.zDirection);\n    var tileResolution = tileGrid.getResolution(z);\n    var oversampling = Math.round(viewResolution / tileResolution) || 1;\n    var extent = frameState.extent;\n    if (layerState.extent !== undefined) {\n      extent = getIntersection(extent, layerState.extent);\n    }\n    if (isEmpty(extent)) {\n      // Return false to prevent the rendering of the layer.\n      return false;\n    }\n    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n    var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);\n    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    var tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);\n    var hints = frameState.viewHints;\n    var animatingOrInteracting = hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING];\n    var tmpExtent = this.tmpExtent;\n    var tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    var tile, x, y;\n    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (Date.now() - frameState.time > 16 && animatingOrInteracting) {\n          continue;\n        }\n        tile = this.getTile(z, x, y, pixelRatio, projection);\n        if (this.isDrawableTile_(tile)) {\n          var uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            var inTransition = tile.inTransition(uid);\n            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n        var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);\n        var covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);\n        }\n      }\n    }\n    var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n    if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (this.newTiles_ || !(this.renderedExtent_ && containsExtent(this.renderedExtent_, extent)) || this.renderedRevision != sourceRevision || oversampling != this.oversampling_ || !animatingOrInteracting && renderedResolution != this.renderedResolution)) {\n      var context = this.context;\n      if (context) {\n        var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);\n        var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);\n        var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);\n        var canvas = context.canvas;\n        if (canvas.width != width || canvas.height != height) {\n          this.oversampling_ = oversampling;\n          canvas.width = width;\n          canvas.height = height;\n        } else {\n          if (this.renderedExtent_ && !equals(imageExtent, this.renderedExtent_)) {\n            context.clearRect(0, 0, width, height);\n          }\n          oversampling = this.oversampling_;\n        }\n      }\n      this.renderedTiles.length = 0;\n      /** @type {Array<number>} */\n      var zs = Object.keys(tilesToDrawByZ).map(Number);\n      zs.sort(function (a, b) {\n        if (a === z) {\n          return 1;\n        } else if (b === z) {\n          return -1;\n        } else {\n          return a > b ? 1 : a < b ? -1 : 0;\n        }\n      });\n      var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;\n      var tileExtent, tileGutter, tilesToDraw, w, h;\n      for (i = 0, ii = zs.length; i < ii; ++i) {\n        currentZ = zs[i];\n        currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n        currentResolution = tileGrid.getResolution(currentZ);\n        currentScale = currentResolution / tileResolution;\n        tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n        tilesToDraw = tilesToDrawByZ[currentZ];\n        for (var tileCoordKey in tilesToDraw) {\n          tile = tilesToDraw[tileCoordKey];\n          tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);\n          x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;\n          y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;\n          w = currentTilePixelSize[0] * currentScale / oversampling;\n          h = currentTilePixelSize[1] * currentScale / oversampling;\n          this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);\n          this.renderedTiles.push(tile);\n        }\n      }\n      this.renderedRevision = sourceRevision;\n      this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n      this.renderedExtent_ = imageExtent;\n    }\n    var scale = this.renderedResolution / viewResolution;\n    var transform = composeTransform(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio, (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);\n    composeTransform(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);\n    this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);\n    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());\n    this.scheduleExpireCache(frameState, tileSource);\n    return this.renderedTiles.length > 0;\n  };\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  CanvasTileLayerRenderer.prototype.drawTileImage = function drawTileImage(tile, frameState, layerState, x, y, w, h, gutter, transition) {\n    var image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    var uid = getUid(this);\n    var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n    var tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */this.getLayer();\n    var tileSource = /** @type {import(\"../../source/Tile.js\").default} */tileLayer.getSource();\n    if (alpha === 1 && !tileSource.getOpaque(frameState.viewState.projection)) {\n      this.context.clearRect(x, y, w, h);\n    }\n    var alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== 1) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasTileLayerRenderer.prototype.getImage = function getImage() {\n    var context = this.context;\n    return context ? context.canvas : null;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasTileLayerRenderer.prototype.getImageTransform = function getImageTransform() {\n    return this.imageTransform_;\n  };\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  CanvasTileLayerRenderer.prototype.getTileImage = function getTileImage(tile) {\n    return (/** @type {import(\"../../ImageTile.js\").default} */tile.getImage()\n    );\n  };\n  return CanvasTileLayerRenderer;\n}(IntermediateCanvasRenderer);\n\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\nCanvasTileLayerRenderer['handles'] = function (layer) {\n  return layer.getType() === LayerType.TILE;\n};\n\n/**\n * Create a layer renderer.\n * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n * @return {CanvasTileLayerRenderer} The layer renderer.\n */\nCanvasTileLayerRenderer['create'] = function (mapRenderer, layer) {\n  return new CanvasTileLayerRenderer( /** @type {import(\"../../layer/Tile.js\").default} */layer);\n};\n\n/**\n * @function\n * @return {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default}\n */\nCanvasTileLayerRenderer.prototype.getLayer;\nexport default CanvasTileLayerRenderer;","map":{"version":3,"names":["getUid","LayerType","TileRange","TileState","ViewHint","createCanvasContext2D","containsExtent","createEmpty","equals","getIntersection","isEmpty","IntermediateCanvasRenderer","create","createTransform","compose","composeTransform","CanvasTileLayerRenderer","tileLayer","opt_noContext","call","context","oversampling_","renderedExtent_","renderedRevision","renderedTiles","newTiles_","tmpExtent","tmpTileRange_","imageTransform_","zDirection","isDrawableTile_","tile","getLayer","tileState","getState","useInterimTilesOnError","getUseInterimTilesOnError","LOADED","EMPTY","ERROR","getTile","z","x","y","pixelRatio","projection","tileSource","getSource","setState","getPreload","getInterimTile","prepareFrame","frameState","layerState","size","viewState","viewResolution","resolution","viewCenter","center","sourceRevision","getRevision","tileGrid","getTileGridForProjection","getZForResolution","tileResolution","getResolution","oversampling","Math","round","extent","undefined","tileRange","getTileRangeForExtentAndZ","imageExtent","getTileRangeExtent","tilePixelRatio","getTilePixelRatio","tilesToDrawByZ","findLoadedTiles","createLoadedTileFinder","hints","viewHints","animatingOrInteracting","ANIMATING","INTERACTING","tmpTileRange","minX","maxX","minY","maxY","Date","now","time","uid","tileCoord","toString","inTransition","indexOf","getAlpha","childTileRange","getTileCoordChildTileRange","covered","forEachTileCoordParentTileRange","renderedResolution","tilePixelSize","getTilePixelSize","width","getWidth","height","getHeight","canvas","clearRect","length","zs","Object","keys","map","Number","sort","a","b","currentResolution","currentScale","currentTilePixelSize","currentZ","i","ii","tileExtent","tileGutter","tilesToDraw","w","h","getGutterForProjection","tileCoordKey","getTileCoordExtent","getTileCoord","drawTileImage","push","scale","transform","coordinateToCanvasPixelTransform","updateUsedTiles","usedTiles","manageTilePyramid","scheduleExpireCache","gutter","transition","image","getTileImage","alpha","getOpaque","alphaChanged","globalAlpha","save","drawImage","restore","animate","endTransition","getImage","getImageTransform","layer","getType","TILE","mapRenderer","prototype"],"sources":["../../../../src/ol/renderer/canvas/TileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport {getUid} from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {containsExtent, createEmpty, equals, getIntersection, isEmpty} from '../../extent.js';\nimport IntermediateCanvasRenderer from './IntermediateCanvas.js';\nimport {create as createTransform, compose as composeTransform} from '../../transform.js';\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n */\nclass CanvasTileLayerRenderer extends IntermediateCanvasRenderer {\n\n  /**\n   * @param {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} tileLayer Tile layer.\n   * @param {boolean=} opt_noContext Skip the context creation.\n   */\n  constructor(tileLayer, opt_noContext) {\n\n    super(tileLayer);\n\n    /**\n     * @protected\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = opt_noContext ? null : createCanvasContext2D();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.oversampling_;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.newTiles_ = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tmpExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tmpTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.imageTransform_ = createTransform();\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.zDirection = 0;\n\n  }\n\n  /**\n   * @private\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {boolean} Tile is drawable.\n   */\n  isDrawableTile_(tile) {\n    const tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */ (this.getLayer());\n    const tileState = tile.getState();\n    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();\n    return tileState == TileState.LOADED ||\n        tileState == TileState.EMPTY ||\n        tileState == TileState.ERROR && !useInterimTilesOnError;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../../Tile.js\").default} Tile.\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */ (this.getLayer());\n    const tileSource = /** @type {import(\"../../source/Tile.js\").default} */ (tileLayer.getSource());\n    let tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n    if (tile.getState() == TileState.ERROR) {\n      if (!tileLayer.getUseInterimTilesOnError()) {\n        // When useInterimTilesOnError is false, we consider the error tile as loaded.\n        tile.setState(TileState.LOADED);\n      } else if (tileLayer.getPreload() > 0) {\n        // Preloaded tiles for lower resolutions might have finished loading.\n        this.newTiles_ = true;\n      }\n    }\n    if (!this.isDrawableTile_(tile)) {\n      tile = tile.getInterimTile();\n    }\n    return tile;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  prepareFrame(frameState, layerState) {\n\n    const pixelRatio = frameState.pixelRatio;\n    const size = frameState.size;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n\n    const tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */ (this.getLayer());\n    const tileSource = /** @type {import(\"../../source/Tile.js\").default} */ (tileLayer.getSource());\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, this.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n    let oversampling = Math.round(viewResolution / tileResolution) || 1;\n    let extent = frameState.extent;\n\n    if (layerState.extent !== undefined) {\n      extent = getIntersection(extent, layerState.extent);\n    }\n    if (isEmpty(extent)) {\n      // Return false to prevent the rendering of the layer.\n      return false;\n    }\n\n    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n    const imageExtent = tileGrid.getTileRangeExtent(z, tileRange);\n\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    /**\n     * @type {Object<number, Object<string, import(\"../../Tile.js\").default>>}\n     */\n    const tilesToDrawByZ = {};\n    tilesToDrawByZ[z] = {};\n\n    const findLoadedTiles = this.createLoadedTileFinder(\n      tileSource, projection, tilesToDrawByZ);\n\n    const hints = frameState.viewHints;\n    const animatingOrInteracting = hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING];\n\n    const tmpExtent = this.tmpExtent;\n    const tmpTileRange = this.tmpTileRange_;\n    this.newTiles_ = false;\n    let tile, x, y;\n    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        if (Date.now() - frameState.time > 16 && animatingOrInteracting) {\n          continue;\n        }\n        tile = this.getTile(z, x, y, pixelRatio, projection);\n        if (this.isDrawableTile_(tile)) {\n          const uid = getUid(this);\n          if (tile.getState() == TileState.LOADED) {\n            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;\n            const inTransition = tile.inTransition(uid);\n            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {\n              this.newTiles_ = true;\n            }\n          }\n          if (tile.getAlpha(uid, frameState.time) === 1) {\n            // don't look for alt tiles if alpha is 1\n            continue;\n          }\n        }\n\n        const childTileRange = tileGrid.getTileCoordChildTileRange(\n          tile.tileCoord, tmpTileRange, tmpExtent);\n        let covered = false;\n        if (childTileRange) {\n          covered = findLoadedTiles(z + 1, childTileRange);\n        }\n        if (!covered) {\n          tileGrid.forEachTileCoordParentTileRange(\n            tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);\n        }\n\n      }\n    }\n\n    const renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n    if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (\n      this.newTiles_ ||\n          !(this.renderedExtent_ && containsExtent(this.renderedExtent_, extent)) ||\n          this.renderedRevision != sourceRevision ||\n          oversampling != this.oversampling_ ||\n          !animatingOrInteracting && renderedResolution != this.renderedResolution\n    )) {\n\n      const context = this.context;\n      if (context) {\n        const tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);\n        const width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);\n        const height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);\n        const canvas = context.canvas;\n        if (canvas.width != width || canvas.height != height) {\n          this.oversampling_ = oversampling;\n          canvas.width = width;\n          canvas.height = height;\n        } else {\n          if (this.renderedExtent_ && !equals(imageExtent, this.renderedExtent_)) {\n            context.clearRect(0, 0, width, height);\n          }\n          oversampling = this.oversampling_;\n        }\n      }\n\n      this.renderedTiles.length = 0;\n      /** @type {Array<number>} */\n      const zs = Object.keys(tilesToDrawByZ).map(Number);\n      zs.sort(function(a, b) {\n        if (a === z) {\n          return 1;\n        } else if (b === z) {\n          return -1;\n        } else {\n          return a > b ? 1 : a < b ? -1 : 0;\n        }\n      });\n      let currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;\n      let tileExtent, tileGutter, tilesToDraw, w, h;\n      for (i = 0, ii = zs.length; i < ii; ++i) {\n        currentZ = zs[i];\n        currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n        currentResolution = tileGrid.getResolution(currentZ);\n        currentScale = currentResolution / tileResolution;\n        tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n        tilesToDraw = tilesToDrawByZ[currentZ];\n        for (const tileCoordKey in tilesToDraw) {\n          tile = tilesToDraw[tileCoordKey];\n          tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);\n          x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;\n          y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;\n          w = currentTilePixelSize[0] * currentScale / oversampling;\n          h = currentTilePixelSize[1] * currentScale / oversampling;\n          this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);\n          this.renderedTiles.push(tile);\n        }\n      }\n\n      this.renderedRevision = sourceRevision;\n      this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;\n      this.renderedExtent_ = imageExtent;\n    }\n\n    const scale = this.renderedResolution / viewResolution;\n    const transform = composeTransform(this.imageTransform_,\n      pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,\n      scale, scale,\n      0,\n      (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio,\n      (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);\n    composeTransform(this.coordinateToCanvasPixelTransform,\n      pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],\n      pixelRatio / viewResolution, -pixelRatio / viewResolution,\n      0,\n      -viewCenter[0], -viewCenter[1]);\n\n\n    this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);\n    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio,\n      projection, extent, z, tileLayer.getPreload());\n    this.scheduleExpireCache(frameState, tileSource);\n\n    return this.renderedTiles.length > 0;\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   */\n  drawTileImage(tile, frameState, layerState, x, y, w, h, gutter, transition) {\n    const image = this.getTileImage(tile);\n    if (!image) {\n      return;\n    }\n    const uid = getUid(this);\n    const alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;\n    const tileLayer = /** @type {import(\"../../layer/Tile.js\").default} */ (this.getLayer());\n    const tileSource = /** @type {import(\"../../source/Tile.js\").default} */ (tileLayer.getSource());\n    if (alpha === 1 && !tileSource.getOpaque(frameState.viewState.projection)) {\n      this.context.clearRect(x, y, w, h);\n    }\n    const alphaChanged = alpha !== this.context.globalAlpha;\n    if (alphaChanged) {\n      this.context.save();\n      this.context.globalAlpha = alpha;\n    }\n    this.context.drawImage(image, gutter, gutter,\n      image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n\n    if (alphaChanged) {\n      this.context.restore();\n    }\n    if (alpha !== 1) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getImageTransform() {\n    return this.imageTransform_;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return /** @type {import(\"../../ImageTile.js\").default} */ (tile).getImage();\n  }\n}\n\n\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\nCanvasTileLayerRenderer['handles'] = function(layer) {\n  return layer.getType() === LayerType.TILE;\n};\n\n\n/**\n * Create a layer renderer.\n * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n * @return {CanvasTileLayerRenderer} The layer renderer.\n */\nCanvasTileLayerRenderer['create'] = function(mapRenderer, layer) {\n  return new CanvasTileLayerRenderer(/** @type {import(\"../../layer/Tile.js\").default} */ (layer));\n};\n\n\n/**\n * @function\n * @return {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default}\n */\nCanvasTileLayerRenderer.prototype.getLayer;\n\n\nexport default CanvasTileLayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}