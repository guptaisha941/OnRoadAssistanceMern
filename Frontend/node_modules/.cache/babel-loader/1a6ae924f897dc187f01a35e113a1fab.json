{"ast":null,"code":"/**\n * @module ol/render/canvas/TextReplay\n */\nimport { getUid } from '../../util.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { intersects } from '../../extent.js';\nimport { matchingChunk } from '../../geom/flat/straightchunk.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport { CANVAS_LINE_DASH } from '../../has.js';\nimport { labelCache, measureTextWidth, defaultTextAlign, measureTextHeight, defaultPadding, defaultLineCap, defaultLineDashOffset, defaultLineDash, defaultLineJoin, defaultFillStyle, checkFont, defaultFont, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle, defaultTextBaseline } from '../canvas.js';\nimport CanvasInstruction from './Instruction.js';\nimport CanvasReplay from './Replay.js';\nimport { TEXT_ALIGN } from '../replay.js';\nimport TextPlacement from '../../style/TextPlacement.js';\nvar CanvasTextReplay = /*@__PURE__*/function (CanvasReplay) {\n  function CanvasTextReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    CanvasReplay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n\n    /**\n     * @private\n     * @type {import(\"../canvas.js\").DeclutterGroup}\n     */\n    this.declutterGroup_;\n\n    /**\n     * @private\n     * @type {Array<HTMLCanvasElement>}\n     */\n    this.labels_ = null;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.text_ = '';\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.textOffsetX_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.textOffsetY_ = 0;\n\n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n    this.textRotateWithView_ = undefined;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.textRotation_ = 0;\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").FillState}\n     */\n    this.textFillState_ = null;\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n    this.fillStates = {};\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").StrokeState}\n     */\n    this.textStrokeState_ = null;\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n    this.strokeStates = {};\n\n    /**\n     * @private\n     * @type {import(\"../canvas.js\").TextState}\n     */\n    this.textState_ = /** @type {import(\"../canvas.js\").TextState} */{};\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n    this.textStates = {};\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.textKey_ = '';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.fillKey_ = '';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.strokeKey_ = '';\n\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n    this.widths_ = {};\n    labelCache.prune();\n  }\n  if (CanvasReplay) CanvasTextReplay.__proto__ = CanvasReplay;\n  CanvasTextReplay.prototype = Object.create(CanvasReplay && CanvasReplay.prototype);\n  CanvasTextReplay.prototype.constructor = CanvasTextReplay;\n\n  /**\n   * @inheritDoc\n   */\n  CanvasTextReplay.prototype.drawText = function drawText(geometry, feature) {\n    var fillState = this.textFillState_;\n    var strokeState = this.textStrokeState_;\n    var textState = this.textState_;\n    if (this.text_ === '' || !textState || !fillState && !strokeState) {\n      return;\n    }\n    var begin = this.coordinates.length;\n    var geometryType = geometry.getType();\n    var flatCoordinates = null;\n    var end = 2;\n    var stride = 2;\n    var i, ii;\n    if (textState.placement === TextPlacement.LINE) {\n      if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {\n        return;\n      }\n      var ends;\n      flatCoordinates = geometry.getFlatCoordinates();\n      stride = geometry.getStride();\n      if (geometryType == GeometryType.LINE_STRING) {\n        ends = [flatCoordinates.length];\n      } else if (geometryType == GeometryType.MULTI_LINE_STRING) {\n        ends = geometry.getEnds();\n      } else if (geometryType == GeometryType.POLYGON) {\n        ends = geometry.getEnds().slice(0, 1);\n      } else if (geometryType == GeometryType.MULTI_POLYGON) {\n        var endss = geometry.getEndss();\n        ends = [];\n        for (i = 0, ii = endss.length; i < ii; ++i) {\n          ends.push(endss[i][0]);\n        }\n      }\n      this.beginGeometry(geometry, feature);\n      var textAlign = textState.textAlign;\n      var flatOffset = 0;\n      var flatEnd;\n      for (var o = 0, oo = ends.length; o < oo; ++o) {\n        if (textAlign == undefined) {\n          var range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);\n          flatOffset = range[0];\n          flatEnd = range[1];\n        } else {\n          flatEnd = ends[o];\n        }\n        for (i = flatOffset; i < flatEnd; i += stride) {\n          this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);\n        }\n        end = this.coordinates.length;\n        flatOffset = ends[o];\n        this.drawChars_(begin, end, this.declutterGroup_);\n        begin = end;\n      }\n      this.endGeometry(geometry, feature);\n    } else {\n      var label = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_);\n      var width = label.width / this.pixelRatio;\n      switch (geometryType) {\n        case GeometryType.POINT:\n        case GeometryType.MULTI_POINT:\n          flatCoordinates = geometry.getFlatCoordinates();\n          end = flatCoordinates.length;\n          break;\n        case GeometryType.LINE_STRING:\n          flatCoordinates = /** @type {import(\"../../geom/LineString.js\").default} */geometry.getFlatMidpoint();\n          break;\n        case GeometryType.CIRCLE:\n          flatCoordinates = /** @type {import(\"../../geom/Circle.js\").default} */geometry.getCenter();\n          break;\n        case GeometryType.MULTI_LINE_STRING:\n          flatCoordinates = /** @type {import(\"../../geom/MultiLineString.js\").default} */geometry.getFlatMidpoints();\n          end = flatCoordinates.length;\n          break;\n        case GeometryType.POLYGON:\n          flatCoordinates = /** @type {import(\"../../geom/Polygon.js\").default} */geometry.getFlatInteriorPoint();\n          if (!textState.overflow && flatCoordinates[2] / this.resolution < width) {\n            return;\n          }\n          stride = 3;\n          break;\n        case GeometryType.MULTI_POLYGON:\n          var interiorPoints = /** @type {import(\"../../geom/MultiPolygon.js\").default} */geometry.getFlatInteriorPoints();\n          flatCoordinates = [];\n          for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {\n            if (textState.overflow || interiorPoints[i + 2] / this.resolution >= width) {\n              flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);\n            }\n          }\n          end = flatCoordinates.length;\n          if (end == 0) {\n            return;\n          }\n          break;\n        default:\n      }\n      end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);\n      if (textState.backgroundFill || textState.backgroundStroke) {\n        this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);\n        if (textState.backgroundFill) {\n          this.updateFillStyle(this.state, this.createFill, geometry);\n          this.hitDetectionInstructions.push(this.createFill(this.state, geometry));\n        }\n        if (textState.backgroundStroke) {\n          this.updateStrokeStyle(this.state, this.applyStroke);\n          this.hitDetectionInstructions.push(this.createStroke(this.state));\n        }\n      }\n      this.beginGeometry(geometry, feature);\n      this.drawTextImage_(label, begin, end);\n      this.endGeometry(geometry, feature);\n    }\n  };\n\n  /**\n   * @param {string} text Text.\n   * @param {string} textKey Text style key.\n   * @param {string} fillKey Fill style key.\n   * @param {string} strokeKey Stroke style key.\n   * @return {HTMLCanvasElement} Image.\n   */\n  CanvasTextReplay.prototype.getImage = function getImage(text, textKey, fillKey, strokeKey) {\n    var label;\n    var key = strokeKey + textKey + text + fillKey + this.pixelRatio;\n    if (!labelCache.containsKey(key)) {\n      var strokeState = strokeKey ? this.strokeStates[strokeKey] || this.textStrokeState_ : null;\n      var fillState = fillKey ? this.fillStates[fillKey] || this.textFillState_ : null;\n      var textState = this.textStates[textKey] || this.textState_;\n      var pixelRatio = this.pixelRatio;\n      var scale = textState.scale * pixelRatio;\n      var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\n      var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n      var lines = text.split('\\n');\n      var numLines = lines.length;\n      var widths = [];\n      var width = measureTextWidths(textState.font, lines, widths);\n      var lineHeight = measureTextHeight(textState.font);\n      var height = lineHeight * numLines;\n      var renderWidth = width + strokeWidth;\n      var context = createCanvasContext2D(Math.ceil(renderWidth * scale), Math.ceil((height + strokeWidth) * scale));\n      label = context.canvas;\n      labelCache.set(key, label);\n      if (scale != 1) {\n        context.scale(scale, scale);\n      }\n      context.font = textState.font;\n      if (strokeKey) {\n        context.strokeStyle = strokeState.strokeStyle;\n        context.lineWidth = strokeWidth;\n        context.lineCap = /** @type {CanvasLineCap} */strokeState.lineCap;\n        context.lineJoin = /** @type {CanvasLineJoin} */strokeState.lineJoin;\n        context.miterLimit = strokeState.miterLimit;\n        if (CANVAS_LINE_DASH && strokeState.lineDash.length) {\n          context.setLineDash(strokeState.lineDash);\n          context.lineDashOffset = strokeState.lineDashOffset;\n        }\n      }\n      if (fillKey) {\n        context.fillStyle = fillState.fillStyle;\n      }\n      context.textBaseline = 'middle';\n      context.textAlign = 'center';\n      var leftRight = 0.5 - align;\n      var x = align * label.width / scale + leftRight * strokeWidth;\n      var i;\n      if (strokeKey) {\n        for (i = 0; i < numLines; ++i) {\n          context.strokeText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);\n        }\n      }\n      if (fillKey) {\n        for (i = 0; i < numLines; ++i) {\n          context.fillText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);\n        }\n      }\n    }\n    return labelCache.get(key);\n  };\n\n  /**\n   * @private\n   * @param {HTMLCanvasElement} label Label.\n   * @param {number} begin Begin.\n   * @param {number} end End.\n   */\n  CanvasTextReplay.prototype.drawTextImage_ = function drawTextImage_(label, begin, end) {\n    var textState = this.textState_;\n    var strokeState = this.textStrokeState_;\n    var pixelRatio = this.pixelRatio;\n    var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\n    var baseline = TEXT_ALIGN[textState.textBaseline];\n    var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n    var anchorX = align * label.width / pixelRatio + 2 * (0.5 - align) * strokeWidth;\n    var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;\n    this.instructions.push([CanvasInstruction.DRAW_IMAGE, begin, end, label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio, this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1, label.width, textState.padding == defaultPadding ? defaultPadding : textState.padding.map(function (p) {\n      return p * pixelRatio;\n    }), !!textState.backgroundFill, !!textState.backgroundStroke]);\n    this.hitDetectionInstructions.push([CanvasInstruction.DRAW_IMAGE, begin, end, label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio, this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1 / pixelRatio, label.width, textState.padding, !!textState.backgroundFill, !!textState.backgroundStroke]);\n  };\n\n  /**\n   * @private\n   * @param {number} begin Begin.\n   * @param {number} end End.\n   * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n   */\n  CanvasTextReplay.prototype.drawChars_ = function drawChars_(begin, end, declutterGroup) {\n    var strokeState = this.textStrokeState_;\n    var textState = this.textState_;\n    var fillState = this.textFillState_;\n    var strokeKey = this.strokeKey_;\n    if (strokeState) {\n      if (!(strokeKey in this.strokeStates)) {\n        this.strokeStates[strokeKey] = /** @type {import(\"../canvas.js\").StrokeState} */{\n          strokeStyle: strokeState.strokeStyle,\n          lineCap: strokeState.lineCap,\n          lineDashOffset: strokeState.lineDashOffset,\n          lineWidth: strokeState.lineWidth,\n          lineJoin: strokeState.lineJoin,\n          miterLimit: strokeState.miterLimit,\n          lineDash: strokeState.lineDash\n        };\n      }\n    }\n    var textKey = this.textKey_;\n    if (!(this.textKey_ in this.textStates)) {\n      this.textStates[this.textKey_] = /** @type {import(\"../canvas.js\").TextState} */{\n        font: textState.font,\n        textAlign: textState.textAlign || defaultTextAlign,\n        scale: textState.scale\n      };\n    }\n    var fillKey = this.fillKey_;\n    if (fillState) {\n      if (!(fillKey in this.fillStates)) {\n        this.fillStates[fillKey] = /** @type {import(\"../canvas.js\").FillState} */{\n          fillStyle: fillState.fillStyle\n        };\n      }\n    }\n    var pixelRatio = this.pixelRatio;\n    var baseline = TEXT_ALIGN[textState.textBaseline];\n    var offsetY = this.textOffsetY_ * pixelRatio;\n    var text = this.text_;\n    var font = textState.font;\n    var textScale = textState.scale;\n    var strokeWidth = strokeState ? strokeState.lineWidth * textScale / 2 : 0;\n    var widths = this.widths_[font];\n    if (!widths) {\n      this.widths_[font] = widths = {};\n    }\n    this.instructions.push([CanvasInstruction.DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, function (text) {\n      var width = widths[text];\n      if (!width) {\n        width = widths[text] = measureTextWidth(font, text);\n      }\n      return width * textScale * pixelRatio;\n    }, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1]);\n    this.hitDetectionInstructions.push([CanvasInstruction.DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, function (text) {\n      var width = widths[text];\n      if (!width) {\n        width = widths[text] = measureTextWidth(font, text);\n      }\n      return width * textScale;\n    }, offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio]);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasTextReplay.prototype.setTextStyle = function setTextStyle(textStyle, declutterGroup) {\n    var textState, fillState, strokeState;\n    if (!textStyle) {\n      this.text_ = '';\n    } else {\n      this.declutterGroup_ = /** @type {import(\"../canvas.js\").DeclutterGroup} */declutterGroup;\n      var textFillStyle = textStyle.getFill();\n      if (!textFillStyle) {\n        fillState = this.textFillState_ = null;\n      } else {\n        fillState = this.textFillState_;\n        if (!fillState) {\n          fillState = this.textFillState_ = /** @type {import(\"../canvas.js\").FillState} */{};\n        }\n        fillState.fillStyle = asColorLike(textFillStyle.getColor() || defaultFillStyle);\n      }\n      var textStrokeStyle = textStyle.getStroke();\n      if (!textStrokeStyle) {\n        strokeState = this.textStrokeState_ = null;\n      } else {\n        strokeState = this.textStrokeState_;\n        if (!strokeState) {\n          strokeState = this.textStrokeState_ = /** @type {import(\"../canvas.js\").StrokeState} */{};\n        }\n        var lineDash = textStrokeStyle.getLineDash();\n        var lineDashOffset = textStrokeStyle.getLineDashOffset();\n        var lineWidth = textStrokeStyle.getWidth();\n        var miterLimit = textStrokeStyle.getMiterLimit();\n        strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;\n        strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;\n        strokeState.lineDashOffset = lineDashOffset === undefined ? defaultLineDashOffset : lineDashOffset;\n        strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;\n        strokeState.lineWidth = lineWidth === undefined ? defaultLineWidth : lineWidth;\n        strokeState.miterLimit = miterLimit === undefined ? defaultMiterLimit : miterLimit;\n        strokeState.strokeStyle = asColorLike(textStrokeStyle.getColor() || defaultStrokeStyle);\n      }\n      textState = this.textState_;\n      var font = textStyle.getFont() || defaultFont;\n      checkFont(font);\n      var textScale = textStyle.getScale();\n      textState.overflow = textStyle.getOverflow();\n      textState.font = font;\n      textState.maxAngle = textStyle.getMaxAngle();\n      textState.placement = textStyle.getPlacement();\n      textState.textAlign = textStyle.getTextAlign();\n      textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;\n      textState.backgroundFill = textStyle.getBackgroundFill();\n      textState.backgroundStroke = textStyle.getBackgroundStroke();\n      textState.padding = textStyle.getPadding() || defaultPadding;\n      textState.scale = textScale === undefined ? 1 : textScale;\n      var textOffsetX = textStyle.getOffsetX();\n      var textOffsetY = textStyle.getOffsetY();\n      var textRotateWithView = textStyle.getRotateWithView();\n      var textRotation = textStyle.getRotation();\n      this.text_ = textStyle.getText() || '';\n      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;\n      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;\n      this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;\n      this.textRotation_ = textRotation === undefined ? 0 : textRotation;\n      this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' : '';\n      this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?');\n      this.fillKey_ = fillState ? typeof fillState.fillStyle == 'string' ? fillState.fillStyle : '|' + getUid(fillState.fillStyle) : '';\n    }\n  };\n  return CanvasTextReplay;\n}(CanvasReplay);\n\n/**\n * @param {string} font Font to use for measuring.\n * @param {Array<string>} lines Lines to measure.\n * @param {Array<number>} widths Array will be populated with the widths of\n * each line.\n * @return {number} Width of the whole text.\n */\nexport function measureTextWidths(font, lines, widths) {\n  var numLines = lines.length;\n  var width = 0;\n  for (var i = 0; i < numLines; ++i) {\n    var currentWidth = measureTextWidth(font, lines[i]);\n    width = Math.max(width, currentWidth);\n    widths.push(currentWidth);\n  }\n  return width;\n}\nexport default CanvasTextReplay;","map":{"version":3,"names":["getUid","asColorLike","createCanvasContext2D","intersects","matchingChunk","GeometryType","CANVAS_LINE_DASH","labelCache","measureTextWidth","defaultTextAlign","measureTextHeight","defaultPadding","defaultLineCap","defaultLineDashOffset","defaultLineDash","defaultLineJoin","defaultFillStyle","checkFont","defaultFont","defaultLineWidth","defaultMiterLimit","defaultStrokeStyle","defaultTextBaseline","CanvasInstruction","CanvasReplay","TEXT_ALIGN","TextPlacement","CanvasTextReplay","tolerance","maxExtent","resolution","pixelRatio","overlaps","declutterTree","call","declutterGroup_","labels_","text_","textOffsetX_","textOffsetY_","textRotateWithView_","undefined","textRotation_","textFillState_","fillStates","textStrokeState_","strokeStates","textState_","textStates","textKey_","fillKey_","strokeKey_","widths_","prune","drawText","geometry","feature","fillState","strokeState","textState","begin","coordinates","length","geometryType","getType","flatCoordinates","end","stride","i","ii","placement","LINE","getBufferedMaxExtent","getExtent","ends","getFlatCoordinates","getStride","LINE_STRING","MULTI_LINE_STRING","getEnds","POLYGON","slice","MULTI_POLYGON","endss","getEndss","push","beginGeometry","textAlign","flatOffset","flatEnd","o","oo","range","maxAngle","drawChars_","endGeometry","label","getImage","width","POINT","MULTI_POINT","getFlatMidpoint","CIRCLE","getCenter","getFlatMidpoints","getFlatInteriorPoint","overflow","interiorPoints","getFlatInteriorPoints","appendFlatCoordinates","backgroundFill","backgroundStroke","setFillStrokeStyle","updateFillStyle","state","createFill","hitDetectionInstructions","updateStrokeStyle","applyStroke","createStroke","drawTextImage_","text","textKey","fillKey","strokeKey","key","containsKey","scale","align","strokeWidth","lineWidth","lines","split","numLines","widths","measureTextWidths","font","lineHeight","height","renderWidth","context","Math","ceil","canvas","set","strokeStyle","lineCap","lineJoin","miterLimit","lineDash","setLineDash","lineDashOffset","fillStyle","textBaseline","leftRight","x","strokeText","fillText","get","baseline","anchorX","anchorY","instructions","DRAW_IMAGE","padding","map","p","declutterGroup","offsetY","textScale","DRAW_CHARS","setTextStyle","textStyle","textFillStyle","getFill","getColor","textStrokeStyle","getStroke","getLineDash","getLineDashOffset","getWidth","getMiterLimit","getLineCap","getLineJoin","getFont","getScale","getOverflow","getMaxAngle","getPlacement","getTextAlign","getTextBaseline","getBackgroundFill","getBackgroundStroke","getPadding","textOffsetX","getOffsetX","textOffsetY","getOffsetY","textRotateWithView","getRotateWithView","textRotation","getRotation","getText","join","currentWidth","max"],"sources":["../../../../src/ol/render/canvas/TextReplay.js"],"sourcesContent":["/**\n * @module ol/render/canvas/TextReplay\n */\nimport {getUid} from '../../util.js';\nimport {asColorLike} from '../../colorlike.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {intersects} from '../../extent.js';\nimport {matchingChunk} from '../../geom/flat/straightchunk.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport {CANVAS_LINE_DASH} from '../../has.js';\nimport {labelCache, measureTextWidth, defaultTextAlign, measureTextHeight, defaultPadding, defaultLineCap, defaultLineDashOffset, defaultLineDash, defaultLineJoin, defaultFillStyle, checkFont, defaultFont, defaultLineWidth, defaultMiterLimit, defaultStrokeStyle, defaultTextBaseline} from '../canvas.js';\nimport CanvasInstruction from './Instruction.js';\nimport CanvasReplay from './Replay.js';\nimport {TEXT_ALIGN} from '../replay.js';\nimport TextPlacement from '../../style/TextPlacement.js';\n\nclass CanvasTextReplay extends CanvasReplay {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {?} declutterTree Declutter tree.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    super(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);\n\n    /**\n     * @private\n     * @type {import(\"../canvas.js\").DeclutterGroup}\n     */\n    this.declutterGroup_;\n\n    /**\n     * @private\n     * @type {Array<HTMLCanvasElement>}\n     */\n    this.labels_ = null;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.text_ = '';\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.textOffsetX_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.textOffsetY_ = 0;\n\n    /**\n     * @private\n     * @type {boolean|undefined}\n     */\n    this.textRotateWithView_ = undefined;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.textRotation_ = 0;\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").FillState}\n     */\n    this.textFillState_ = null;\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").FillState>}\n     */\n    this.fillStates = {};\n\n    /**\n     * @private\n     * @type {?import(\"../canvas.js\").StrokeState}\n     */\n    this.textStrokeState_ = null;\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").StrokeState>}\n     */\n    this.strokeStates = {};\n\n    /**\n     * @private\n     * @type {import(\"../canvas.js\").TextState}\n     */\n    this.textState_ = /** @type {import(\"../canvas.js\").TextState} */ ({});\n\n    /**\n     * @type {!Object<string, import(\"../canvas.js\").TextState>}\n     */\n    this.textStates = {};\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.textKey_ = '';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.fillKey_ = '';\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.strokeKey_ = '';\n\n    /**\n     * @private\n     * @type {Object<string, Object<string, number>>}\n     */\n    this.widths_ = {};\n\n    labelCache.prune();\n\n  }\n\n  /**\n   * @inheritDoc\n   */\n  drawText(geometry, feature) {\n    const fillState = this.textFillState_;\n    const strokeState = this.textStrokeState_;\n    const textState = this.textState_;\n    if (this.text_ === '' || !textState || (!fillState && !strokeState)) {\n      return;\n    }\n\n    let begin = this.coordinates.length;\n\n    const geometryType = geometry.getType();\n    let flatCoordinates = null;\n    let end = 2;\n    let stride = 2;\n    let i, ii;\n\n    if (textState.placement === TextPlacement.LINE) {\n      if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {\n        return;\n      }\n      let ends;\n      flatCoordinates = geometry.getFlatCoordinates();\n      stride = geometry.getStride();\n      if (geometryType == GeometryType.LINE_STRING) {\n        ends = [flatCoordinates.length];\n      } else if (geometryType == GeometryType.MULTI_LINE_STRING) {\n        ends = geometry.getEnds();\n      } else if (geometryType == GeometryType.POLYGON) {\n        ends = geometry.getEnds().slice(0, 1);\n      } else if (geometryType == GeometryType.MULTI_POLYGON) {\n        const endss = geometry.getEndss();\n        ends = [];\n        for (i = 0, ii = endss.length; i < ii; ++i) {\n          ends.push(endss[i][0]);\n        }\n      }\n      this.beginGeometry(geometry, feature);\n      const textAlign = textState.textAlign;\n      let flatOffset = 0;\n      let flatEnd;\n      for (let o = 0, oo = ends.length; o < oo; ++o) {\n        if (textAlign == undefined) {\n          const range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);\n          flatOffset = range[0];\n          flatEnd = range[1];\n        } else {\n          flatEnd = ends[o];\n        }\n        for (i = flatOffset; i < flatEnd; i += stride) {\n          this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);\n        }\n        end = this.coordinates.length;\n        flatOffset = ends[o];\n        this.drawChars_(begin, end, this.declutterGroup_);\n        begin = end;\n      }\n      this.endGeometry(geometry, feature);\n\n    } else {\n      const label = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_);\n      const width = label.width / this.pixelRatio;\n      switch (geometryType) {\n        case GeometryType.POINT:\n        case GeometryType.MULTI_POINT:\n          flatCoordinates = geometry.getFlatCoordinates();\n          end = flatCoordinates.length;\n          break;\n        case GeometryType.LINE_STRING:\n          flatCoordinates = /** @type {import(\"../../geom/LineString.js\").default} */ (geometry).getFlatMidpoint();\n          break;\n        case GeometryType.CIRCLE:\n          flatCoordinates = /** @type {import(\"../../geom/Circle.js\").default} */ (geometry).getCenter();\n          break;\n        case GeometryType.MULTI_LINE_STRING:\n          flatCoordinates = /** @type {import(\"../../geom/MultiLineString.js\").default} */ (geometry).getFlatMidpoints();\n          end = flatCoordinates.length;\n          break;\n        case GeometryType.POLYGON:\n          flatCoordinates = /** @type {import(\"../../geom/Polygon.js\").default} */ (geometry).getFlatInteriorPoint();\n          if (!textState.overflow && flatCoordinates[2] / this.resolution < width) {\n            return;\n          }\n          stride = 3;\n          break;\n        case GeometryType.MULTI_POLYGON:\n          const interiorPoints = /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (geometry).getFlatInteriorPoints();\n          flatCoordinates = [];\n          for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {\n            if (textState.overflow || interiorPoints[i + 2] / this.resolution >= width) {\n              flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);\n            }\n          }\n          end = flatCoordinates.length;\n          if (end == 0) {\n            return;\n          }\n          break;\n        default:\n      }\n      end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);\n      if (textState.backgroundFill || textState.backgroundStroke) {\n        this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);\n        if (textState.backgroundFill) {\n          this.updateFillStyle(this.state, this.createFill, geometry);\n          this.hitDetectionInstructions.push(this.createFill(this.state, geometry));\n        }\n        if (textState.backgroundStroke) {\n          this.updateStrokeStyle(this.state, this.applyStroke);\n          this.hitDetectionInstructions.push(this.createStroke(this.state));\n        }\n      }\n      this.beginGeometry(geometry, feature);\n      this.drawTextImage_(label, begin, end);\n      this.endGeometry(geometry, feature);\n    }\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {string} textKey Text style key.\n   * @param {string} fillKey Fill style key.\n   * @param {string} strokeKey Stroke style key.\n   * @return {HTMLCanvasElement} Image.\n   */\n  getImage(text, textKey, fillKey, strokeKey) {\n    let label;\n    const key = strokeKey + textKey + text + fillKey + this.pixelRatio;\n\n    if (!labelCache.containsKey(key)) {\n      const strokeState = strokeKey ? this.strokeStates[strokeKey] || this.textStrokeState_ : null;\n      const fillState = fillKey ? this.fillStates[fillKey] || this.textFillState_ : null;\n      const textState = this.textStates[textKey] || this.textState_;\n      const pixelRatio = this.pixelRatio;\n      const scale = textState.scale * pixelRatio;\n      const align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\n      const strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;\n\n      const lines = text.split('\\n');\n      const numLines = lines.length;\n      const widths = [];\n      const width = measureTextWidths(textState.font, lines, widths);\n      const lineHeight = measureTextHeight(textState.font);\n      const height = lineHeight * numLines;\n      const renderWidth = (width + strokeWidth);\n      const context = createCanvasContext2D(\n        Math.ceil(renderWidth * scale),\n        Math.ceil((height + strokeWidth) * scale));\n      label = context.canvas;\n      labelCache.set(key, label);\n      if (scale != 1) {\n        context.scale(scale, scale);\n      }\n      context.font = textState.font;\n      if (strokeKey) {\n        context.strokeStyle = strokeState.strokeStyle;\n        context.lineWidth = strokeWidth;\n        context.lineCap = /** @type {CanvasLineCap} */ (strokeState.lineCap);\n        context.lineJoin = /** @type {CanvasLineJoin} */ (strokeState.lineJoin);\n        context.miterLimit = strokeState.miterLimit;\n        if (CANVAS_LINE_DASH && strokeState.lineDash.length) {\n          context.setLineDash(strokeState.lineDash);\n          context.lineDashOffset = strokeState.lineDashOffset;\n        }\n      }\n      if (fillKey) {\n        context.fillStyle = fillState.fillStyle;\n      }\n      context.textBaseline = 'middle';\n      context.textAlign = 'center';\n      const leftRight = (0.5 - align);\n      const x = align * label.width / scale + leftRight * strokeWidth;\n      let i;\n      if (strokeKey) {\n        for (i = 0; i < numLines; ++i) {\n          context.strokeText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);\n        }\n      }\n      if (fillKey) {\n        for (i = 0; i < numLines; ++i) {\n          context.fillText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);\n        }\n      }\n    }\n    return labelCache.get(key);\n  }\n\n  /**\n   * @private\n   * @param {HTMLCanvasElement} label Label.\n   * @param {number} begin Begin.\n   * @param {number} end End.\n   */\n  drawTextImage_(label, begin, end) {\n    const textState = this.textState_;\n    const strokeState = this.textStrokeState_;\n    const pixelRatio = this.pixelRatio;\n    const align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];\n    const baseline = TEXT_ALIGN[textState.textBaseline];\n    const strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;\n\n    const anchorX = align * label.width / pixelRatio + 2 * (0.5 - align) * strokeWidth;\n    const anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;\n    this.instructions.push([CanvasInstruction.DRAW_IMAGE, begin, end,\n      label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio,\n      this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_,\n      1, label.width,\n      textState.padding == defaultPadding ?\n        defaultPadding : textState.padding.map(function(p) {\n          return p * pixelRatio;\n        }),\n      !!textState.backgroundFill, !!textState.backgroundStroke\n    ]);\n    this.hitDetectionInstructions.push([CanvasInstruction.DRAW_IMAGE, begin, end,\n      label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio,\n      this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_,\n      1 / pixelRatio, label.width, textState.padding,\n      !!textState.backgroundFill, !!textState.backgroundStroke\n    ]);\n  }\n\n  /**\n   * @private\n   * @param {number} begin Begin.\n   * @param {number} end End.\n   * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n   */\n  drawChars_(begin, end, declutterGroup) {\n    const strokeState = this.textStrokeState_;\n    const textState = this.textState_;\n    const fillState = this.textFillState_;\n\n    const strokeKey = this.strokeKey_;\n    if (strokeState) {\n      if (!(strokeKey in this.strokeStates)) {\n        this.strokeStates[strokeKey] = /** @type {import(\"../canvas.js\").StrokeState} */ ({\n          strokeStyle: strokeState.strokeStyle,\n          lineCap: strokeState.lineCap,\n          lineDashOffset: strokeState.lineDashOffset,\n          lineWidth: strokeState.lineWidth,\n          lineJoin: strokeState.lineJoin,\n          miterLimit: strokeState.miterLimit,\n          lineDash: strokeState.lineDash\n        });\n      }\n    }\n    const textKey = this.textKey_;\n    if (!(this.textKey_ in this.textStates)) {\n      this.textStates[this.textKey_] = /** @type {import(\"../canvas.js\").TextState} */ ({\n        font: textState.font,\n        textAlign: textState.textAlign || defaultTextAlign,\n        scale: textState.scale\n      });\n    }\n    const fillKey = this.fillKey_;\n    if (fillState) {\n      if (!(fillKey in this.fillStates)) {\n        this.fillStates[fillKey] = /** @type {import(\"../canvas.js\").FillState} */ ({\n          fillStyle: fillState.fillStyle\n        });\n      }\n    }\n\n    const pixelRatio = this.pixelRatio;\n    const baseline = TEXT_ALIGN[textState.textBaseline];\n\n    const offsetY = this.textOffsetY_ * pixelRatio;\n    const text = this.text_;\n    const font = textState.font;\n    const textScale = textState.scale;\n    const strokeWidth = strokeState ? strokeState.lineWidth * textScale / 2 : 0;\n    let widths = this.widths_[font];\n    if (!widths) {\n      this.widths_[font] = widths = {};\n    }\n    this.instructions.push([CanvasInstruction.DRAW_CHARS,\n      begin, end, baseline, declutterGroup,\n      textState.overflow, fillKey, textState.maxAngle,\n      function(text) {\n        let width = widths[text];\n        if (!width) {\n          width = widths[text] = measureTextWidth(font, text);\n        }\n        return width * textScale * pixelRatio;\n      },\n      offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1\n    ]);\n    this.hitDetectionInstructions.push([CanvasInstruction.DRAW_CHARS,\n      begin, end, baseline, declutterGroup,\n      textState.overflow, fillKey, textState.maxAngle,\n      function(text) {\n        let width = widths[text];\n        if (!width) {\n          width = widths[text] = measureTextWidth(font, text);\n        }\n        return width * textScale;\n      },\n      offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio\n    ]);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setTextStyle(textStyle, declutterGroup) {\n    let textState, fillState, strokeState;\n    if (!textStyle) {\n      this.text_ = '';\n    } else {\n      this.declutterGroup_ = /** @type {import(\"../canvas.js\").DeclutterGroup} */ (declutterGroup);\n\n      const textFillStyle = textStyle.getFill();\n      if (!textFillStyle) {\n        fillState = this.textFillState_ = null;\n      } else {\n        fillState = this.textFillState_;\n        if (!fillState) {\n          fillState = this.textFillState_ = /** @type {import(\"../canvas.js\").FillState} */ ({});\n        }\n        fillState.fillStyle = asColorLike(\n          textFillStyle.getColor() || defaultFillStyle);\n      }\n\n      const textStrokeStyle = textStyle.getStroke();\n      if (!textStrokeStyle) {\n        strokeState = this.textStrokeState_ = null;\n      } else {\n        strokeState = this.textStrokeState_;\n        if (!strokeState) {\n          strokeState = this.textStrokeState_ = /** @type {import(\"../canvas.js\").StrokeState} */ ({});\n        }\n        const lineDash = textStrokeStyle.getLineDash();\n        const lineDashOffset = textStrokeStyle.getLineDashOffset();\n        const lineWidth = textStrokeStyle.getWidth();\n        const miterLimit = textStrokeStyle.getMiterLimit();\n        strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;\n        strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;\n        strokeState.lineDashOffset =\n            lineDashOffset === undefined ? defaultLineDashOffset : lineDashOffset;\n        strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;\n        strokeState.lineWidth =\n            lineWidth === undefined ? defaultLineWidth : lineWidth;\n        strokeState.miterLimit =\n            miterLimit === undefined ? defaultMiterLimit : miterLimit;\n        strokeState.strokeStyle = asColorLike(\n          textStrokeStyle.getColor() || defaultStrokeStyle);\n      }\n\n      textState = this.textState_;\n      const font = textStyle.getFont() || defaultFont;\n      checkFont(font);\n      const textScale = textStyle.getScale();\n      textState.overflow = textStyle.getOverflow();\n      textState.font = font;\n      textState.maxAngle = textStyle.getMaxAngle();\n      textState.placement = textStyle.getPlacement();\n      textState.textAlign = textStyle.getTextAlign();\n      textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;\n      textState.backgroundFill = textStyle.getBackgroundFill();\n      textState.backgroundStroke = textStyle.getBackgroundStroke();\n      textState.padding = textStyle.getPadding() || defaultPadding;\n      textState.scale = textScale === undefined ? 1 : textScale;\n\n      const textOffsetX = textStyle.getOffsetX();\n      const textOffsetY = textStyle.getOffsetY();\n      const textRotateWithView = textStyle.getRotateWithView();\n      const textRotation = textStyle.getRotation();\n      this.text_ = textStyle.getText() || '';\n      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;\n      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;\n      this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;\n      this.textRotation_ = textRotation === undefined ? 0 : textRotation;\n\n      this.strokeKey_ = strokeState ?\n        (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) +\n        strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth +\n        strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' :\n        '';\n      this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?');\n      this.fillKey_ = fillState ?\n        (typeof fillState.fillStyle == 'string' ? fillState.fillStyle : ('|' + getUid(fillState.fillStyle))) :\n        '';\n    }\n  }\n}\n\n\n/**\n * @param {string} font Font to use for measuring.\n * @param {Array<string>} lines Lines to measure.\n * @param {Array<number>} widths Array will be populated with the widths of\n * each line.\n * @return {number} Width of the whole text.\n */\nexport function measureTextWidths(font, lines, widths) {\n  const numLines = lines.length;\n  let width = 0;\n  for (let i = 0; i < numLines; ++i) {\n    const currentWidth = measureTextWidth(font, lines[i]);\n    width = Math.max(width, currentWidth);\n    widths.push(currentWidth);\n  }\n  return width;\n}\n\n\nexport default CanvasTextReplay;\n"],"mappings":"AAAA;;;AAGA,SAAQA,MAAM,QAAO,eAAe;AACpC,SAAQC,WAAW,QAAO,oBAAoB;AAC9C,SAAQC,qBAAqB,QAAO,cAAc;AAClD,SAAQC,UAAU,QAAO,iBAAiB;AAC1C,SAAQC,aAAa,QAAO,kCAAkC;AAC9D,OAAOC,YAAY,MAAM,4BAA4B;AACrD,SAAQC,gBAAgB,QAAO,cAAc;AAC7C,SAAQC,UAAU,EAAEC,gBAAgB,EAAEC,gBAAgB,EAAEC,iBAAiB,EAAEC,cAAc,EAAEC,cAAc,EAAEC,qBAAqB,EAAEC,eAAe,EAAEC,eAAe,EAAEC,gBAAgB,EAAEC,SAAS,EAAEC,WAAW,EAAEC,gBAAgB,EAAEC,iBAAiB,EAAEC,kBAAkB,EAAEC,mBAAmB,QAAO,cAAc;AAC/S,OAAOC,iBAAiB,MAAM,kBAAkB;AAChD,OAAOC,YAAY,MAAM,aAAa;AACtC,SAAQC,UAAU,QAAO,cAAc;AACvC,OAAOC,aAAa,MAAM,8BAA8B;AAExD,IAAMC,gBAAgB,GAAqB,uBAAAH,YAAA;EASzC,SAAAG,gBAAWA,CAACC,SAAS,EAAEC,SAAS,EAAEC,UAAU,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,aAAa,EAAE;IACjFT,YAAA,CAAAU,IAAK,OAACN,SAAS,EAAEC,SAAS,EAAEC,UAAU,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,aAAa,CAAC;;;;;;IAM5E,IAAI,CAACE,eAAe;;;;;;IAMpB,IAAI,CAACC,OAAO,GAAG,IAAI;;;;;;IAMnB,IAAI,CAACC,KAAK,GAAG,EAAE;;;;;;IAMf,IAAI,CAACC,YAAY,GAAG,CAAC;;;;;;IAMrB,IAAI,CAACC,YAAY,GAAG,CAAC;;;;;;IAMrB,IAAI,CAACC,mBAAmB,GAAGC,SAAS;;;;;;IAMpC,IAAI,CAACC,aAAa,GAAG,CAAC;;;;;;IAMtB,IAAI,CAACC,cAAc,GAAG,IAAI;;;;;IAK1B,IAAI,CAACC,UAAU,GAAG,EAAE;;;;;;IAMpB,IAAI,CAACC,gBAAgB,GAAG,IAAI;;;;;IAK5B,IAAI,CAACC,YAAY,GAAG,EAAE;;;;;;IAMtB,IAAI,CAACC,UAAU,kDAAoD,EAAG;;;;;IAKtE,IAAI,CAACC,UAAU,GAAG,EAAE;;;;;;IAMpB,IAAI,CAACC,QAAQ,GAAG,EAAE;;;;;;IAMlB,IAAI,CAACC,QAAQ,GAAG,EAAE;;;;;;IAMlB,IAAI,CAACC,UAAU,GAAG,EAAE;;;;;;IAMpB,IAAI,CAACC,OAAO,GAAG,EAAE;IAEjB7C,UAAU,CAAC8C,KAAK,EAAE;;;;;;;;;6BAOpBC,QAAA,YAAAA,SAASC,QAAQ,EAAEC,OAAO,EAAE;IAC1B,IAAMC,SAAS,GAAG,IAAI,CAACd,cAAc;IACrC,IAAMe,WAAW,GAAG,IAAI,CAACb,gBAAgB;IACzC,IAAMc,SAAS,GAAG,IAAI,CAACZ,UAAU;IACjC,IAAI,IAAI,CAACV,KAAK,KAAK,EAAE,IAAI,CAACsB,SAAS,IAAK,CAACF,SAAS,IAAI,CAACC,WAAY,EAAE;MACnE;;IAGF,IAAIE,KAAK,GAAG,IAAI,CAACC,WAAW,CAACC,MAAM;IAEnC,IAAMC,YAAY,GAAGR,QAAQ,CAACS,OAAO,EAAE;IACvC,IAAIC,eAAe,GAAG,IAAI;IAC1B,IAAIC,GAAG,GAAG,CAAC;IACX,IAAIC,MAAM,GAAG,CAAC;IACd,IAAIC,CAAC,EAAEC,EAAE;IAET,IAAIV,SAAS,CAACW,SAAS,KAAK5C,aAAa,CAAC6C,IAAI,EAAE;MAC9C,IAAI,CAACpE,UAAU,CAAC,IAAI,CAACqE,oBAAoB,EAAE,EAAEjB,QAAQ,CAACkB,SAAS,EAAE,CAAC,EAAE;QAClE;;MAEF,IAAIC,IAAI;MACRT,eAAe,GAAGV,QAAQ,CAACoB,kBAAkB,EAAE;MAC/CR,MAAM,GAAGZ,QAAQ,CAACqB,SAAS,EAAE;MAC7B,IAAIb,YAAY,IAAI1D,YAAY,CAACwE,WAAW,EAAE;QAC5CH,IAAI,GAAG,CAACT,eAAe,CAACH,MAAM,CAAC;OAChC,MAAM,IAAIC,YAAY,IAAI1D,YAAY,CAACyE,iBAAiB,EAAE;QACzDJ,IAAI,GAAGnB,QAAQ,CAACwB,OAAO,EAAE;OAC1B,MAAM,IAAIhB,YAAY,IAAI1D,YAAY,CAAC2E,OAAO,EAAE;QAC/CN,IAAI,GAAGnB,QAAQ,CAACwB,OAAO,EAAE,CAACE,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;OACtC,MAAM,IAAIlB,YAAY,IAAI1D,YAAY,CAAC6E,aAAa,EAAE;QACrD,IAAMC,KAAK,GAAG5B,QAAQ,CAAC6B,QAAQ,EAAE;QACjCV,IAAI,GAAG,EAAE;QACT,KAAKN,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGc,KAAK,CAACrB,MAAM,EAAEM,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;UAC1CM,IAAI,CAACW,IAAI,CAACF,KAAK,CAACf,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;;;MAG1B,IAAI,CAACkB,aAAa,CAAC/B,QAAQ,EAAEC,OAAO,CAAC;MACrC,IAAM+B,SAAS,GAAG5B,SAAS,CAAC4B,SAAS;MACrC,IAAIC,UAAU,GAAG,CAAC;MAClB,IAAIC,OAAO;MACX,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGjB,IAAI,CAACZ,MAAM,EAAE4B,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;QAC7C,IAAIH,SAAS,IAAI9C,SAAS,EAAE;UAC1B,IAAMmD,KAAK,GAAGxF,aAAa,CAACuD,SAAS,CAACkC,QAAQ,EAAE5B,eAAe,EAAEuB,UAAU,EAAEd,IAAI,CAACgB,CAAC,CAAC,EAAEvB,MAAM,CAAC;UAC7FqB,UAAU,GAAGI,KAAK,CAAC,CAAC,CAAC;UACrBH,OAAO,GAAGG,KAAK,CAAC,CAAC,CAAC;SACnB,MAAM;UACLH,OAAO,GAAGf,IAAI,CAACgB,CAAC,CAAC;;QAEnB,KAAKtB,CAAC,GAAGoB,UAAU,EAAEpB,CAAC,GAAGqB,OAAO,EAAErB,CAAC,IAAID,MAAM,EAAE;UAC7C,IAAI,CAACN,WAAW,CAACwB,IAAI,CAACpB,eAAe,CAACG,CAAC,CAAC,EAAEH,eAAe,CAACG,CAAC,GAAG,CAAC,CAAC,CAAC;;QAEnEF,GAAG,GAAG,IAAI,CAACL,WAAW,CAACC,MAAM;QAC7B0B,UAAU,GAAGd,IAAI,CAACgB,CAAC,CAAC;QACpB,IAAI,CAACI,UAAU,CAAClC,KAAK,EAAEM,GAAG,EAAE,IAAI,CAAC/B,eAAe,CAAC;QACjDyB,KAAK,GAAGM,GAAG;;MAEb,IAAI,CAAC6B,WAAW,CAACxC,QAAQ,EAAEC,OAAO,CAAC;KAEpC,MAAM;MACL,IAAMwC,KAAK,GAAG,IAAI,CAACC,QAAQ,CAAC,IAAI,CAAC5D,KAAK,EAAE,IAAI,CAACY,QAAQ,EAAE,IAAI,CAACC,QAAQ,EAAE,IAAI,CAACC,UAAU,CAAC;MACtF,IAAM+C,KAAK,GAAGF,KAAK,CAACE,KAAK,GAAG,IAAI,CAACnE,UAAU;MAC3C,QAAQgC,YAAY;QAClB,KAAK1D,YAAY,CAAC8F,KAAK;QACvB,KAAK9F,YAAY,CAAC+F,WAAW;UAC3BnC,eAAe,GAAGV,QAAQ,CAACoB,kBAAkB,EAAE;UAC/CT,GAAG,GAAGD,eAAe,CAACH,MAAM;UAC5B;QACF,KAAKzD,YAAY,CAACwE,WAAW;UAC3BZ,eAAe,4DAA8DV,QAAQ,CAAE8C,eAAe,EAAE;UACxG;QACF,KAAKhG,YAAY,CAACiG,MAAM;UACtBrC,eAAe,wDAA0DV,QAAQ,CAAEgD,SAAS,EAAE;UAC9F;QACF,KAAKlG,YAAY,CAACyE,iBAAiB;UACjCb,eAAe,iEAAmEV,QAAQ,CAAEiD,gBAAgB,EAAE;UAC9GtC,GAAG,GAAGD,eAAe,CAACH,MAAM;UAC5B;QACF,KAAKzD,YAAY,CAAC2E,OAAO;UACvBf,eAAe,yDAA2DV,QAAQ,CAAEkD,oBAAoB,EAAE;UAC1G,IAAI,CAAC9C,SAAS,CAAC+C,QAAQ,IAAIzC,eAAe,CAAC,CAAC,CAAC,GAAG,IAAI,CAACnC,UAAU,GAAGoE,KAAK,EAAE;YACvE;;UAEF/B,MAAM,GAAG,CAAC;UACV;QACF,KAAK9D,YAAY,CAAC6E,aAAa;UAC7B,IAAMyB,cAAc,8DAAgEpD,QAAQ,CAAEqD,qBAAqB,EAAE;UACrH3C,eAAe,GAAG,EAAE;UACpB,KAAKG,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGsC,cAAc,CAAC7C,MAAM,EAAEM,CAAC,GAAGC,EAAE,EAAED,CAAC,IAAI,CAAC,EAAE;YACtD,IAAIT,SAAS,CAAC+C,QAAQ,IAAIC,cAAc,CAACvC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAACtC,UAAU,IAAIoE,KAAK,EAAE;cAC1EjC,eAAe,CAACoB,IAAI,CAACsB,cAAc,CAACvC,CAAC,CAAC,EAAEuC,cAAc,CAACvC,CAAC,GAAG,CAAC,CAAC,CAAC;;;UAGlEF,GAAG,GAAGD,eAAe,CAACH,MAAM;UAC5B,IAAII,GAAG,IAAI,CAAC,EAAE;YACZ;;UAEF;QACF;MAAQ;MAEVA,GAAG,GAAG,IAAI,CAAC2C,qBAAqB,CAAC5C,eAAe,EAAE,CAAC,EAAEC,GAAG,EAAEC,MAAM,EAAE,KAAK,EAAE,KAAK,CAAC;MAC/E,IAAIR,SAAS,CAACmD,cAAc,IAAInD,SAAS,CAACoD,gBAAgB,EAAE;QAC1D,IAAI,CAACC,kBAAkB,CAACrD,SAAS,CAACmD,cAAc,EAAEnD,SAAS,CAACoD,gBAAgB,CAAC;QAC7E,IAAIpD,SAAS,CAACmD,cAAc,EAAE;UAC5B,IAAI,CAACG,eAAe,CAAC,IAAI,CAACC,KAAK,EAAE,IAAI,CAACC,UAAU,EAAE5D,QAAQ,CAAC;UAC3D,IAAI,CAAC6D,wBAAwB,CAAC/B,IAAI,CAAC,IAAI,CAAC8B,UAAU,CAAC,IAAI,CAACD,KAAK,EAAE3D,QAAQ,CAAC,CAAC;;QAE3E,IAAII,SAAS,CAACoD,gBAAgB,EAAE;UAC9B,IAAI,CAACM,iBAAiB,CAAC,IAAI,CAACH,KAAK,EAAE,IAAI,CAACI,WAAW,CAAC;UACpD,IAAI,CAACF,wBAAwB,CAAC/B,IAAI,CAAC,IAAI,CAACkC,YAAY,CAAC,IAAI,CAACL,KAAK,CAAC,CAAC;;;MAGrE,IAAI,CAAC5B,aAAa,CAAC/B,QAAQ,EAAEC,OAAO,CAAC;MACrC,IAAI,CAACgE,cAAc,CAACxB,KAAK,EAAEpC,KAAK,EAAEM,GAAG,CAAC;MACtC,IAAI,CAAC6B,WAAW,CAACxC,QAAQ,EAAEC,OAAO,CAAC;;;;;;;;;;;6BAWvCyC,QAAA,YAAAA,SAASwB,IAAI,EAAEC,OAAO,EAAEC,OAAO,EAAEC,SAAS,EAAE;IAC1C,IAAI5B,KAAK;IACT,IAAM6B,GAAG,GAAGD,SAAS,GAAGF,OAAO,GAAGD,IAAI,GAAGE,OAAO,GAAG,IAAI,CAAC5F,UAAU;IAElE,IAAI,CAACxB,UAAU,CAACuH,WAAW,CAACD,GAAG,CAAC,EAAE;MAChC,IAAMnE,WAAW,GAAGkE,SAAS,GAAG,IAAI,CAAC9E,YAAY,CAAC8E,SAAS,CAAC,IAAI,IAAI,CAAC/E,gBAAgB,GAAG,IAAI;MAC5F,IAAMY,SAAS,GAAGkE,OAAO,GAAG,IAAI,CAAC/E,UAAU,CAAC+E,OAAO,CAAC,IAAI,IAAI,CAAChF,cAAc,GAAG,IAAI;MAClF,IAAMgB,SAAS,GAAG,IAAI,CAACX,UAAU,CAAC0E,OAAO,CAAC,IAAI,IAAI,CAAC3E,UAAU;MAC7D,IAAMhB,UAAU,GAAG,IAAI,CAACA,UAAU;MAClC,IAAMgG,KAAK,GAAGpE,SAAS,CAACoE,KAAK,GAAGhG,UAAU;MAC1C,IAAMiG,KAAK,GAAGvG,UAAU,CAACkC,SAAS,CAAC4B,SAAS,IAAI9E,gBAAgB,CAAC;MACjE,IAAMwH,WAAW,GAAGL,SAAS,IAAIlE,WAAW,CAACwE,SAAS,GAAGxE,WAAW,CAACwE,SAAS,GAAG,CAAC;MAElF,IAAMC,KAAK,GAAGV,IAAI,CAACW,KAAK,CAAC,IAAI,CAAC;MAC9B,IAAMC,QAAQ,GAAGF,KAAK,CAACrE,MAAM;MAC7B,IAAMwE,MAAM,GAAG,EAAE;MACjB,IAAMpC,KAAK,GAAGqC,iBAAiB,CAAC5E,SAAS,CAAC6E,IAAI,EAAEL,KAAK,EAAEG,MAAM,CAAC;MAC9D,IAAMG,UAAU,GAAG/H,iBAAiB,CAACiD,SAAS,CAAC6E,IAAI,CAAC;MACpD,IAAME,MAAM,GAAGD,UAAU,GAAGJ,QAAQ;MACpC,IAAMM,WAAW,GAAIzC,KAAK,GAAG+B,WAAY;MACzC,IAAMW,OAAO,GAAG1I,qBAAqB,CACnC2I,IAAI,CAACC,IAAI,CAACH,WAAW,GAAGZ,KAAK,CAAC,EAC9Bc,IAAI,CAACC,IAAI,CAAC,CAACJ,MAAM,GAAGT,WAAW,IAAIF,KAAK,CAAC,CAAC;MAC5C/B,KAAK,GAAG4C,OAAO,CAACG,MAAM;MACtBxI,UAAU,CAACyI,GAAG,CAACnB,GAAG,EAAE7B,KAAK,CAAC;MAC1B,IAAI+B,KAAK,IAAI,CAAC,EAAE;QACda,OAAO,CAACb,KAAK,CAACA,KAAK,EAAEA,KAAK,CAAC;;MAE7Ba,OAAO,CAACJ,IAAI,GAAG7E,SAAS,CAAC6E,IAAI;MAC7B,IAAIZ,SAAS,EAAE;QACbgB,OAAO,CAACK,WAAW,GAAGvF,WAAW,CAACuF,WAAW;QAC7CL,OAAO,CAACV,SAAS,GAAGD,WAAW;QAC/BW,OAAO,CAACM,OAAO,+BAAiCxF,WAAW,CAACwF,OAAQ;QACpEN,OAAO,CAACO,QAAQ,gCAAkCzF,WAAW,CAACyF,QAAS;QACvEP,OAAO,CAACQ,UAAU,GAAG1F,WAAW,CAAC0F,UAAU;QAC3C,IAAI9I,gBAAgB,IAAIoD,WAAW,CAAC2F,QAAQ,CAACvF,MAAM,EAAE;UACnD8E,OAAO,CAACU,WAAW,CAAC5F,WAAW,CAAC2F,QAAQ,CAAC;UACzCT,OAAO,CAACW,cAAc,GAAG7F,WAAW,CAAC6F,cAAc;;;MAGvD,IAAI5B,OAAO,EAAE;QACXiB,OAAO,CAACY,SAAS,GAAG/F,SAAS,CAAC+F,SAAS;;MAEzCZ,OAAO,CAACa,YAAY,GAAG,QAAQ;MAC/Bb,OAAO,CAACrD,SAAS,GAAG,QAAQ;MAC5B,IAAMmE,SAAS,GAAI,GAAG,GAAG1B,KAAM;MAC/B,IAAM2B,CAAC,GAAG3B,KAAK,GAAGhC,KAAK,CAACE,KAAK,GAAG6B,KAAK,GAAG2B,SAAS,GAAGzB,WAAW;MAC/D,IAAI7D,CAAC;MACL,IAAIwD,SAAS,EAAE;QACb,KAAKxD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiE,QAAQ,EAAE,EAAEjE,CAAC,EAAE;UAC7BwE,OAAO,CAACgB,UAAU,CAACzB,KAAK,CAAC/D,CAAC,CAAC,EAAEuF,CAAC,GAAGD,SAAS,GAAGpB,MAAM,CAAClE,CAAC,CAAC,EAAE,GAAG,IAAI6D,WAAW,GAAGQ,UAAU,CAAC,GAAGrE,CAAC,GAAGqE,UAAU,CAAC;;;MAG9G,IAAId,OAAO,EAAE;QACX,KAAKvD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiE,QAAQ,EAAE,EAAEjE,CAAC,EAAE;UAC7BwE,OAAO,CAACiB,QAAQ,CAAC1B,KAAK,CAAC/D,CAAC,CAAC,EAAEuF,CAAC,GAAGD,SAAS,GAAGpB,MAAM,CAAClE,CAAC,CAAC,EAAE,GAAG,IAAI6D,WAAW,GAAGQ,UAAU,CAAC,GAAGrE,CAAC,GAAGqE,UAAU,CAAC;;;;IAI9G,OAAOlI,UAAU,CAACuJ,GAAG,CAACjC,GAAG,CAAC;;;;;;;;;6BAS5BL,cAAA,YAAAA,eAAexB,KAAK,EAAEpC,KAAK,EAAEM,GAAG,EAAE;IAChC,IAAMP,SAAS,GAAG,IAAI,CAACZ,UAAU;IACjC,IAAMW,WAAW,GAAG,IAAI,CAACb,gBAAgB;IACzC,IAAMd,UAAU,GAAG,IAAI,CAACA,UAAU;IAClC,IAAMiG,KAAK,GAAGvG,UAAU,CAACkC,SAAS,CAAC4B,SAAS,IAAI9E,gBAAgB,CAAC;IACjE,IAAMsJ,QAAQ,GAAGtI,UAAU,CAACkC,SAAS,CAAC8F,YAAY,CAAC;IACnD,IAAMxB,WAAW,GAAGvE,WAAW,IAAIA,WAAW,CAACwE,SAAS,GAAGxE,WAAW,CAACwE,SAAS,GAAG,CAAC;IAEpF,IAAM8B,OAAO,GAAGhC,KAAK,GAAGhC,KAAK,CAACE,KAAK,GAAGnE,UAAU,GAAG,CAAC,IAAI,GAAG,GAAGiG,KAAK,CAAC,GAAGC,WAAW;IAClF,IAAMgC,OAAO,GAAGF,QAAQ,GAAG/D,KAAK,CAAC0C,MAAM,GAAG3G,UAAU,GAAG,CAAC,IAAI,GAAG,GAAGgI,QAAQ,CAAC,GAAG9B,WAAW;IACzF,IAAI,CAACiC,YAAY,CAAC7E,IAAI,CAAC,CAAC9D,iBAAiB,CAAC4I,UAAU,EAAEvG,KAAK,EAAEM,GAAG,EAC9D8B,KAAK,EAAE,CAACgE,OAAO,GAAG,IAAI,CAAC1H,YAAY,IAAIP,UAAU,EAAE,CAACkI,OAAO,GAAG,IAAI,CAAC1H,YAAY,IAAIR,UAAU,EAC7F,IAAI,CAACI,eAAe,EAAE6D,KAAK,CAAC0C,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAAClG,mBAAmB,EAAE,IAAI,CAACE,aAAa,EACzF,CAAC,EAAEsD,KAAK,CAACE,KAAK,EACdvC,SAAS,CAACyG,OAAO,IAAIzJ,cAAc,GACjCA,cAAc,GAAGgD,SAAS,CAACyG,OAAO,CAACC,GAAG,CAAC,UAASC,CAAC,EAAE;MACjD,OAAOA,CAAC,GAAGvI,UAAU;KACtB,CAAC,EACJ,CAAC,CAAC4B,SAAS,CAACmD,cAAc,EAAE,CAAC,CAACnD,SAAS,CAACoD,gBAAgB,CACzD,CAAC;IACF,IAAI,CAACK,wBAAwB,CAAC/B,IAAI,CAAC,CAAC9D,iBAAiB,CAAC4I,UAAU,EAAEvG,KAAK,EAAEM,GAAG,EAC1E8B,KAAK,EAAE,CAACgE,OAAO,GAAG,IAAI,CAAC1H,YAAY,IAAIP,UAAU,EAAE,CAACkI,OAAO,GAAG,IAAI,CAAC1H,YAAY,IAAIR,UAAU,EAC7F,IAAI,CAACI,eAAe,EAAE6D,KAAK,CAAC0C,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAAClG,mBAAmB,EAAE,IAAI,CAACE,aAAa,EACzF,CAAC,GAAGX,UAAU,EAAEiE,KAAK,CAACE,KAAK,EAAEvC,SAAS,CAACyG,OAAO,EAC9C,CAAC,CAACzG,SAAS,CAACmD,cAAc,EAAE,CAAC,CAACnD,SAAS,CAACoD,gBAAgB,CACzD,CAAC;;;;;;;;;6BASJjB,UAAA,YAAAA,WAAWlC,KAAK,EAAEM,GAAG,EAAEqG,cAAc,EAAE;IACrC,IAAM7G,WAAW,GAAG,IAAI,CAACb,gBAAgB;IACzC,IAAMc,SAAS,GAAG,IAAI,CAACZ,UAAU;IACjC,IAAMU,SAAS,GAAG,IAAI,CAACd,cAAc;IAErC,IAAMiF,SAAS,GAAG,IAAI,CAACzE,UAAU;IACjC,IAAIO,WAAW,EAAE;MACf,IAAI,EAAEkE,SAAS,IAAI,IAAI,CAAC9E,YAAY,CAAC,EAAE;QACrC,IAAI,CAACA,YAAY,CAAC8E,SAAS,CAAC,oDAAsD;UAChFqB,WAAW,EAAEvF,WAAW,CAACuF,WAAW;UACpCC,OAAO,EAAExF,WAAW,CAACwF,OAAO;UAC5BK,cAAc,EAAE7F,WAAW,CAAC6F,cAAc;UAC1CrB,SAAS,EAAExE,WAAW,CAACwE,SAAS;UAChCiB,QAAQ,EAAEzF,WAAW,CAACyF,QAAQ;UAC9BC,UAAU,EAAE1F,WAAW,CAAC0F,UAAU;UAClCC,QAAQ,EAAE3F,WAAW,CAAC2F;SACtB;;;IAGN,IAAM3B,OAAO,GAAG,IAAI,CAACzE,QAAQ;IAC7B,IAAI,EAAE,IAAI,CAACA,QAAQ,IAAI,IAAI,CAACD,UAAU,CAAC,EAAE;MACvC,IAAI,CAACA,UAAU,CAAC,IAAI,CAACC,QAAQ,CAAC,kDAAoD;QAChFuF,IAAI,EAAE7E,SAAS,CAAC6E,IAAI;QACpBjD,SAAS,EAAE5B,SAAS,CAAC4B,SAAS,IAAI9E,gBAAgB;QAClDsH,KAAK,EAAEpE,SAAS,CAACoE;OACjB;;IAEJ,IAAMJ,OAAO,GAAG,IAAI,CAACzE,QAAQ;IAC7B,IAAIO,SAAS,EAAE;MACb,IAAI,EAAEkE,OAAO,IAAI,IAAI,CAAC/E,UAAU,CAAC,EAAE;QACjC,IAAI,CAACA,UAAU,CAAC+E,OAAO,CAAC,kDAAoD;UAC1E6B,SAAS,EAAE/F,SAAS,CAAC+F;SACrB;;;IAIN,IAAMzH,UAAU,GAAG,IAAI,CAACA,UAAU;IAClC,IAAMgI,QAAQ,GAAGtI,UAAU,CAACkC,SAAS,CAAC8F,YAAY,CAAC;IAEnD,IAAMe,OAAO,GAAG,IAAI,CAACjI,YAAY,GAAGR,UAAU;IAC9C,IAAM0F,IAAI,GAAG,IAAI,CAACpF,KAAK;IACvB,IAAMmG,IAAI,GAAG7E,SAAS,CAAC6E,IAAI;IAC3B,IAAMiC,SAAS,GAAG9G,SAAS,CAACoE,KAAK;IACjC,IAAME,WAAW,GAAGvE,WAAW,GAAGA,WAAW,CAACwE,SAAS,GAAGuC,SAAS,GAAG,CAAC,GAAG,CAAC;IAC3E,IAAInC,MAAM,GAAG,IAAI,CAAClF,OAAO,CAACoF,IAAI,CAAC;IAC/B,IAAI,CAACF,MAAM,EAAE;MACX,IAAI,CAAClF,OAAO,CAACoF,IAAI,CAAC,GAAGF,MAAM,GAAG,EAAE;;IAElC,IAAI,CAAC4B,YAAY,CAAC7E,IAAI,CAAC,CAAC9D,iBAAiB,CAACmJ,UAAU,EAClD9G,KAAK,EAAEM,GAAG,EAAE6F,QAAQ,EAAEQ,cAAc,EACpC5G,SAAS,CAAC+C,QAAQ,EAAEiB,OAAO,EAAEhE,SAAS,CAACkC,QAAQ,EAC/C,UAAS4B,IAAI,EAAE;MACb,IAAIvB,KAAK,GAAGoC,MAAM,CAACb,IAAI,CAAC;MACxB,IAAI,CAACvB,KAAK,EAAE;QACVA,KAAK,GAAGoC,MAAM,CAACb,IAAI,CAAC,GAAGjH,gBAAgB,CAACgI,IAAI,EAAEf,IAAI,CAAC;;MAErD,OAAOvB,KAAK,GAAGuE,SAAS,GAAG1I,UAAU;KACtC,EACDyI,OAAO,EAAE5C,SAAS,EAAEK,WAAW,GAAGlG,UAAU,EAAE0F,IAAI,EAAEC,OAAO,EAAE,CAAC,CAC/D,CAAC;IACF,IAAI,CAACN,wBAAwB,CAAC/B,IAAI,CAAC,CAAC9D,iBAAiB,CAACmJ,UAAU,EAC9D9G,KAAK,EAAEM,GAAG,EAAE6F,QAAQ,EAAEQ,cAAc,EACpC5G,SAAS,CAAC+C,QAAQ,EAAEiB,OAAO,EAAEhE,SAAS,CAACkC,QAAQ,EAC/C,UAAS4B,IAAI,EAAE;MACb,IAAIvB,KAAK,GAAGoC,MAAM,CAACb,IAAI,CAAC;MACxB,IAAI,CAACvB,KAAK,EAAE;QACVA,KAAK,GAAGoC,MAAM,CAACb,IAAI,CAAC,GAAGjH,gBAAgB,CAACgI,IAAI,EAAEf,IAAI,CAAC;;MAErD,OAAOvB,KAAK,GAAGuE,SAAS;KACzB,EACDD,OAAO,EAAE5C,SAAS,EAAEK,WAAW,EAAER,IAAI,EAAEC,OAAO,EAAE,CAAC,GAAG3F,UAAU,CAC/D,CAAC;;;;;;6BAMJ4I,YAAA,YAAAA,aAAaC,SAAS,EAAEL,cAAc,EAAE;IACtC,IAAI5G,SAAS,EAAEF,SAAS,EAAEC,WAAW;IACrC,IAAI,CAACkH,SAAS,EAAE;MACd,IAAI,CAACvI,KAAK,GAAG,EAAE;KAChB,MAAM;MACL,IAAI,CAACF,eAAe,uDAAyDoI,cAAe;MAE5F,IAAMM,aAAa,GAAGD,SAAS,CAACE,OAAO,EAAE;MACzC,IAAI,CAACD,aAAa,EAAE;QAClBpH,SAAS,GAAG,IAAI,CAACd,cAAc,GAAG,IAAI;OACvC,MAAM;QACLc,SAAS,GAAG,IAAI,CAACd,cAAc;QAC/B,IAAI,CAACc,SAAS,EAAE;UACdA,SAAS,GAAG,IAAI,CAACd,cAAc,kDAAoD,EAAG;;QAExFc,SAAS,CAAC+F,SAAS,GAAGvJ,WAAW,CAC/B4K,aAAa,CAACE,QAAQ,EAAE,IAAI/J,gBAAgB,CAAC;;MAGjD,IAAMgK,eAAe,GAAGJ,SAAS,CAACK,SAAS,EAAE;MAC7C,IAAI,CAACD,eAAe,EAAE;QACpBtH,WAAW,GAAG,IAAI,CAACb,gBAAgB,GAAG,IAAI;OAC3C,MAAM;QACLa,WAAW,GAAG,IAAI,CAACb,gBAAgB;QACnC,IAAI,CAACa,WAAW,EAAE;UAChBA,WAAW,GAAG,IAAI,CAACb,gBAAgB,oDAAsD,EAAG;;QAE9F,IAAMwG,QAAQ,GAAG2B,eAAe,CAACE,WAAW,EAAE;QAC9C,IAAM3B,cAAc,GAAGyB,eAAe,CAACG,iBAAiB,EAAE;QAC1D,IAAMjD,SAAS,GAAG8C,eAAe,CAACI,QAAQ,EAAE;QAC5C,IAAMhC,UAAU,GAAG4B,eAAe,CAACK,aAAa,EAAE;QAClD3H,WAAW,CAACwF,OAAO,GAAG8B,eAAe,CAACM,UAAU,EAAE,IAAI1K,cAAc;QACpE8C,WAAW,CAAC2F,QAAQ,GAAGA,QAAQ,GAAGA,QAAQ,CAACpE,KAAK,EAAE,GAAGnE,eAAe;QACpE4C,WAAW,CAAC6F,cAAc,GACtBA,cAAc,KAAK9G,SAAS,GAAG5B,qBAAqB,GAAG0I,cAAc;QACzE7F,WAAW,CAACyF,QAAQ,GAAG6B,eAAe,CAACO,WAAW,EAAE,IAAIxK,eAAe;QACvE2C,WAAW,CAACwE,SAAS,GACjBA,SAAS,KAAKzF,SAAS,GAAGtB,gBAAgB,GAAG+G,SAAS;QAC1DxE,WAAW,CAAC0F,UAAU,GAClBA,UAAU,KAAK3G,SAAS,GAAGrB,iBAAiB,GAAGgI,UAAU;QAC7D1F,WAAW,CAACuF,WAAW,GAAGhJ,WAAW,CACnC+K,eAAe,CAACD,QAAQ,EAAE,IAAI1J,kBAAkB,CAAC;;MAGrDsC,SAAS,GAAG,IAAI,CAACZ,UAAU;MAC3B,IAAMyF,IAAI,GAAGoC,SAAS,CAACY,OAAO,EAAE,IAAItK,WAAW;MAC/CD,SAAS,CAACuH,IAAI,CAAC;MACf,IAAMiC,SAAS,GAAGG,SAAS,CAACa,QAAQ,EAAE;MACtC9H,SAAS,CAAC+C,QAAQ,GAAGkE,SAAS,CAACc,WAAW,EAAE;MAC5C/H,SAAS,CAAC6E,IAAI,GAAGA,IAAI;MACrB7E,SAAS,CAACkC,QAAQ,GAAG+E,SAAS,CAACe,WAAW,EAAE;MAC5ChI,SAAS,CAACW,SAAS,GAAGsG,SAAS,CAACgB,YAAY,EAAE;MAC9CjI,SAAS,CAAC4B,SAAS,GAAGqF,SAAS,CAACiB,YAAY,EAAE;MAC9ClI,SAAS,CAAC8F,YAAY,GAAGmB,SAAS,CAACkB,eAAe,EAAE,IAAIxK,mBAAmB;MAC3EqC,SAAS,CAACmD,cAAc,GAAG8D,SAAS,CAACmB,iBAAiB,EAAE;MACxDpI,SAAS,CAACoD,gBAAgB,GAAG6D,SAAS,CAACoB,mBAAmB,EAAE;MAC5DrI,SAAS,CAACyG,OAAO,GAAGQ,SAAS,CAACqB,UAAU,EAAE,IAAItL,cAAc;MAC5DgD,SAAS,CAACoE,KAAK,GAAG0C,SAAS,KAAKhI,SAAS,GAAG,CAAC,GAAGgI,SAAS;MAEzD,IAAMyB,WAAW,GAAGtB,SAAS,CAACuB,UAAU,EAAE;MAC1C,IAAMC,WAAW,GAAGxB,SAAS,CAACyB,UAAU,EAAE;MAC1C,IAAMC,kBAAkB,GAAG1B,SAAS,CAAC2B,iBAAiB,EAAE;MACxD,IAAMC,YAAY,GAAG5B,SAAS,CAAC6B,WAAW,EAAE;MAC5C,IAAI,CAACpK,KAAK,GAAGuI,SAAS,CAAC8B,OAAO,EAAE,IAAI,EAAE;MACtC,IAAI,CAACpK,YAAY,GAAG4J,WAAW,KAAKzJ,SAAS,GAAG,CAAC,GAAGyJ,WAAW;MAC/D,IAAI,CAAC3J,YAAY,GAAG6J,WAAW,KAAK3J,SAAS,GAAG,CAAC,GAAG2J,WAAW;MAC/D,IAAI,CAAC5J,mBAAmB,GAAG8J,kBAAkB,KAAK7J,SAAS,GAAG,KAAK,GAAG6J,kBAAkB;MACxF,IAAI,CAAC5J,aAAa,GAAG8J,YAAY,KAAK/J,SAAS,GAAG,CAAC,GAAG+J,YAAY;MAElE,IAAI,CAACrJ,UAAU,GAAGO,WAAW,GAC3B,CAAC,OAAOA,WAAW,CAACuF,WAAW,IAAI,QAAQ,GAAGvF,WAAW,CAACuF,WAAW,GAAGjJ,MAAM,CAAC0D,WAAW,CAACuF,WAAW,CAAC,IACvGvF,WAAW,CAACwF,OAAO,GAAGxF,WAAW,CAAC6F,cAAc,GAAG,GAAG,GAAG7F,WAAW,CAACwE,SAAS,GAC9ExE,WAAW,CAACyF,QAAQ,GAAGzF,WAAW,CAAC0F,UAAU,GAAG,GAAG,GAAG1F,WAAW,CAAC2F,QAAQ,CAACsD,IAAI,EAAE,GAAG,GAAG,GACvF,EAAE;MACJ,IAAI,CAAC1J,QAAQ,GAAGU,SAAS,CAAC6E,IAAI,GAAG7E,SAAS,CAACoE,KAAK,IAAIpE,SAAS,CAAC4B,SAAS,IAAI,GAAG,CAAC;MAC/E,IAAI,CAACrC,QAAQ,GAAGO,SAAS,GACtB,OAAOA,SAAS,CAAC+F,SAAS,IAAI,QAAQ,GAAG/F,SAAS,CAAC+F,SAAS,GAAI,GAAG,GAAGxJ,MAAM,CAACyD,SAAS,CAAC+F,SAAS,CAAE,GACnG,EAAE;;GAEP;;EApf4BhI,YAAA;;;;;;;;;AA+f/B,OAAO,SAAS+G,iBAAiBA,CAACC,IAAI,EAAEL,KAAK,EAAEG,MAAM,EAAE;EACrD,IAAMD,QAAQ,GAAGF,KAAK,CAACrE,MAAM;EAC7B,IAAIoC,KAAK,GAAG,CAAC;EACb,KAAK,IAAI9B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiE,QAAQ,EAAE,EAAEjE,CAAC,EAAE;IACjC,IAAMwI,YAAY,GAAGpM,gBAAgB,CAACgI,IAAI,EAAEL,KAAK,CAAC/D,CAAC,CAAC,CAAC;IACrD8B,KAAK,GAAG2C,IAAI,CAACgE,GAAG,CAAC3G,KAAK,EAAE0G,YAAY,CAAC;IACrCtE,MAAM,CAACjD,IAAI,CAACuH,YAAY,CAAC;;EAE3B,OAAO1G,KAAK;;AAId,eAAevE,gBAAgB"},"metadata":{},"sourceType":"module"}