{"ast":null,"code":"/**\n * @module ol/interaction/Snap\n */\nimport { getUid } from '../util.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport { distance as coordinateDistance, squaredDistance as squaredCoordinateDistance, closestOnCircle, closestOnSegment, squaredDistanceToSegment } from '../coordinate.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { boundingExtent, createEmpty } from '../extent.js';\nimport { TRUE, FALSE } from '../functions.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport { fromCircle } from '../geom/Polygon.js';\nimport PointerInteraction from './Pointer.js';\nimport { getValues } from '../obj.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport RBush from '../structs/RBush.js';\n\n/**\n * @typedef {Object} Result\n * @property {boolean} snapped\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel\n */\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if ( /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */evt.feature) {\n    return (/** @type {import(\"../source/Vector.js\").VectorSourceEvent} */evt.feature\n    );\n  } else if ( /** @type {import(\"../Collection.js\").CollectionEvent} */evt.element) {\n    return (/** @type {import(\"../Feature.js\").default} */ /** @type {import(\"../Collection.js\").CollectionEvent} */evt.element\n    );\n  }\n}\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     var snap = new Snap({\n *       source: source\n *     });\n *\n * @api\n */\nvar Snap = /*@__PURE__*/function (PointerInteraction) {\n  function Snap(opt_options) {\n    var options = opt_options ? opt_options : {};\n    var pointerOptions = /** @type {import(\"./Pointer.js\").Options} */options;\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n    PointerInteraction.call(this, pointerOptions);\n\n    /**\n     * @type {import(\"../source/Vector.js\").default}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * Used for distance sorting in sortByDistance_\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.pixelCoordinate_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;\n\n    /**\n     * @type {function(SegmentData, SegmentData): number}\n     * @private\n     */\n    this.sortByDistance_ = sortByDistance.bind(this);\n\n    /**\n    * Segment RTree for each layer\n    * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n    * @private\n    */\n    this.rBush_ = new RBush();\n\n    /**\n    * @const\n    * @private\n    * @type {Object<string, function(import(\"../Feature.js\").default, import(\"../geom/Geometry.js\").default)>}\n    */\n    this.SEGMENT_WRITERS_ = {\n      'Point': this.writePointGeometry_,\n      'LineString': this.writeLineStringGeometry_,\n      'LinearRing': this.writeLineStringGeometry_,\n      'Polygon': this.writePolygonGeometry_,\n      'MultiPoint': this.writeMultiPointGeometry_,\n      'MultiLineString': this.writeMultiLineStringGeometry_,\n      'MultiPolygon': this.writeMultiPolygonGeometry_,\n      'GeometryCollection': this.writeGeometryCollectionGeometry_,\n      'Circle': this.writeCircleGeometry_\n    };\n  }\n  if (PointerInteraction) Snap.__proto__ = PointerInteraction;\n  Snap.prototype = Object.create(PointerInteraction && PointerInteraction.prototype);\n  Snap.prototype.constructor = Snap;\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean=} opt_listen Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  Snap.prototype.addFeature = function addFeature(feature, opt_listen) {\n    var register = opt_listen !== undefined ? opt_listen : true;\n    var feature_uid = getUid(feature);\n    var geometry = feature.getGeometry();\n    if (geometry) {\n      var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];\n      if (segmentWriter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n        segmentWriter.call(this, feature, geometry);\n      }\n    }\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(feature, EventType.CHANGE, this.handleFeatureChange_, this);\n    }\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  Snap.prototype.forEachFeatureAdd_ = function forEachFeatureAdd_(feature) {\n    this.addFeature(feature);\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  Snap.prototype.forEachFeatureRemove_ = function forEachFeatureRemove_(feature) {\n    this.removeFeature(feature);\n  };\n\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  Snap.prototype.getFeatures_ = function getFeatures_() {\n    var features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Snap.prototype.handleEvent = function handleEvent(evt) {\n    var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result.snapped) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n    return PointerInteraction.prototype.handleEvent.call(this, evt);\n  };\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  Snap.prototype.handleFeatureAdd_ = function handleFeatureAdd_(evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  };\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  Snap.prototype.handleFeatureRemove_ = function handleFeatureRemove_(evt) {\n    var feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  };\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  Snap.prototype.handleFeatureChange_ = function handleFeatureChange_(evt) {\n    var feature = /** @type {import(\"../Feature.js\").default} */evt.target;\n    if (this.handlingDownUpSequence) {\n      var uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Snap.prototype.handleUpEvent = function handleUpEvent(evt) {\n    var featuresToUpdate = getValues(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  };\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean=} opt_unlisten Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  Snap.prototype.removeFeature = function removeFeature(feature, opt_unlisten) {\n    var unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n    var feature_uid = getUid(feature);\n    var extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      var rBush = this.rBush_;\n      var nodesToRemove = [];\n      rBush.forEachInExtent(extent, function (node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (var i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Snap.prototype.setMap = function setMap(map) {\n    var currentMap = this.getMap();\n    var keys = this.featuresListenerKeys_;\n    var features = /** @type {Array<import(\"../Feature.js\").default>} */this.getFeatures_();\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n    PointerInteraction.prototype.setMap.call(this, map);\n    if (map) {\n      if (this.features_) {\n        keys.push(listen(this.features_, CollectionEventType.ADD, this.handleFeatureAdd_, this), listen(this.features_, CollectionEventType.REMOVE, this.handleFeatureRemove_, this));\n      } else if (this.source_) {\n        keys.push(listen(this.source_, VectorEventType.ADDFEATURE, this.handleFeatureAdd_, this), listen(this.source_, VectorEventType.REMOVEFEATURE, this.handleFeatureRemove_, this));\n      }\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  };\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   * @return {Result} Snap result\n   */\n  Snap.prototype.snapTo = function snapTo(pixel, pixelCoordinate, map) {\n    var lowerLeft = map.getCoordinateFromPixel([pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n    var upperRight = map.getCoordinateFromPixel([pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n    var box = boundingExtent([lowerLeft, upperRight]);\n    var segments = this.rBush_.getInExtent(box);\n\n    // If snapping on vertices only, don't consider circles\n    if (this.vertex_ && !this.edge_) {\n      segments = segments.filter(function (segment) {\n        return segment.feature.getGeometry().getType() !== GeometryType.CIRCLE;\n      });\n    }\n    var snappedToVertex = false;\n    var snapped = false;\n    var vertex = null;\n    var vertexPixel = null;\n    var dist, pixel1, pixel2, squaredDist1, squaredDist2;\n    if (segments.length > 0) {\n      this.pixelCoordinate_ = pixelCoordinate;\n      segments.sort(this.sortByDistance_);\n      var closestSegment = segments[0].segment;\n      var isCircle = segments[0].feature.getGeometry().getType() === GeometryType.CIRCLE;\n      if (this.vertex_ && !this.edge_) {\n        pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n        pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n        squaredDist1 = squaredCoordinateDistance(pixel, pixel1);\n        squaredDist2 = squaredCoordinateDistance(pixel, pixel2);\n        dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n        snappedToVertex = dist <= this.pixelTolerance_;\n        if (snappedToVertex) {\n          snapped = true;\n          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n          vertexPixel = map.getPixelFromCoordinate(vertex);\n        }\n      } else if (this.edge_) {\n        if (isCircle) {\n          vertex = closestOnCircle(pixelCoordinate, /** @type {import(\"../geom/Circle.js\").default} */segments[0].feature.getGeometry());\n        } else {\n          vertex = closestOnSegment(pixelCoordinate, closestSegment);\n        }\n        vertexPixel = map.getPixelFromCoordinate(vertex);\n        if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\n          snapped = true;\n          if (this.vertex_ && !isCircle) {\n            pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n            pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n            squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n            squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n            dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n            snappedToVertex = dist <= this.pixelTolerance_;\n            if (snappedToVertex) {\n              vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n              vertexPixel = map.getPixelFromCoordinate(vertex);\n            }\n          }\n        }\n      }\n      if (snapped) {\n        vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];\n      }\n    }\n    return (/** @type {Result} */{\n        snapped: snapped,\n        vertex: vertex,\n        vertexPixel: vertexPixel\n      }\n    );\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  Snap.prototype.updateFeature_ = function updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeCircleGeometry_ = function writeCircleGeometry_(feature, geometry) {\n    var polygon = fromCircle(geometry);\n    var coordinates = polygon.getCoordinates()[0];\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      var segment = coordinates.slice(i, i + 2);\n      var segmentData = /** @type {SegmentData} */{\n        feature: feature,\n        segment: segment\n      };\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeGeometryCollectionGeometry_ = function writeGeometryCollectionGeometry_(feature, geometry) {\n    var geometries = geometry.getGeometriesArray();\n    for (var i = 0; i < geometries.length; ++i) {\n      var segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];\n      if (segmentWriter) {\n        segmentWriter.call(this, feature, geometries[i]);\n      }\n    }\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeLineStringGeometry_ = function writeLineStringGeometry_(feature, geometry) {\n    var coordinates = geometry.getCoordinates();\n    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      var segment = coordinates.slice(i, i + 2);\n      var segmentData = /** @type {SegmentData} */{\n        feature: feature,\n        segment: segment\n      };\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeMultiLineStringGeometry_ = function writeMultiLineStringGeometry_(feature, geometry) {\n    var lines = geometry.getCoordinates();\n    for (var j = 0, jj = lines.length; j < jj; ++j) {\n      var coordinates = lines[j];\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        var segment = coordinates.slice(i, i + 2);\n        var segmentData = /** @type {SegmentData} */{\n          feature: feature,\n          segment: segment\n        };\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeMultiPointGeometry_ = function writeMultiPointGeometry_(feature, geometry) {\n    var points = geometry.getCoordinates();\n    for (var i = 0, ii = points.length; i < ii; ++i) {\n      var coordinates = points[i];\n      var segmentData = /** @type {SegmentData} */{\n        feature: feature,\n        segment: [coordinates, coordinates]\n      };\n      this.rBush_.insert(geometry.getExtent(), segmentData);\n    }\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writeMultiPolygonGeometry_ = function writeMultiPolygonGeometry_(feature, geometry) {\n    var polygons = geometry.getCoordinates();\n    for (var k = 0, kk = polygons.length; k < kk; ++k) {\n      var rings = polygons[k];\n      for (var j = 0, jj = rings.length; j < jj; ++j) {\n        var coordinates = rings[j];\n        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          var segment = coordinates.slice(i, i + 2);\n          var segmentData = /** @type {SegmentData} */{\n            feature: feature,\n            segment: segment\n          };\n          this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      }\n    }\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writePointGeometry_ = function writePointGeometry_(feature, geometry) {\n    var coordinates = geometry.getCoordinates();\n    var segmentData = /** @type {SegmentData} */{\n      feature: feature,\n      segment: [coordinates, coordinates]\n    };\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  };\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  Snap.prototype.writePolygonGeometry_ = function writePolygonGeometry_(feature, geometry) {\n    var rings = geometry.getCoordinates();\n    for (var j = 0, jj = rings.length; j < jj; ++j) {\n      var coordinates = rings[j];\n      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        var segment = coordinates.slice(i, i + 2);\n        var segmentData = /** @type {SegmentData} */{\n          feature: feature,\n          segment: segment\n        };\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  };\n  return Snap;\n}(PointerInteraction);\n\n/**\n * Sort segments by distance, helper function\n * @param {SegmentData} a The first segment data.\n * @param {SegmentData} b The second segment data.\n * @return {number} The difference in distance.\n * @this {Snap}\n */\nfunction sortByDistance(a, b) {\n  var deltaA = squaredDistanceToSegment(this.pixelCoordinate_, a.segment);\n  var deltaB = squaredDistanceToSegment(this.pixelCoordinate_, b.segment);\n  return deltaA - deltaB;\n}\nexport default Snap;","map":{"version":3,"names":["getUid","CollectionEventType","distance","coordinateDistance","squaredDistance","squaredCoordinateDistance","closestOnCircle","closestOnSegment","squaredDistanceToSegment","listen","unlistenByKey","EventType","boundingExtent","createEmpty","TRUE","FALSE","GeometryType","fromCircle","PointerInteraction","getValues","VectorEventType","RBush","getFeatureFromEvent","evt","feature","element","Snap","opt_options","options","pointerOptions","handleDownEvent","stopDown","call","source_","source","vertex_","vertex","undefined","edge_","edge","features_","features","featuresListenerKeys_","featureChangeListenerKeys_","indexedFeaturesExtents_","pendingFeatures_","pixelCoordinate_","pixelTolerance_","pixelTolerance","sortByDistance_","sortByDistance","bind","rBush_","SEGMENT_WRITERS_","writePointGeometry_","writeLineStringGeometry_","writePolygonGeometry_","writeMultiPointGeometry_","writeMultiLineStringGeometry_","writeMultiPolygonGeometry_","writeGeometryCollectionGeometry_","writeCircleGeometry_","addFeature","opt_listen","register","feature_uid","geometry","getGeometry","segmentWriter","getType","getExtent","CHANGE","handleFeatureChange_","forEachFeatureAdd_","forEachFeatureRemove_","removeFeature","getFeatures_","getFeatures","handleEvent","result","snapTo","pixel","coordinate","map","snapped","slice","vertexPixel","prototype","handleFeatureAdd_","handleFeatureRemove_","target","handlingDownUpSequence","uid","updateFeature_","handleUpEvent","featuresToUpdate","length","forEach","opt_unlisten","unregister","extent","rBush","nodesToRemove","forEachInExtent","node","push","i","remove","setMap","currentMap","getMap","keys","ADD","REMOVE","ADDFEATURE","REMOVEFEATURE","pixelCoordinate","lowerLeft","getCoordinateFromPixel","upperRight","box","segments","getInExtent","filter","segment","CIRCLE","snappedToVertex","dist","pixel1","pixel2","squaredDist1","squaredDist2","sort","closestSegment","isCircle","getPixelFromCoordinate","Math","sqrt","min","round","polygon","coordinates","getCoordinates","ii","segmentData","insert","geometries","getGeometriesArray","lines","j","jj","points","polygons","k","kk","rings","a","b","deltaA","deltaB"],"sources":["../../../src/ol/interaction/Snap.js"],"sourcesContent":["/**\n * @module ol/interaction/Snap\n */\nimport {getUid} from '../util.js';\nimport CollectionEventType from '../CollectionEventType.js';\nimport {distance as coordinateDistance, squaredDistance as squaredCoordinateDistance, closestOnCircle, closestOnSegment, squaredDistanceToSegment} from '../coordinate.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport EventType from '../events/EventType.js';\nimport {boundingExtent, createEmpty} from '../extent.js';\nimport {TRUE, FALSE} from '../functions.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport {fromCircle} from '../geom/Polygon.js';\nimport PointerInteraction from './Pointer.js';\nimport {getValues} from '../obj.js';\nimport VectorEventType from '../source/VectorEventType.js';\nimport RBush from '../structs/RBush.js';\n\n\n/**\n * @typedef {Object} Result\n * @property {boolean} snapped\n * @property {import(\"../coordinate.js\").Coordinate|null} vertex\n * @property {import(\"../pixel.js\").Pixel|null} vertexPixel\n */\n\n\n/**\n * @typedef {Object} SegmentData\n * @property {import(\"../Feature.js\").default} feature\n * @property {Array<import(\"../coordinate.js\").Coordinate>} segment\n */\n\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../Collection.js\").default<import(\"../Feature.js\").default>} [features] Snap to these features. Either this option or source should be provided.\n * @property {boolean} [edge=true] Snap to edges.\n * @property {boolean} [vertex=true] Snap to vertices.\n * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or\n * vertex for snapping.\n * @property {import(\"../source/Vector.js\").default} [source] Snap to features from this source. Either this option or features should be provided\n */\n\n\n/**\n * @param  {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n * @return {import(\"../Feature.js\").default} Feature.\n */\nfunction getFeatureFromEvent(evt) {\n  if (/** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature) {\n    return /** @type {import(\"../source/Vector.js\").VectorSourceEvent} */ (evt).feature;\n  } else if (/** @type {import(\"../Collection.js\").CollectionEvent} */ (evt).element) {\n    return /** @type {import(\"../Feature.js\").default} */ (/** @type {import(\"../Collection.js\").CollectionEvent} */ (evt).element);\n  }\n\n}\n\n/**\n * @classdesc\n * Handles snapping of vector features while modifying or drawing them.  The\n * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}\n * Any interaction object that allows the user to interact\n * with the features using the mouse can benefit from the snapping, as long\n * as it is added before.\n *\n * The snap interaction modifies map browser event `coordinate` and `pixel`\n * properties to force the snap to occur to any interaction that them.\n *\n * Example:\n *\n *     import Snap from 'ol/interaction/Snap';\n *\n *     var snap = new Snap({\n *       source: source\n *     });\n *\n * @api\n */\nclass Snap extends PointerInteraction {\n  /**\n   * @param {Options=} opt_options Options.\n   */\n  constructor(opt_options) {\n\n    const options = opt_options ? opt_options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (options);\n\n    if (!pointerOptions.handleDownEvent) {\n      pointerOptions.handleDownEvent = TRUE;\n    }\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /**\n     * @type {import(\"../source/Vector.js\").default}\n     * @private\n     */\n    this.source_ = options.source ? options.source : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.vertex_ = options.vertex !== undefined ? options.vertex : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.edge_ = options.edge !== undefined ? options.edge : true;\n\n    /**\n     * @type {import(\"../Collection.js\").default<import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.features_ = options.features ? options.features : null;\n\n    /**\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featuresListenerKeys_ = [];\n\n    /**\n     * @type {Object<string, import(\"../events.js\").EventsKey>}\n     * @private\n     */\n    this.featureChangeListenerKeys_ = {};\n\n    /**\n     * Extents are preserved so indexed segment can be quickly removed\n     * when its feature geometry changes\n     * @type {Object<string, import(\"../extent.js\").Extent>}\n     * @private\n     */\n    this.indexedFeaturesExtents_ = {};\n\n    /**\n     * If a feature geometry changes while a pointer drag|move event occurs, the\n     * feature doesn't get updated right away.  It will be at the next 'pointerup'\n     * event fired.\n     * @type {!Object<string, import(\"../Feature.js\").default>}\n     * @private\n     */\n    this.pendingFeatures_ = {};\n\n    /**\n     * Used for distance sorting in sortByDistance_\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @private\n     */\n    this.pixelCoordinate_ = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pixelTolerance_ = options.pixelTolerance !== undefined ?\n      options.pixelTolerance : 10;\n\n    /**\n     * @type {function(SegmentData, SegmentData): number}\n     * @private\n     */\n    this.sortByDistance_ = sortByDistance.bind(this);\n\n\n    /**\n    * Segment RTree for each layer\n    * @type {import(\"../structs/RBush.js\").default<SegmentData>}\n    * @private\n    */\n    this.rBush_ = new RBush();\n\n\n    /**\n    * @const\n    * @private\n    * @type {Object<string, function(import(\"../Feature.js\").default, import(\"../geom/Geometry.js\").default)>}\n    */\n    this.SEGMENT_WRITERS_ = {\n      'Point': this.writePointGeometry_,\n      'LineString': this.writeLineStringGeometry_,\n      'LinearRing': this.writeLineStringGeometry_,\n      'Polygon': this.writePolygonGeometry_,\n      'MultiPoint': this.writeMultiPointGeometry_,\n      'MultiLineString': this.writeMultiLineStringGeometry_,\n      'MultiPolygon': this.writeMultiPolygonGeometry_,\n      'GeometryCollection': this.writeGeometryCollectionGeometry_,\n      'Circle': this.writeCircleGeometry_\n    };\n  }\n\n  /**\n   * Add a feature to the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {boolean=} opt_listen Whether to listen to the feature change or not\n   *     Defaults to `true`.\n   * @api\n   */\n  addFeature(feature, opt_listen) {\n    const register = opt_listen !== undefined ? opt_listen : true;\n    const feature_uid = getUid(feature);\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      const segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];\n      if (segmentWriter) {\n        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());\n        segmentWriter.call(this, feature, geometry);\n      }\n    }\n\n    if (register) {\n      this.featureChangeListenerKeys_[feature_uid] = listen(\n        feature,\n        EventType.CHANGE,\n        this.handleFeatureChange_, this);\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  forEachFeatureAdd_(feature) {\n    this.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @private\n   */\n  forEachFeatureRemove_(feature) {\n    this.removeFeature(feature);\n  }\n\n  /**\n   * @return {import(\"../Collection.js\").default<import(\"../Feature.js\").default>|Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  getFeatures_() {\n    let features;\n    if (this.features_) {\n      features = this.features_;\n    } else if (this.source_) {\n      features = this.source_.getFeatures();\n    }\n    return features;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  handleEvent(evt) {\n    const result = this.snapTo(evt.pixel, evt.coordinate, evt.map);\n    if (result.snapped) {\n      evt.coordinate = result.vertex.slice(0, 2);\n      evt.pixel = result.vertexPixel;\n    }\n    return super.handleEvent(evt);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  handleFeatureAdd_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../source/Vector.js\").VectorSourceEvent|import(\"../Collection.js\").CollectionEvent} evt Event.\n   * @private\n   */\n  handleFeatureRemove_(evt) {\n    const feature = getFeatureFromEvent(evt);\n    this.removeFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../events/Event.js\").default} evt Event.\n   * @private\n   */\n  handleFeatureChange_(evt) {\n    const feature = /** @type {import(\"../Feature.js\").default} */ (evt.target);\n    if (this.handlingDownUpSequence) {\n      const uid = getUid(feature);\n      if (!(uid in this.pendingFeatures_)) {\n        this.pendingFeatures_[uid] = feature;\n      }\n    } else {\n      this.updateFeature_(feature);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  handleUpEvent(evt) {\n    const featuresToUpdate = getValues(this.pendingFeatures_);\n    if (featuresToUpdate.length) {\n      featuresToUpdate.forEach(this.updateFeature_.bind(this));\n      this.pendingFeatures_ = {};\n    }\n    return false;\n  }\n\n  /**\n   * Remove a feature from the collection of features that we may snap to.\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {boolean=} opt_unlisten Whether to unlisten to the feature change\n   *     or not. Defaults to `true`.\n   * @api\n   */\n  removeFeature(feature, opt_unlisten) {\n    const unregister = opt_unlisten !== undefined ? opt_unlisten : true;\n    const feature_uid = getUid(feature);\n    const extent = this.indexedFeaturesExtents_[feature_uid];\n    if (extent) {\n      const rBush = this.rBush_;\n      const nodesToRemove = [];\n      rBush.forEachInExtent(extent, function(node) {\n        if (feature === node.feature) {\n          nodesToRemove.push(node);\n        }\n      });\n      for (let i = nodesToRemove.length - 1; i >= 0; --i) {\n        rBush.remove(nodesToRemove[i]);\n      }\n    }\n\n    if (unregister) {\n      unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);\n      delete this.featureChangeListenerKeys_[feature_uid];\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setMap(map) {\n    const currentMap = this.getMap();\n    const keys = this.featuresListenerKeys_;\n    const features = /** @type {Array<import(\"../Feature.js\").default>} */ (this.getFeatures_());\n\n    if (currentMap) {\n      keys.forEach(unlistenByKey);\n      keys.length = 0;\n      features.forEach(this.forEachFeatureRemove_.bind(this));\n    }\n    super.setMap(map);\n\n    if (map) {\n      if (this.features_) {\n        keys.push(\n          listen(this.features_, CollectionEventType.ADD,\n            this.handleFeatureAdd_, this),\n          listen(this.features_, CollectionEventType.REMOVE,\n            this.handleFeatureRemove_, this)\n        );\n      } else if (this.source_) {\n        keys.push(\n          listen(this.source_, VectorEventType.ADDFEATURE,\n            this.handleFeatureAdd_, this),\n          listen(this.source_, VectorEventType.REMOVEFEATURE,\n            this.handleFeatureRemove_, this)\n        );\n      }\n      features.forEach(this.forEachFeatureAdd_.bind(this));\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel\n   * @param {import(\"../coordinate.js\").Coordinate} pixelCoordinate Coordinate\n   * @param {import(\"../PluggableMap.js\").default} map Map.\n   * @return {Result} Snap result\n   */\n  snapTo(pixel, pixelCoordinate, map) {\n\n    const lowerLeft = map.getCoordinateFromPixel(\n      [pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);\n    const upperRight = map.getCoordinateFromPixel(\n      [pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);\n    const box = boundingExtent([lowerLeft, upperRight]);\n\n    let segments = this.rBush_.getInExtent(box);\n\n    // If snapping on vertices only, don't consider circles\n    if (this.vertex_ && !this.edge_) {\n      segments = segments.filter(function(segment) {\n        return segment.feature.getGeometry().getType() !==\n            GeometryType.CIRCLE;\n      });\n    }\n\n    let snappedToVertex = false;\n    let snapped = false;\n    let vertex = null;\n    let vertexPixel = null;\n    let dist, pixel1, pixel2, squaredDist1, squaredDist2;\n    if (segments.length > 0) {\n      this.pixelCoordinate_ = pixelCoordinate;\n      segments.sort(this.sortByDistance_);\n      const closestSegment = segments[0].segment;\n      const isCircle = segments[0].feature.getGeometry().getType() ===\n          GeometryType.CIRCLE;\n      if (this.vertex_ && !this.edge_) {\n        pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n        pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n        squaredDist1 = squaredCoordinateDistance(pixel, pixel1);\n        squaredDist2 = squaredCoordinateDistance(pixel, pixel2);\n        dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n        snappedToVertex = dist <= this.pixelTolerance_;\n        if (snappedToVertex) {\n          snapped = true;\n          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n          vertexPixel = map.getPixelFromCoordinate(vertex);\n        }\n      } else if (this.edge_) {\n        if (isCircle) {\n          vertex = closestOnCircle(pixelCoordinate,\n            /** @type {import(\"../geom/Circle.js\").default} */ (segments[0].feature.getGeometry()));\n        } else {\n          vertex = closestOnSegment(pixelCoordinate, closestSegment);\n        }\n        vertexPixel = map.getPixelFromCoordinate(vertex);\n        if (coordinateDistance(pixel, vertexPixel) <= this.pixelTolerance_) {\n          snapped = true;\n          if (this.vertex_ && !isCircle) {\n            pixel1 = map.getPixelFromCoordinate(closestSegment[0]);\n            pixel2 = map.getPixelFromCoordinate(closestSegment[1]);\n            squaredDist1 = squaredCoordinateDistance(vertexPixel, pixel1);\n            squaredDist2 = squaredCoordinateDistance(vertexPixel, pixel2);\n            dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));\n            snappedToVertex = dist <= this.pixelTolerance_;\n            if (snappedToVertex) {\n              vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];\n              vertexPixel = map.getPixelFromCoordinate(vertex);\n            }\n          }\n        }\n      }\n      if (snapped) {\n        vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];\n      }\n    }\n    return (\n      /** @type {Result} */ ({\n        snapped: snapped,\n        vertex: vertex,\n        vertexPixel: vertexPixel\n      })\n    );\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @private\n   */\n  updateFeature_(feature) {\n    this.removeFeature(feature, false);\n    this.addFeature(feature, false);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n   * @private\n   */\n  writeCircleGeometry_(feature, geometry) {\n    const polygon = fromCircle(geometry);\n    const coordinates = polygon.getCoordinates()[0];\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      const segment = coordinates.slice(i, i + 2);\n      const segmentData = /** @type {SegmentData} */ ({\n        feature: feature,\n        segment: segment\n      });\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n   * @private\n   */\n  writeGeometryCollectionGeometry_(feature, geometry) {\n    const geometries = geometry.getGeometriesArray();\n    for (let i = 0; i < geometries.length; ++i) {\n      const segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];\n      if (segmentWriter) {\n        segmentWriter.call(this, feature, geometries[i]);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n   * @private\n   */\n  writeLineStringGeometry_(feature, geometry) {\n    const coordinates = geometry.getCoordinates();\n    for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n      const segment = coordinates.slice(i, i + 2);\n      const segmentData = /** @type {SegmentData} */ ({\n        feature: feature,\n        segment: segment\n      });\n      this.rBush_.insert(boundingExtent(segment), segmentData);\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiLineStringGeometry_(feature, geometry) {\n    const lines = geometry.getCoordinates();\n    for (let j = 0, jj = lines.length; j < jj; ++j) {\n      const coordinates = lines[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        const segment = coordinates.slice(i, i + 2);\n        const segmentData = /** @type {SegmentData} */ ({\n          feature: feature,\n          segment: segment\n        });\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiPointGeometry_(feature, geometry) {\n    const points = geometry.getCoordinates();\n    for (let i = 0, ii = points.length; i < ii; ++i) {\n      const coordinates = points[i];\n      const segmentData = /** @type {SegmentData} */ ({\n        feature: feature,\n        segment: [coordinates, coordinates]\n      });\n      this.rBush_.insert(geometry.getExtent(), segmentData);\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n   * @private\n   */\n  writeMultiPolygonGeometry_(feature, geometry) {\n    const polygons = geometry.getCoordinates();\n    for (let k = 0, kk = polygons.length; k < kk; ++k) {\n      const rings = polygons[k];\n      for (let j = 0, jj = rings.length; j < jj; ++j) {\n        const coordinates = rings[j];\n        for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n          const segment = coordinates.slice(i, i + 2);\n          const segmentData = /** @type {SegmentData} */ ({\n            feature: feature,\n            segment: segment\n          });\n          this.rBush_.insert(boundingExtent(segment), segmentData);\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n   * @private\n   */\n  writePointGeometry_(feature, geometry) {\n    const coordinates = geometry.getCoordinates();\n    const segmentData = /** @type {SegmentData} */ ({\n      feature: feature,\n      segment: [coordinates, coordinates]\n    });\n    this.rBush_.insert(geometry.getExtent(), segmentData);\n  }\n\n  /**\n   * @param {import(\"../Feature.js\").default} feature Feature\n   * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n   * @private\n   */\n  writePolygonGeometry_(feature, geometry) {\n    const rings = geometry.getCoordinates();\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      const coordinates = rings[j];\n      for (let i = 0, ii = coordinates.length - 1; i < ii; ++i) {\n        const segment = coordinates.slice(i, i + 2);\n        const segmentData = /** @type {SegmentData} */ ({\n          feature: feature,\n          segment: segment\n        });\n        this.rBush_.insert(boundingExtent(segment), segmentData);\n      }\n    }\n  }\n}\n\n\n/**\n * Sort segments by distance, helper function\n * @param {SegmentData} a The first segment data.\n * @param {SegmentData} b The second segment data.\n * @return {number} The difference in distance.\n * @this {Snap}\n */\nfunction sortByDistance(a, b) {\n  const deltaA = squaredDistanceToSegment(this.pixelCoordinate_, a.segment);\n  const deltaB = squaredDistanceToSegment(this.pixelCoordinate_, b.segment);\n  return deltaA - deltaB;\n}\n\nexport default Snap;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}