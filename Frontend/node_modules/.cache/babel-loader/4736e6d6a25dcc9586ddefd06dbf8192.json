{"ast":null,"code":"/**\n * @module ol/reproj\n */\nimport { createCanvasContext2D } from './dom.js';\nimport { containsCoordinate, createEmpty, extend, getHeight, getTopLeft, getWidth } from './extent.js';\nimport { solveLinearSystem } from './math.js';\nimport { getPointResolution, transform } from './proj.js';\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {\n  var sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);\n  var targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  var sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n  return sourceResolution;\n}\n\n/**\n * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap\n * in order to mask gaps caused by antialiasing.\n *\n * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).\n * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).\n * @param {number} x X coordinate of the point (in pixels).\n * @param {number} y Y coordinate of the point (in pixels).\n * @return {import(\"./coordinate.js\").Coordinate} New point 1 px farther from the centroid.\n */\nfunction enlargeClipPoint(centroidX, centroidY, x, y) {\n  var dX = x - centroidX;\n  var dY = y - centroidY;\n  var distance = Math.sqrt(dX * dX + dY * dY);\n  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];\n}\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation\n * Calculated triangulation.\n * @param {Array<{extent: import(\"./extent.js\").Extent,\n *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources\n * Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean=} opt_renderEdges Render reprojection edges.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges) {\n  var context = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n  context.scale(pixelRatio, pixelRatio);\n  var sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n  var canvasWidthInUnits = getWidth(sourceDataExtent);\n  var canvasHeightInUnits = getHeight(sourceDataExtent);\n  var stitchContext = createCanvasContext2D(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));\n  var stitchScale = pixelRatio / sourceResolution;\n  sources.forEach(function (src, i, arr) {\n    var xPos = src.extent[0] - sourceDataExtent[0];\n    var yPos = -(src.extent[3] - sourceDataExtent[3]);\n    var srcWidth = getWidth(src.extent);\n    var srcHeight = getHeight(src.extent);\n    stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);\n  });\n  var targetTopLeft = getTopLeft(targetExtent);\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    var source = triangle.source;\n    var target = triangle.target;\n    var x0 = source[0][0],\n      y0 = source[0][1];\n    var x1 = source[1][0],\n      y1 = source[1][1];\n    var x2 = source[2][0],\n      y2 = source[2][1];\n    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n    var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n    var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n    var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    var sourceNumericalShiftX = x0;\n    var sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n    var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];\n    var affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n    context.save();\n    context.beginPath();\n    var centroidX = (u0 + u1 + u2) / 3;\n    var centroidY = (v0 + v1 + v2) / 3;\n    var p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);\n    var p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);\n    var p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);\n    context.moveTo(p1[0], p1[1]);\n    context.lineTo(p0[0], p0[1]);\n    context.lineTo(p2[0], p2[1]);\n    context.clip();\n    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);\n    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);\n    context.drawImage(stitchContext.canvas, 0, 0);\n    context.restore();\n  });\n  if (opt_renderEdges) {\n    context.save();\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      var target = triangle.target;\n      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n    context.restore();\n  }\n  return context.canvas;\n}","map":{"version":3,"names":["createCanvasContext2D","containsCoordinate","createEmpty","extend","getHeight","getTopLeft","getWidth","solveLinearSystem","getPointResolution","transform","calculateSourceResolution","sourceProj","targetProj","targetCenter","targetResolution","sourceCenter","sourceResolution","targetMetersPerUnit","getMetersPerUnit","undefined","sourceMetersPerUnit","sourceExtent","getExtent","compensationFactor","isFinite","enlargeClipPoint","centroidX","centroidY","x","y","dX","dY","distance","Math","sqrt","round","render","width","height","pixelRatio","targetExtent","triangulation","sources","gutter","opt_renderEdges","context","length","canvas","scale","sourceDataExtent","forEach","src","i","arr","extent","canvasWidthInUnits","canvasHeightInUnits","stitchContext","stitchScale","xPos","yPos","srcWidth","srcHeight","drawImage","image","targetTopLeft","getTriangles","triangle","source","target","x0","y0","x1","y1","x2","y2","u0","v0","u1","v1","u2","v2","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","save","beginPath","p0","p1","p2","moveTo","lineTo","clip","translate","restore","strokeStyle","lineWidth","closePath","stroke"],"sources":["../../src/ol/reproj.js"],"sourcesContent":["/**\n * @module ol/reproj\n */\nimport {createCanvasContext2D} from './dom.js';\nimport {containsCoordinate, createEmpty, extend, getHeight, getTopLeft, getWidth} from './extent.js';\nimport {solveLinearSystem} from './math.js';\nimport {getPointResolution, transform} from './proj.js';\n\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(sourceProj, targetProj,\n  targetCenter, targetResolution) {\n\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  let sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);\n\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  const sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    const compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n        sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n\n\n/**\n * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap\n * in order to mask gaps caused by antialiasing.\n *\n * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).\n * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).\n * @param {number} x X coordinate of the point (in pixels).\n * @param {number} y Y coordinate of the point (in pixels).\n * @return {import(\"./coordinate.js\").Coordinate} New point 1 px farther from the centroid.\n */\nfunction enlargeClipPoint(centroidX, centroidY, x, y) {\n  const dX = x - centroidX;\n  const dY = y - centroidY;\n  const distance = Math.sqrt(dX * dX + dY * dY);\n  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];\n}\n\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation\n * Calculated triangulation.\n * @param {Array<{extent: import(\"./extent.js\").Extent,\n *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources\n * Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean=} opt_renderEdges Render reprojection edges.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(width, height, pixelRatio,\n  sourceResolution, sourceExtent, targetResolution, targetExtent,\n  triangulation, sources, gutter, opt_renderEdges) {\n\n  const context = createCanvasContext2D(Math.round(pixelRatio * width),\n    Math.round(pixelRatio * height));\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function(src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  const canvasWidthInUnits = getWidth(sourceDataExtent);\n  const canvasHeightInUnits = getHeight(sourceDataExtent);\n  const stitchContext = createCanvasContext2D(\n    Math.round(pixelRatio * canvasWidthInUnits / sourceResolution),\n    Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));\n\n  const stitchScale = pixelRatio / sourceResolution;\n\n  sources.forEach(function(src, i, arr) {\n    const xPos = src.extent[0] - sourceDataExtent[0];\n    const yPos = -(src.extent[3] - sourceDataExtent[3]);\n    const srcWidth = getWidth(src.extent);\n    const srcHeight = getHeight(src.extent);\n\n    stitchContext.drawImage(\n      src.image,\n      gutter, gutter,\n      src.image.width - 2 * gutter, src.image.height - 2 * gutter,\n      xPos * stitchScale, yPos * stitchScale,\n      srcWidth * stitchScale, srcHeight * stitchScale);\n  });\n\n  const targetTopLeft = getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function(triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    const source = triangle.source;\n    const target = triangle.target;\n    let x0 = source[0][0], y0 = source[0][1];\n    let x1 = source[1][0], y1 = source[1][1];\n    let x2 = source[2][0], y2 = source[2][1];\n    const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n    const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n    const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n    const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n    const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n    const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    const sourceNumericalShiftX = x0;\n    const sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    const augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0]\n    ];\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n    const centroidX = (u0 + u1 + u2) / 3;\n    const centroidY = (v0 + v1 + v2) / 3;\n    const p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);\n    const p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);\n    const p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);\n\n    context.moveTo(p1[0], p1[1]);\n    context.lineTo(p0[0], p0[1]);\n    context.lineTo(p2[0], p2[1]);\n    context.clip();\n\n    context.transform(\n      affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n\n    context.translate(sourceDataExtent[0] - sourceNumericalShiftX,\n      sourceDataExtent[3] - sourceNumericalShiftY);\n\n    context.scale(sourceResolution / pixelRatio,\n      -sourceResolution / pixelRatio);\n\n    context.drawImage(stitchContext.canvas, 0, 0);\n    context.restore();\n  });\n\n  if (opt_renderEdges) {\n    context.save();\n\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function(triangle, i, arr) {\n      const target = triangle.target;\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}