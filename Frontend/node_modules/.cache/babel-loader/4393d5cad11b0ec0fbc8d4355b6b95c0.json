{"ast":null,"code":"/**\n * @module ol/style/Atlas\n */\nimport { createCanvasContext2D } from '../dom.js';\n\n/**\n * @typedef {Object} AtlasBlock\n * @property {number} x\n * @property {number} y\n * @property {number} width\n * @property {number} height\n */\n\n/**\n * Provides information for an image inside an atlas.\n * `offsetX` and `offsetY` are the position of the image inside the atlas image `image`.\n * @typedef {Object} AtlasInfo\n * @property {number} offsetX\n * @property {number} offsetY\n * @property {HTMLCanvasElement} image\n */\n\n/**\n * @classesc\n * This class facilitates the creation of image atlases.\n *\n * Images added to an atlas will be rendered onto a single\n * atlas canvas. The distribution of images on the canvas is\n * managed with the bin packing algorithm described in:\n * http://www.blackpawn.com/texts/lightmaps/\n *\n * @param {number} size The size in pixels of the sprite image.\n * @param {number} space The space in pixels between images.\n *    Because texture coordinates are float values, the edges of\n *    images might not be completely correct (in a way that the\n *    edges overlap when being rendered). To avoid this we add a\n *    padding around each image.\n */\nvar Atlas = function Atlas(size, space) {\n  /**\n   * @private\n   * @type {number}\n   */\n  this.space_ = space;\n\n  /**\n   * @private\n   * @type {Array<AtlasBlock>}\n   */\n  this.emptyBlocks_ = [{\n    x: 0,\n    y: 0,\n    width: size,\n    height: size\n  }];\n\n  /**\n   * @private\n   * @type {Object<string, AtlasInfo>}\n   */\n  this.entries_ = {};\n\n  /**\n   * @private\n   * @type {CanvasRenderingContext2D}\n   */\n  this.context_ = createCanvasContext2D(size, size);\n\n  /**\n   * @private\n   * @type {HTMLCanvasElement}\n   */\n  this.canvas_ = this.context_.canvas;\n};\n\n/**\n * @param {string} id The identifier of the entry to check.\n * @return {?AtlasInfo} The atlas info.\n */\nAtlas.prototype.get = function get(id) {\n  return this.entries_[id] || null;\n};\n\n/**\n * @param {string} id The identifier of the entry to add.\n * @param {number} width The width.\n * @param {number} height The height.\n * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n *  Called to render the new image onto an atlas image.\n * @param {Object=} opt_this Value to use as `this` when executing\n *  `renderCallback`.\n * @return {?AtlasInfo} The position and atlas image for the entry.\n */\nAtlas.prototype.add = function add(id, width, height, renderCallback, opt_this) {\n  for (var i = 0, ii = this.emptyBlocks_.length; i < ii; ++i) {\n    var block = this.emptyBlocks_[i];\n    if (block.width >= width + this.space_ && block.height >= height + this.space_) {\n      // we found a block that is big enough for our entry\n      var entry = {\n        offsetX: block.x + this.space_,\n        offsetY: block.y + this.space_,\n        image: this.canvas_\n      };\n      this.entries_[id] = entry;\n\n      // render the image on the atlas image\n      renderCallback.call(opt_this, this.context_, block.x + this.space_, block.y + this.space_);\n\n      // split the block after the insertion, either horizontally or vertically\n      this.split_(i, block, width + this.space_, height + this.space_);\n      return entry;\n    }\n  }\n\n  // there is no space for the new entry in this atlas\n  return null;\n};\n\n/**\n * @private\n * @param {number} index The index of the block.\n * @param {AtlasBlock} block The block to split.\n * @param {number} width The width of the entry to insert.\n * @param {number} height The height of the entry to insert.\n */\nAtlas.prototype.split_ = function split_(index, block, width, height) {\n  var deltaWidth = block.width - width;\n  var deltaHeight = block.height - height;\n\n  /** @type {AtlasBlock} */\n  var newBlock1;\n  /** @type {AtlasBlock} */\n  var newBlock2;\n  if (deltaWidth > deltaHeight) {\n    // split vertically\n    // block right of the inserted entry\n    newBlock1 = {\n      x: block.x + width,\n      y: block.y,\n      width: block.width - width,\n      height: block.height\n    };\n\n    // block below the inserted entry\n    newBlock2 = {\n      x: block.x,\n      y: block.y + height,\n      width: width,\n      height: block.height - height\n    };\n    this.updateBlocks_(index, newBlock1, newBlock2);\n  } else {\n    // split horizontally\n    // block right of the inserted entry\n    newBlock1 = {\n      x: block.x + width,\n      y: block.y,\n      width: block.width - width,\n      height: height\n    };\n\n    // block below the inserted entry\n    newBlock2 = {\n      x: block.x,\n      y: block.y + height,\n      width: block.width,\n      height: block.height - height\n    };\n    this.updateBlocks_(index, newBlock1, newBlock2);\n  }\n};\n\n/**\n * Remove the old block and insert new blocks at the same array position.\n * The new blocks are inserted at the same position, so that splitted\n * blocks (that are potentially smaller) are filled first.\n * @private\n * @param {number} index The index of the block to remove.\n * @param {AtlasBlock} newBlock1 The 1st block to add.\n * @param {AtlasBlock} newBlock2 The 2nd block to add.\n */\nAtlas.prototype.updateBlocks_ = function updateBlocks_(index, newBlock1, newBlock2) {\n  var args = /** @type {Array<*>} */[index, 1];\n  if (newBlock1.width > 0 && newBlock1.height > 0) {\n    args.push(newBlock1);\n  }\n  if (newBlock2.width > 0 && newBlock2.height > 0) {\n    args.push(newBlock2);\n  }\n  this.emptyBlocks_.splice.apply(this.emptyBlocks_, args);\n};\nexport default Atlas;","map":{"version":3,"names":["createCanvasContext2D","Atlas","size","space","space_","emptyBlocks_","x","y","width","height","entries_","context_","canvas_","canvas","prototype","get","id","add","renderCallback","opt_this","i","ii","length","block","entry","offsetX","offsetY","image","call","split_","index","deltaWidth","deltaHeight","newBlock1","newBlock2","updateBlocks_","args","push","splice","apply"],"sources":["../../../src/ol/style/Atlas.js"],"sourcesContent":["/**\n * @module ol/style/Atlas\n */\nimport {createCanvasContext2D} from '../dom.js';\n\n\n/**\n * @typedef {Object} AtlasBlock\n * @property {number} x\n * @property {number} y\n * @property {number} width\n * @property {number} height\n */\n\n/**\n * Provides information for an image inside an atlas.\n * `offsetX` and `offsetY` are the position of the image inside the atlas image `image`.\n * @typedef {Object} AtlasInfo\n * @property {number} offsetX\n * @property {number} offsetY\n * @property {HTMLCanvasElement} image\n */\n\n\n/**\n * @classesc\n * This class facilitates the creation of image atlases.\n *\n * Images added to an atlas will be rendered onto a single\n * atlas canvas. The distribution of images on the canvas is\n * managed with the bin packing algorithm described in:\n * http://www.blackpawn.com/texts/lightmaps/\n *\n * @param {number} size The size in pixels of the sprite image.\n * @param {number} space The space in pixels between images.\n *    Because texture coordinates are float values, the edges of\n *    images might not be completely correct (in a way that the\n *    edges overlap when being rendered). To avoid this we add a\n *    padding around each image.\n */\nclass Atlas {\n\n  /**\n   * @param {number} size The size in pixels of the sprite image.\n   * @param {number} space The space in pixels between images.\n   *    Because texture coordinates are float values, the edges of\n   *    images might not be completely correct (in a way that the\n   *    edges overlap when being rendered). To avoid this we add a\n   *    padding around each image.\n   */\n  constructor(size, space) {\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.space_ = space;\n\n    /**\n     * @private\n     * @type {Array<AtlasBlock>}\n     */\n    this.emptyBlocks_ = [{x: 0, y: 0, width: size, height: size}];\n\n    /**\n     * @private\n     * @type {Object<string, AtlasInfo>}\n     */\n    this.entries_ = {};\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context_ = createCanvasContext2D(size, size);\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = this.context_.canvas;\n  }\n\n  /**\n   * @param {string} id The identifier of the entry to check.\n   * @return {?AtlasInfo} The atlas info.\n   */\n  get(id) {\n    return this.entries_[id] || null;\n  }\n\n  /**\n   * @param {string} id The identifier of the entry to add.\n   * @param {number} width The width.\n   * @param {number} height The height.\n   * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n   *    Called to render the new image onto an atlas image.\n   * @param {Object=} opt_this Value to use as `this` when executing\n   *    `renderCallback`.\n   * @return {?AtlasInfo} The position and atlas image for the entry.\n   */\n  add(id, width, height, renderCallback, opt_this) {\n    for (let i = 0, ii = this.emptyBlocks_.length; i < ii; ++i) {\n      const block = this.emptyBlocks_[i];\n      if (block.width >= width + this.space_ &&\n          block.height >= height + this.space_) {\n        // we found a block that is big enough for our entry\n        const entry = {\n          offsetX: block.x + this.space_,\n          offsetY: block.y + this.space_,\n          image: this.canvas_\n        };\n        this.entries_[id] = entry;\n\n        // render the image on the atlas image\n        renderCallback.call(opt_this, this.context_,\n          block.x + this.space_, block.y + this.space_);\n\n        // split the block after the insertion, either horizontally or vertically\n        this.split_(i, block, width + this.space_, height + this.space_);\n\n        return entry;\n      }\n    }\n\n    // there is no space for the new entry in this atlas\n    return null;\n  }\n\n  /**\n   * @private\n   * @param {number} index The index of the block.\n   * @param {AtlasBlock} block The block to split.\n   * @param {number} width The width of the entry to insert.\n   * @param {number} height The height of the entry to insert.\n   */\n  split_(index, block, width, height) {\n    const deltaWidth = block.width - width;\n    const deltaHeight = block.height - height;\n\n    /** @type {AtlasBlock} */\n    let newBlock1;\n    /** @type {AtlasBlock} */\n    let newBlock2;\n\n    if (deltaWidth > deltaHeight) {\n      // split vertically\n      // block right of the inserted entry\n      newBlock1 = {\n        x: block.x + width,\n        y: block.y,\n        width: block.width - width,\n        height: block.height\n      };\n\n      // block below the inserted entry\n      newBlock2 = {\n        x: block.x,\n        y: block.y + height,\n        width: width,\n        height: block.height - height\n      };\n      this.updateBlocks_(index, newBlock1, newBlock2);\n    } else {\n      // split horizontally\n      // block right of the inserted entry\n      newBlock1 = {\n        x: block.x + width,\n        y: block.y,\n        width: block.width - width,\n        height: height\n      };\n\n      // block below the inserted entry\n      newBlock2 = {\n        x: block.x,\n        y: block.y + height,\n        width: block.width,\n        height: block.height - height\n      };\n      this.updateBlocks_(index, newBlock1, newBlock2);\n    }\n  }\n\n  /**\n   * Remove the old block and insert new blocks at the same array position.\n   * The new blocks are inserted at the same position, so that splitted\n   * blocks (that are potentially smaller) are filled first.\n   * @private\n   * @param {number} index The index of the block to remove.\n   * @param {AtlasBlock} newBlock1 The 1st block to add.\n   * @param {AtlasBlock} newBlock2 The 2nd block to add.\n   */\n  updateBlocks_(index, newBlock1, newBlock2) {\n    const args = /** @type {Array<*>} */ ([index, 1]);\n    if (newBlock1.width > 0 && newBlock1.height > 0) {\n      args.push(newBlock1);\n    }\n    if (newBlock2.width > 0 && newBlock2.height > 0) {\n      args.push(newBlock2);\n    }\n    this.emptyBlocks_.splice.apply(this.emptyBlocks_, args);\n  }\n}\n\nexport default Atlas;\n"],"mappings":"AAAA;;;AAGA,SAAQA,qBAAqB,QAAO,WAAW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqC/C,IAAMC,KAAK,GAUT,SAAAA,KAAWA,CAACC,IAAI,EAAEC,KAAK,EAAE;EAEzB;;;;EAIA,IAAM,CAACC,MAAM,GAAGD,KAAK;;EAErB;;;;EAIA,IAAM,CAACE,YAAY,GAAG,CAAC;IAACC,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;IAAEC,KAAK,EAAEN,IAAI;IAAEO,MAAM,EAAEP;EAAI,CAAC,CAAC;;EAE/D;;;;EAIA,IAAM,CAACQ,QAAQ,GAAG,EAAE;;EAEpB;;;;EAIA,IAAM,CAACC,QAAQ,GAAGX,qBAAqB,CAACE,IAAI,EAAEA,IAAI,CAAC;;EAEnD;;;;EAIA,IAAM,CAACU,OAAO,GAAG,IAAI,CAACD,QAAQ,CAACE,MAAM;AACvC,CAAE;;AAEF;;;;AAIAZ,KAAA,CAAAa,SAAA,CAAEC,GAAA,YAAAA,IAAIC,EAAE,EAAE;EACR,OAAS,IAAI,CAACN,QAAQ,CAACM,EAAE,CAAC,IAAI,IAAI;AACpC,CAAE;;AAEF;;;;;;;;;;AAUAf,KAAA,CAAAa,SAAA,CAAEG,GAAA,YAAAA,IAAID,EAAE,EAAER,KAAK,EAAEC,MAAM,EAAES,cAAc,EAAEC,QAAQ,EAAE;EACjD,KAAO,IAAIC,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAG,IAAI,CAAChB,YAAY,CAACiB,MAAM,EAAEF,CAAC,GAAGC,EAAE,EAAE,EAAED,CAAC,EAAE;IAC5D,IAAQG,KAAK,GAAG,IAAI,CAAClB,YAAY,CAACe,CAAC,CAAC;IACpC,IAAMG,KAAK,CAACf,KAAK,IAAIA,KAAK,GAAG,IAAI,CAACJ,MAAM,IACpCmB,KAAO,CAACd,MAAM,IAAIA,MAAM,GAAG,IAAI,CAACL,MAAM,EAAE;MAC1C;MACA,IAAQoB,KAAK,GAAG;QACdC,OAAS,EAAEF,KAAK,CAACjB,CAAC,GAAG,IAAI,CAACF,MAAM;QAChCsB,OAAS,EAAEH,KAAK,CAAChB,CAAC,GAAG,IAAI,CAACH,MAAM;QAChCuB,KAAO,EAAE,IAAI,CAACf;MAChB,CAAG;MACH,IAAM,CAACF,QAAQ,CAACM,EAAE,CAAC,GAAGQ,KAAK;;MAE3B;MACAN,cAAgB,CAACU,IAAI,CAACT,QAAQ,EAAE,IAAI,CAACR,QAAQ,EAC3CY,KAAO,CAACjB,CAAC,GAAG,IAAI,CAACF,MAAM,EAAEmB,KAAK,CAAChB,CAAC,GAAG,IAAI,CAACH,MAAM,CAAC;;MAEjD;MACA,IAAM,CAACyB,MAAM,CAACT,CAAC,EAAEG,KAAK,EAAEf,KAAK,GAAG,IAAI,CAACJ,MAAM,EAAEK,MAAM,GAAG,IAAI,CAACL,MAAM,CAAC;MAElE,OAASoB,KAAK;IAChB;EACF;;EAEA;EACA,OAAS,IAAI;AACf,CAAE;;AAEF;;;;;;;AAOAvB,KAAA,CAAAa,SAAA,CAAEe,MAAA,YAAAA,OAAOC,KAAK,EAAEP,KAAK,EAAEf,KAAK,EAAEC,MAAM,EAAE;EACpC,IAAQsB,UAAU,GAAGR,KAAK,CAACf,KAAK,GAAGA,KAAK;EACxC,IAAQwB,WAAW,GAAGT,KAAK,CAACd,MAAM,GAAGA,MAAM;;EAE3C;EACA,IAAMwB,SAAS;EACf;EACA,IAAMC,SAAS;EAEf,IAAMH,UAAU,GAAGC,WAAW,EAAE;IAC9B;IACA;IACAC,SAAW,GAAG;MACZ3B,CAAG,EAAEiB,KAAK,CAACjB,CAAC,GAAGE,KAAK;MACpBD,CAAG,EAAEgB,KAAK,CAAChB,CAAC;MACZC,KAAO,EAAEe,KAAK,CAACf,KAAK,GAAGA,KAAK;MAC5BC,MAAQ,EAAEc,KAAK,CAACd;IAClB,CAAG;;IAEH;IACAyB,SAAW,GAAG;MACZ5B,CAAG,EAAEiB,KAAK,CAACjB,CAAC;MACZC,CAAG,EAAEgB,KAAK,CAAChB,CAAC,GAAGE,MAAM;MACrBD,KAAO,EAAEA,KAAK;MACdC,MAAQ,EAAEc,KAAK,CAACd,MAAM,GAAGA;IAC3B,CAAG;IACH,IAAM,CAAC0B,aAAa,CAACL,KAAK,EAAEG,SAAS,EAAEC,SAAS,CAAC;EACnD,CAAG,MAAM;IACP;IACA;IACAD,SAAW,GAAG;MACZ3B,CAAG,EAAEiB,KAAK,CAACjB,CAAC,GAAGE,KAAK;MACpBD,CAAG,EAAEgB,KAAK,CAAChB,CAAC;MACZC,KAAO,EAAEe,KAAK,CAACf,KAAK,GAAGA,KAAK;MAC5BC,MAAQ,EAAEA;IACZ,CAAG;;IAEH;IACAyB,SAAW,GAAG;MACZ5B,CAAG,EAAEiB,KAAK,CAACjB,CAAC;MACZC,CAAG,EAAEgB,KAAK,CAAChB,CAAC,GAAGE,MAAM;MACrBD,KAAO,EAAEe,KAAK,CAACf,KAAK;MACpBC,MAAQ,EAAEc,KAAK,CAACd,MAAM,GAAGA;IAC3B,CAAG;IACH,IAAM,CAAC0B,aAAa,CAACL,KAAK,EAAEG,SAAS,EAAEC,SAAS,CAAC;EACnD;AACF,CAAE;;AAEF;;;;;;;;;AASAjC,KAAA,CAAAa,SAAA,CAAEqB,aAAA,YAAAA,cAAcL,KAAK,EAAEG,SAAS,EAAEC,SAAS,EAAE;EAC3C,IAAQE,IAAI,0BAA4B,CAACN,KAAK,EAAE,CAAC,CAAE;EACnD,IAAMG,SAAS,CAACzB,KAAK,GAAG,CAAC,IAAIyB,SAAS,CAACxB,MAAM,GAAG,CAAC,EAAE;IACjD2B,IAAM,CAACC,IAAI,CAACJ,SAAS,CAAC;EACxB;EACA,IAAMC,SAAS,CAAC1B,KAAK,GAAG,CAAC,IAAI0B,SAAS,CAACzB,MAAM,GAAG,CAAC,EAAE;IACjD2B,IAAM,CAACC,IAAI,CAACH,SAAS,CAAC;EACxB;EACA,IAAM,CAAC7B,YAAY,CAACiC,MAAM,CAACC,KAAK,CAAC,IAAI,CAAClC,YAAY,EAAE+B,IAAI,CAAC;AAC3D,CAAG;AAGH,eAAenC,KAAK"},"metadata":{},"sourceType":"module"}