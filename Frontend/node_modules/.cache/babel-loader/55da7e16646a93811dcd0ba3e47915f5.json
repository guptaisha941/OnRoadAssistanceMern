{"ast":null,"code":"/**\n * @module ol/render/canvas/Replay\n */\nimport { getUid } from '../../util.js';\nimport { equals, reverseSubArray } from '../../array.js';\nimport { asColorLike } from '../../colorlike.js';\nimport { buffer, clone, coordinateRelationship, createEmpty, createOrUpdate, createOrUpdateEmpty, extend, extendCoordinate, intersects } from '../../extent.js';\nimport Relationship from '../../extent/Relationship.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport { inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray } from '../../geom/flat/inflate.js';\nimport { lineStringLength } from '../../geom/flat/length.js';\nimport { drawTextOnPath } from '../../geom/flat/textpath.js';\nimport { transform2D } from '../../geom/flat/transform.js';\nimport { CANVAS_LINE_DASH } from '../../has.js';\nimport { isEmpty } from '../../obj.js';\nimport VectorContext from '../VectorContext.js';\nimport { drawImage, resetTransform, defaultPadding, defaultFillStyle, defaultStrokeStyle, defaultMiterLimit, defaultLineWidth, defaultLineJoin, defaultLineDashOffset, defaultLineDash, defaultLineCap } from '../canvas.js';\nimport CanvasInstruction from './Instruction.js';\nimport { TEXT_ALIGN } from '../replay.js';\nimport { create as createTransform, compose as composeTransform, apply as applyTransform, setFromArray as transformSetFromArray } from '../../transform.js';\n\n/**\n * @type {import(\"../../extent.js\").Extent}\n */\nvar tmpExtent = createEmpty();\n\n/**\n * @type {!import(\"../../transform.js\").Transform}\n */\nvar tmpTransform = createTransform();\nvar CanvasReplay = /*@__PURE__*/function (VectorContext) {\n  function CanvasReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    VectorContext.call(this);\n\n    /**\n     * @type {?}\n     */\n    this.declutterTree = declutterTree;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.tolerance = tolerance;\n\n    /**\n     * @protected\n     * @const\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent = maxExtent;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.overlaps = overlaps;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.pixelRatio = pixelRatio;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.maxLineWidth = 0;\n\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n    this.resolution = resolution;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.alignFill_;\n\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    this.beginGeometryInstruction1_ = null;\n\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    this.beginGeometryInstruction2_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.bufferedMaxExtent_ = null;\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.instructions = [];\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.coordinates = [];\n\n    /**\n     * @private\n     * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\n     */\n    this.coordinateCache_ = {};\n\n    /**\n     * @private\n     * @type {!import(\"../../transform.js\").Transform}\n     */\n    this.renderedTransform_ = createTransform();\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.hitDetectionInstructions = [];\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.pixelCoordinates_ = null;\n\n    /**\n     * @protected\n     * @type {import(\"../canvas.js\").FillStrokeState}\n     */\n    this.state = /** @type {import(\"../canvas.js\").FillStrokeState} */{};\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.viewRotation_ = 0;\n  }\n  if (VectorContext) CanvasReplay.__proto__ = VectorContext;\n  CanvasReplay.prototype = Object.create(VectorContext && VectorContext.prototype);\n  CanvasReplay.prototype.constructor = CanvasReplay;\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   */\n  CanvasReplay.prototype.replayTextBackground_ = function replayTextBackground_(context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {\n    context.beginPath();\n    context.moveTo.apply(context, p1);\n    context.lineTo.apply(context, p2);\n    context.lineTo.apply(context, p3);\n    context.lineTo.apply(context, p4);\n    context.lineTo.apply(context, p1);\n    if (fillInstruction) {\n      this.alignFill_ = /** @type {boolean} */fillInstruction[2];\n      this.fill_(context);\n    }\n    if (strokeInstruction) {\n      this.setStrokeStyle_(context, /** @type {Array<*>} */strokeInstruction);\n      context.stroke();\n    }\n  };\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.\n   * @param {number} anchorX Anchor X.\n   * @param {number} anchorY Anchor Y.\n   * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n   * @param {number} height Height.\n   * @param {number} opacity Opacity.\n   * @param {number} originX Origin X.\n   * @param {number} originY Origin Y.\n   * @param {number} rotation Rotation.\n   * @param {number} scale Scale.\n   * @param {boolean} snapToPixel Snap to pixel.\n   * @param {number} width Width.\n   * @param {Array<number>} padding Padding.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   */\n  CanvasReplay.prototype.replayImage_ = function replayImage_(context, x, y, image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {\n    var fillStroke = fillInstruction || strokeInstruction;\n    anchorX *= scale;\n    anchorY *= scale;\n    x -= anchorX;\n    y -= anchorY;\n    var w = width + originX > image.width ? image.width - originX : width;\n    var h = height + originY > image.height ? image.height - originY : height;\n    var boxW = padding[3] + w * scale + padding[1];\n    var boxH = padding[0] + h * scale + padding[2];\n    var boxX = x - padding[3];\n    var boxY = y - padding[0];\n\n    /** @type {import(\"../../coordinate.js\").Coordinate} */\n    var p1;\n    /** @type {import(\"../../coordinate.js\").Coordinate} */\n    var p2;\n    /** @type {import(\"../../coordinate.js\").Coordinate} */\n    var p3;\n    /** @type {import(\"../../coordinate.js\").Coordinate} */\n    var p4;\n    if (fillStroke || rotation !== 0) {\n      p1 = [boxX, boxY];\n      p2 = [boxX + boxW, boxY];\n      p3 = [boxX + boxW, boxY + boxH];\n      p4 = [boxX, boxY + boxH];\n    }\n    var transform = null;\n    if (rotation !== 0) {\n      var centerX = x + anchorX;\n      var centerY = y + anchorY;\n      transform = composeTransform(tmpTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n      createOrUpdateEmpty(tmpExtent);\n      extendCoordinate(tmpExtent, applyTransform(tmpTransform, p1));\n      extendCoordinate(tmpExtent, applyTransform(tmpTransform, p2));\n      extendCoordinate(tmpExtent, applyTransform(tmpTransform, p3));\n      extendCoordinate(tmpExtent, applyTransform(tmpTransform, p4));\n    } else {\n      createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);\n    }\n    var canvas = context.canvas;\n    var strokePadding = strokeInstruction ? strokeInstruction[2] * scale / 2 : 0;\n    var intersects = tmpExtent[0] - strokePadding <= canvas.width && tmpExtent[2] + strokePadding >= 0 && tmpExtent[1] - strokePadding <= canvas.height && tmpExtent[3] + strokePadding >= 0;\n    if (snapToPixel) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n    if (declutterGroup) {\n      if (!intersects && declutterGroup[4] == 1) {\n        return;\n      }\n      extend(declutterGroup, tmpExtent);\n      var declutterArgs = intersects ? [context, transform ? transform.slice(0) : null, opacity, image, originX, originY, w, h, x, y, scale] : null;\n      if (declutterArgs && fillStroke) {\n        declutterArgs.push(fillInstruction, strokeInstruction, p1, p2, p3, p4);\n      }\n      declutterGroup.push(declutterArgs);\n    } else if (intersects) {\n      if (fillStroke) {\n        this.replayTextBackground_(context, p1, p2, p3, p4, /** @type {Array<*>} */fillInstruction, /** @type {Array<*>} */strokeInstruction);\n      }\n      drawImage(context, transform, opacity, image, originX, originY, w, h, x, y, scale);\n    }\n  };\n\n  /**\n   * @protected\n   * @param {Array<number>} dashArray Dash array.\n   * @return {Array<number>} Dash array with pixel ratio applied\n   */\n  CanvasReplay.prototype.applyPixelRatio = function applyPixelRatio(dashArray) {\n    var pixelRatio = this.pixelRatio;\n    return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {\n      return dash * pixelRatio;\n    });\n  };\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} closed Last input coordinate equals first.\n   * @param {boolean} skipFirst Skip first coordinate.\n   * @protected\n   * @return {number} My end.\n   */\n  CanvasReplay.prototype.appendFlatCoordinates = function appendFlatCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {\n    var myEnd = this.coordinates.length;\n    var extent = this.getBufferedMaxExtent();\n    if (skipFirst) {\n      offset += stride;\n    }\n    var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n    var nextCoord = [NaN, NaN];\n    var skipped = true;\n    var i, lastRel, nextRel;\n    for (i = offset + stride; i < end; i += stride) {\n      nextCoord[0] = flatCoordinates[i];\n      nextCoord[1] = flatCoordinates[i + 1];\n      nextRel = coordinateRelationship(extent, nextCoord);\n      if (nextRel !== lastRel) {\n        if (skipped) {\n          this.coordinates[myEnd++] = lastCoord[0];\n          this.coordinates[myEnd++] = lastCoord[1];\n        }\n        this.coordinates[myEnd++] = nextCoord[0];\n        this.coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else if (nextRel === Relationship.INTERSECTING) {\n        this.coordinates[myEnd++] = nextCoord[0];\n        this.coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else {\n        skipped = true;\n      }\n      lastCoord[0] = nextCoord[0];\n      lastCoord[1] = nextCoord[1];\n      lastRel = nextRel;\n    }\n\n    // Last coordinate equals first or only one point to append:\n    if (closed && skipped || i === offset + stride) {\n      this.coordinates[myEnd++] = lastCoord[0];\n      this.coordinates[myEnd++] = lastCoord[1];\n    }\n    return myEnd;\n  };\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array<number>} replayEnds Replay ends.\n   * @return {number} Offset.\n   */\n  CanvasReplay.prototype.drawCustomCoordinates_ = function drawCustomCoordinates_(flatCoordinates, offset, ends, stride, replayEnds) {\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var replayEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\n      replayEnds.push(replayEnd);\n      offset = end;\n    }\n    return offset;\n  };\n\n  /**\n   * @inheritDoc.\n   */\n  CanvasReplay.prototype.drawCustom = function drawCustom(geometry, feature, renderer) {\n    this.beginGeometry(geometry, feature);\n    var type = geometry.getType();\n    var stride = geometry.getStride();\n    var replayBegin = this.coordinates.length;\n    var flatCoordinates, replayEnd, replayEnds, replayEndss;\n    var offset;\n    if (type == GeometryType.MULTI_POLYGON) {\n      geometry = /** @type {import(\"../../geom/MultiPolygon.js\").default} */geometry;\n      flatCoordinates = geometry.getOrientedFlatCoordinates();\n      replayEndss = [];\n      var endss = geometry.getEndss();\n      offset = 0;\n      for (var i = 0, ii = endss.length; i < ii; ++i) {\n        var myEnds = [];\n        offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n        replayEndss.push(myEnds);\n      }\n      this.instructions.push([CanvasInstruction.CUSTOM, replayBegin, replayEndss, geometry, renderer, inflateMultiCoordinatesArray]);\n    } else if (type == GeometryType.POLYGON || type == GeometryType.MULTI_LINE_STRING) {\n      replayEnds = [];\n      flatCoordinates = type == GeometryType.POLYGON ? /** @type {import(\"../../geom/Polygon.js\").default} */geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();\n      offset = this.drawCustomCoordinates_(flatCoordinates, 0, /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */geometry.getEnds(), stride, replayEnds);\n      this.instructions.push([CanvasInstruction.CUSTOM, replayBegin, replayEnds, geometry, renderer, inflateCoordinatesArray]);\n    } else if (type == GeometryType.LINE_STRING || type == GeometryType.MULTI_POINT) {\n      flatCoordinates = geometry.getFlatCoordinates();\n      replayEnd = this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n      this.instructions.push([CanvasInstruction.CUSTOM, replayBegin, replayEnd, geometry, renderer, inflateCoordinates]);\n    } else if (type == GeometryType.POINT) {\n      flatCoordinates = geometry.getFlatCoordinates();\n      this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n      replayEnd = this.coordinates.length;\n      this.instructions.push([CanvasInstruction.CUSTOM, replayBegin, replayEnd, geometry, renderer]);\n    }\n    this.endGeometry(geometry, feature);\n  };\n\n  /**\n   * @protected\n   * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n   */\n  CanvasReplay.prototype.beginGeometry = function beginGeometry(geometry, feature) {\n    this.beginGeometryInstruction1_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0];\n    this.instructions.push(this.beginGeometryInstruction1_);\n    this.beginGeometryInstruction2_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0];\n    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n  };\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  CanvasReplay.prototype.finish = function finish() {};\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n  CanvasReplay.prototype.fill_ = function fill_(context) {\n    if (this.alignFill_) {\n      var origin = applyTransform(this.renderedTransform_, [0, 0]);\n      var repeatSize = 512 * this.pixelRatio;\n      context.translate(origin[0] % repeatSize, origin[1] % repeatSize);\n      context.rotate(this.viewRotation_);\n    }\n    context.fill();\n    if (this.alignFill_) {\n      context.setTransform.apply(context, resetTransform);\n    }\n  };\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {Array<*>} instruction Instruction.\n   */\n  CanvasReplay.prototype.setStrokeStyle_ = function setStrokeStyle_(context, instruction) {\n    context.strokeStyle = /** @type {import(\"../../colorlike.js\").ColorLike} */instruction[1];\n    context.lineWidth = /** @type {number} */instruction[2];\n    context.lineCap = /** @type {CanvasLineCap} */instruction[3];\n    context.lineJoin = /** @type {CanvasLineJoin} */instruction[4];\n    context.miterLimit = /** @type {number} */instruction[5];\n    if (CANVAS_LINE_DASH) {\n      context.lineDashOffset = /** @type {number} */instruction[7];\n      context.setLineDash( /** @type {Array<number>} */instruction[6]);\n    }\n  };\n\n  /**\n   * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n   * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n   */\n  CanvasReplay.prototype.renderDeclutter_ = function renderDeclutter_(declutterGroup, feature) {\n    if (declutterGroup && declutterGroup.length > 5) {\n      var groupCount = declutterGroup[4];\n      if (groupCount == 1 || groupCount == declutterGroup.length - 5) {\n        /** @type {import(\"../../structs/RBush.js\").Entry} */\n        var box = {\n          minX: /** @type {number} */declutterGroup[0],\n          minY: /** @type {number} */declutterGroup[1],\n          maxX: /** @type {number} */declutterGroup[2],\n          maxY: /** @type {number} */declutterGroup[3],\n          value: feature\n        };\n        if (!this.declutterTree.collides(box)) {\n          this.declutterTree.insert(box);\n          for (var j = 5, jj = declutterGroup.length; j < jj; ++j) {\n            var declutterData = /** @type {Array} */declutterGroup[j];\n            if (declutterData) {\n              if (declutterData.length > 11) {\n                this.replayTextBackground_(declutterData[0], declutterData[13], declutterData[14], declutterData[15], declutterData[16], declutterData[11], declutterData[12]);\n              }\n              drawImage.apply(undefined, declutterData);\n            }\n          }\n        }\n        declutterGroup.length = 5;\n        createOrUpdateEmpty(declutterGroup);\n      }\n    }\n  };\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   * @param {Array<*>} instructions Instructions array.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T|undefined} featureCallback Feature callback.\n   * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  CanvasReplay.prototype.replay_ = function replay_(context, transform, skippedFeaturesHash, instructions, snapToPixel, featureCallback, opt_hitExtent) {\n    /** @type {Array<number>} */\n    var pixelCoordinates;\n    if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n      pixelCoordinates = this.pixelCoordinates_;\n    } else {\n      if (!this.pixelCoordinates_) {\n        this.pixelCoordinates_ = [];\n      }\n      pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);\n      transformSetFromArray(this.renderedTransform_, transform);\n    }\n    var skipFeatures = !isEmpty(skippedFeaturesHash);\n    var i = 0; // instruction index\n    var ii = instructions.length; // end of instructions\n    var d = 0; // data index\n    var dd; // end of per-instruction data\n    var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;\n    var pendingFill = 0;\n    var pendingStroke = 0;\n    var lastFillInstruction = null;\n    var lastStrokeInstruction = null;\n    var coordinateCache = this.coordinateCache_;\n    var viewRotation = this.viewRotation_;\n    var state = /** @type {import(\"../../render.js\").State} */{\n      context: context,\n      pixelRatio: this.pixelRatio,\n      resolution: this.resolution,\n      rotation: viewRotation\n    };\n\n    // When the batch size gets too big, performance decreases. 200 is a good\n    // balance between batch size and number of fill/stroke instructions.\n    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n    var /** @type {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} */feature;\n    var x, y;\n    while (i < ii) {\n      var instruction = instructions[i];\n      var type = /** @type {CanvasInstruction} */instruction[0];\n      switch (type) {\n        case CanvasInstruction.BEGIN_GEOMETRY:\n          feature = /** @type {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} */instruction[1];\n          if (skipFeatures && skippedFeaturesHash[getUid(feature)] || !feature.getGeometry()) {\n            i = /** @type {number} */instruction[2];\n          } else if (opt_hitExtent !== undefined && !intersects(opt_hitExtent, feature.getGeometry().getExtent())) {\n            i = /** @type {number} */instruction[2] + 1;\n          } else {\n            ++i;\n          }\n          break;\n        case CanvasInstruction.BEGIN_PATH:\n          if (pendingFill > batchSize) {\n            this.fill_(context);\n            pendingFill = 0;\n          }\n          if (pendingStroke > batchSize) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          if (!pendingFill && !pendingStroke) {\n            context.beginPath();\n            prevX = prevY = NaN;\n          }\n          ++i;\n          break;\n        case CanvasInstruction.CIRCLE:\n          d = /** @type {number} */instruction[1];\n          var x1 = pixelCoordinates[d];\n          var y1 = pixelCoordinates[d + 1];\n          var x2 = pixelCoordinates[d + 2];\n          var y2 = pixelCoordinates[d + 3];\n          var dx = x2 - x1;\n          var dy = y2 - y1;\n          var r = Math.sqrt(dx * dx + dy * dy);\n          context.moveTo(x1 + r, y1);\n          context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n          ++i;\n          break;\n        case CanvasInstruction.CLOSE_PATH:\n          context.closePath();\n          ++i;\n          break;\n        case CanvasInstruction.CUSTOM:\n          d = /** @type {number} */instruction[1];\n          dd = instruction[2];\n          var geometry = /** @type {import(\"../../geom/SimpleGeometry.js\").default} */instruction[3];\n          var renderer = instruction[4];\n          var fn = instruction.length == 6 ? instruction[5] : undefined;\n          state.geometry = geometry;\n          state.feature = feature;\n          if (!(i in coordinateCache)) {\n            coordinateCache[i] = [];\n          }\n          var coords = coordinateCache[i];\n          if (fn) {\n            fn(pixelCoordinates, d, dd, 2, coords);\n          } else {\n            coords[0] = pixelCoordinates[d];\n            coords[1] = pixelCoordinates[d + 1];\n            coords.length = 2;\n          }\n          renderer(coords, state);\n          ++i;\n          break;\n        case CanvasInstruction.DRAW_IMAGE:\n          d = /** @type {number} */instruction[1];\n          dd = /** @type {number} */instruction[2];\n          image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */\n          instruction[3];\n          // Remaining arguments in DRAW_IMAGE are in alphabetical order\n          anchorX = /** @type {number} */instruction[4];\n          anchorY = /** @type {number} */instruction[5];\n          declutterGroup = featureCallback ? null : /** @type {import(\"../canvas.js\").DeclutterGroup} */instruction[6];\n          var height = /** @type {number} */instruction[7];\n          var opacity = /** @type {number} */instruction[8];\n          var originX = /** @type {number} */instruction[9];\n          var originY = /** @type {number} */instruction[10];\n          var rotateWithView = /** @type {boolean} */instruction[11];\n          var rotation = /** @type {number} */instruction[12];\n          var scale = /** @type {number} */instruction[13];\n          var width = /** @type {number} */instruction[14];\n          var padding = void 0,\n            backgroundFill = void 0,\n            backgroundStroke = void 0;\n          if (instruction.length > 16) {\n            padding = /** @type {Array<number>} */instruction[15];\n            backgroundFill = /** @type {boolean} */instruction[16];\n            backgroundStroke = /** @type {boolean} */instruction[17];\n          } else {\n            padding = defaultPadding;\n            backgroundFill = backgroundStroke = false;\n          }\n          if (rotateWithView) {\n            rotation += viewRotation;\n          }\n          for (; d < dd; d += 2) {\n            this.replayImage_(context, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, backgroundFill ? /** @type {Array<*>} */lastFillInstruction : null, backgroundStroke ? /** @type {Array<*>} */lastStrokeInstruction : null);\n          }\n          this.renderDeclutter_(declutterGroup, feature);\n          ++i;\n          break;\n        case CanvasInstruction.DRAW_CHARS:\n          var begin = /** @type {number} */instruction[1];\n          var end = /** @type {number} */instruction[2];\n          var baseline = /** @type {number} */instruction[3];\n          declutterGroup = featureCallback ? null : /** @type {import(\"../canvas.js\").DeclutterGroup} */instruction[4];\n          var overflow = /** @type {number} */instruction[5];\n          var fillKey = /** @type {string} */instruction[6];\n          var maxAngle = /** @type {number} */instruction[7];\n          var measure = /** @type {function(string):number} */instruction[8];\n          var offsetY = /** @type {number} */instruction[9];\n          var strokeKey = /** @type {string} */instruction[10];\n          var strokeWidth = /** @type {number} */instruction[11];\n          var text = /** @type {string} */instruction[12];\n          var textKey = /** @type {string} */instruction[13];\n          var textScale = /** @type {number} */instruction[14];\n          var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n          var textLength = measure(text);\n          if (overflow || textLength <= pathLength) {\n            /** @type {import(\"./TextReplay.js\").default} */\n            var textReplay = /** @type {?} */this;\n            var textAlign = textReplay.textStates[textKey].textAlign;\n            var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n            var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);\n            if (parts) {\n              var c = void 0,\n                cc = void 0,\n                chars = void 0,\n                label = void 0,\n                part = void 0;\n              if (strokeKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */part[4];\n                  label = textReplay.getImage(chars, textKey, '', strokeKey);\n                  anchorX = /** @type {number} */part[2] + strokeWidth;\n                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;\n                  this.replayImage_(context, /** @type {number} */part[0], /** @type {number} */part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0, /** @type {number} */part[3], textScale, false, label.width, defaultPadding, null, null);\n                }\n              }\n              if (fillKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */part[4];\n                  label = textReplay.getImage(chars, textKey, fillKey, '');\n                  anchorX = /** @type {number} */part[2];\n                  anchorY = baseline * label.height - offsetY;\n                  this.replayImage_(context, /** @type {number} */part[0], /** @type {number} */part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0, /** @type {number} */part[3], textScale, false, label.width, defaultPadding, null, null);\n                }\n              }\n            }\n          }\n          this.renderDeclutter_(declutterGroup, feature);\n          ++i;\n          break;\n        case CanvasInstruction.END_GEOMETRY:\n          if (featureCallback !== undefined) {\n            feature = /** @type {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} */instruction[1];\n            var result = featureCallback(feature);\n            if (result) {\n              return result;\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.FILL:\n          if (batchSize) {\n            pendingFill++;\n          } else {\n            this.fill_(context);\n          }\n          ++i;\n          break;\n        case CanvasInstruction.MOVE_TO_LINE_TO:\n          d = /** @type {number} */instruction[1];\n          dd = /** @type {number} */instruction[2];\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          roundX = x + 0.5 | 0;\n          roundY = y + 0.5 | 0;\n          if (roundX !== prevX || roundY !== prevY) {\n            context.moveTo(x, y);\n            prevX = roundX;\n            prevY = roundY;\n          }\n          for (d += 2; d < dd; d += 2) {\n            x = pixelCoordinates[d];\n            y = pixelCoordinates[d + 1];\n            roundX = x + 0.5 | 0;\n            roundY = y + 0.5 | 0;\n            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n              context.lineTo(x, y);\n              prevX = roundX;\n              prevY = roundY;\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.SET_FILL_STYLE:\n          lastFillInstruction = instruction;\n          this.alignFill_ = instruction[2];\n          if (pendingFill) {\n            this.fill_(context);\n            pendingFill = 0;\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n          }\n          context.fillStyle = /** @type {import(\"../../colorlike.js\").ColorLike} */instruction[1];\n          ++i;\n          break;\n        case CanvasInstruction.SET_STROKE_STYLE:\n          lastStrokeInstruction = instruction;\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          this.setStrokeStyle_(context, /** @type {Array<*>} */instruction);\n          ++i;\n          break;\n        case CanvasInstruction.STROKE:\n          if (batchSize) {\n            pendingStroke++;\n          } else {\n            context.stroke();\n          }\n          ++i;\n          break;\n        default:\n          ++i; // consume the instruction anyway, to avoid an infinite loop\n          break;\n      }\n    }\n    if (pendingFill) {\n      this.fill_(context);\n    }\n    if (pendingStroke) {\n      context.stroke();\n    }\n    return undefined;\n  };\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   */\n  CanvasReplay.prototype.replay = function replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel) {\n    this.viewRotation_ = viewRotation;\n    this.replay_(context, transform, skippedFeaturesHash, this.instructions, snapToPixel, undefined, undefined);\n  };\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T=} opt_featureCallback\n   *     Feature callback.\n   * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  CanvasReplay.prototype.replayHitDetection = function replayHitDetection(context, transform, viewRotation, skippedFeaturesHash, opt_featureCallback, opt_hitExtent) {\n    this.viewRotation_ = viewRotation;\n    return this.replay_(context, transform, skippedFeaturesHash, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);\n  };\n\n  /**\n   * Reverse the hit detection instructions.\n   */\n  CanvasReplay.prototype.reverseHitDetectionInstructions = function reverseHitDetectionInstructions() {\n    var hitDetectionInstructions = this.hitDetectionInstructions;\n    // step 1 - reverse array\n    hitDetectionInstructions.reverse();\n    // step 2 - reverse instructions within geometry blocks\n    var i;\n    var n = hitDetectionInstructions.length;\n    var instruction;\n    var type;\n    var begin = -1;\n    for (i = 0; i < n; ++i) {\n      instruction = hitDetectionInstructions[i];\n      type = /** @type {CanvasInstruction} */instruction[0];\n      if (type == CanvasInstruction.END_GEOMETRY) {\n        begin = i;\n      } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n        instruction[2] = i;\n        reverseSubArray(this.hitDetectionInstructions, begin, i);\n        begin = -1;\n      }\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasReplay.prototype.setFillStrokeStyle = function setFillStrokeStyle(fillStyle, strokeStyle) {\n    var state = this.state;\n    if (fillStyle) {\n      var fillStyleColor = fillStyle.getColor();\n      state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);\n    } else {\n      state.fillStyle = undefined;\n    }\n    if (strokeStyle) {\n      var strokeStyleColor = strokeStyle.getColor();\n      state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);\n      var strokeStyleLineCap = strokeStyle.getLineCap();\n      state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;\n      var strokeStyleLineDash = strokeStyle.getLineDash();\n      state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;\n      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;\n      var strokeStyleLineJoin = strokeStyle.getLineJoin();\n      state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : defaultLineJoin;\n      var strokeStyleWidth = strokeStyle.getWidth();\n      state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;\n      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : defaultMiterLimit;\n      if (state.lineWidth > this.maxLineWidth) {\n        this.maxLineWidth = state.lineWidth;\n        // invalidate the buffered max extent cache\n        this.bufferedMaxExtent_ = null;\n      }\n    } else {\n      state.strokeStyle = undefined;\n      state.lineCap = undefined;\n      state.lineDash = null;\n      state.lineDashOffset = undefined;\n      state.lineJoin = undefined;\n      state.lineWidth = undefined;\n      state.miterLimit = undefined;\n    }\n  };\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n   * @return {Array<*>} Fill instruction.\n   */\n  CanvasReplay.prototype.createFill = function createFill(state, geometry) {\n    var fillStyle = state.fillStyle;\n    /** @type {Array<*>} */\n    var fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n    if (typeof fillStyle !== 'string') {\n      // Fill is a pattern or gradient - align it!\n      fillInstruction.push(true);\n    }\n    return fillInstruction;\n  };\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   */\n  CanvasReplay.prototype.applyStroke = function applyStroke(state) {\n    this.instructions.push(this.createStroke(state));\n  };\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Stroke instruction.\n   */\n  CanvasReplay.prototype.createStroke = function createStroke(state) {\n    return [CanvasInstruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio];\n  };\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasReplay, import(\"../canvas.js\").FillStrokeState, (import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default)):Array<*>} createFill Create fill.\n   * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n   */\n  CanvasReplay.prototype.updateFillStyle = function updateFillStyle(state, createFill, geometry) {\n    var fillStyle = state.fillStyle;\n    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n      if (fillStyle !== undefined) {\n        this.instructions.push(createFill.call(this, state, geometry));\n      }\n      state.currentFillStyle = fillStyle;\n    }\n  };\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasReplay, import(\"../canvas.js\").FillStrokeState)} applyStroke Apply stroke.\n   */\n  CanvasReplay.prototype.updateStrokeStyle = function updateStrokeStyle(state, applyStroke) {\n    var strokeStyle = state.strokeStyle;\n    var lineCap = state.lineCap;\n    var lineDash = state.lineDash;\n    var lineDashOffset = state.lineDashOffset;\n    var lineJoin = state.lineJoin;\n    var lineWidth = state.lineWidth;\n    var miterLimit = state.miterLimit;\n    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {\n      if (strokeStyle !== undefined) {\n        applyStroke.call(this, state);\n      }\n      state.currentStrokeStyle = strokeStyle;\n      state.currentLineCap = lineCap;\n      state.currentLineDash = lineDash;\n      state.currentLineDashOffset = lineDashOffset;\n      state.currentLineJoin = lineJoin;\n      state.currentLineWidth = lineWidth;\n      state.currentMiterLimit = miterLimit;\n    }\n  };\n\n  /**\n   * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n   */\n  CanvasReplay.prototype.endGeometry = function endGeometry(geometry, feature) {\n    this.beginGeometryInstruction1_[2] = this.instructions.length;\n    this.beginGeometryInstruction1_ = null;\n    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n    this.beginGeometryInstruction2_ = null;\n    var endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n    this.instructions.push(endGeometryInstruction);\n    this.hitDetectionInstructions.push(endGeometryInstruction);\n  };\n\n  /**\n   * Get the buffered rendering extent.  Rendering will be clipped to the extent\n   * provided to the constructor.  To account for symbolizers that may intersect\n   * this extent, we calculate a buffered extent (e.g. based on stroke width).\n   * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n   * @protected\n   */\n  CanvasReplay.prototype.getBufferedMaxExtent = function getBufferedMaxExtent() {\n    if (!this.bufferedMaxExtent_) {\n      this.bufferedMaxExtent_ = clone(this.maxExtent);\n      if (this.maxLineWidth > 0) {\n        var width = this.resolution * (this.maxLineWidth + 1) / 2;\n        buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n      }\n    }\n    return this.bufferedMaxExtent_;\n  };\n  return CanvasReplay;\n}(VectorContext);\nexport default CanvasReplay;","map":{"version":3,"names":["getUid","equals","reverseSubArray","asColorLike","buffer","clone","coordinateRelationship","createEmpty","createOrUpdate","createOrUpdateEmpty","extend","extendCoordinate","intersects","Relationship","GeometryType","inflateCoordinates","inflateCoordinatesArray","inflateMultiCoordinatesArray","lineStringLength","drawTextOnPath","transform2D","CANVAS_LINE_DASH","isEmpty","VectorContext","drawImage","resetTransform","defaultPadding","defaultFillStyle","defaultStrokeStyle","defaultMiterLimit","defaultLineWidth","defaultLineJoin","defaultLineDashOffset","defaultLineDash","defaultLineCap","CanvasInstruction","TEXT_ALIGN","create","createTransform","compose","composeTransform","apply","applyTransform","setFromArray","transformSetFromArray","tmpExtent","tmpTransform","CanvasReplay","tolerance","maxExtent","resolution","pixelRatio","overlaps","declutterTree","call","maxLineWidth","alignFill_","beginGeometryInstruction1_","beginGeometryInstruction2_","bufferedMaxExtent_","instructions","coordinates","coordinateCache_","renderedTransform_","hitDetectionInstructions","pixelCoordinates_","state","viewRotation_","replayTextBackground_","context","p1","p2","p3","p4","fillInstruction","strokeInstruction","beginPath","moveTo","lineTo","fill_","setStrokeStyle_","stroke","replayImage_","x","y","image","anchorX","anchorY","declutterGroup","height","opacity","originX","originY","rotation","scale","snapToPixel","width","padding","fillStroke","w","h","boxW","boxH","boxX","boxY","transform","centerX","centerY","canvas","strokePadding","Math","round","declutterArgs","slice","push","applyPixelRatio","dashArray","map","dash","appendFlatCoordinates","flatCoordinates","offset","end","stride","closed","skipFirst","myEnd","length","extent","getBufferedMaxExtent","lastCoord","nextCoord","NaN","skipped","i","lastRel","nextRel","INTERSECTING","drawCustomCoordinates_","ends","replayEnds","ii","replayEnd","drawCustom","geometry","feature","renderer","beginGeometry","type","getType","getStride","replayBegin","replayEndss","MULTI_POLYGON","getOrientedFlatCoordinates","endss","getEndss","myEnds","CUSTOM","POLYGON","MULTI_LINE_STRING","getFlatCoordinates","getEnds","LINE_STRING","MULTI_POINT","POINT","endGeometry","BEGIN_GEOMETRY","finish","origin","repeatSize","translate","rotate","fill","setTransform","instruction","strokeStyle","lineWidth","lineCap","lineJoin","miterLimit","lineDashOffset","setLineDash","renderDeclutter_","groupCount","box","minX","minY","maxX","maxY","value","collides","insert","j","jj","declutterData","undefined","replay_","skippedFeaturesHash","featureCallback","opt_hitExtent","pixelCoordinates","skipFeatures","d","dd","prevX","prevY","roundX","roundY","pendingFill","pendingStroke","lastFillInstruction","lastStrokeInstruction","coordinateCache","viewRotation","batchSize","getGeometry","getExtent","BEGIN_PATH","CIRCLE","x1","y1","x2","y2","dx","dy","r","sqrt","arc","PI","CLOSE_PATH","closePath","fn","coords","DRAW_IMAGE","rotateWithView","backgroundFill","backgroundStroke","DRAW_CHARS","begin","baseline","overflow","fillKey","maxAngle","measure","offsetY","strokeKey","strokeWidth","text","textKey","textScale","pathLength","textLength","textReplay","textAlign","textStates","startM","parts","c","cc","chars","label","part","getImage","END_GEOMETRY","result","FILL","MOVE_TO_LINE_TO","SET_FILL_STYLE","fillStyle","SET_STROKE_STYLE","STROKE","replay","replayHitDetection","opt_featureCallback","reverseHitDetectionInstructions","reverse","n","setFillStrokeStyle","fillStyleColor","getColor","strokeStyleColor","strokeStyleLineCap","getLineCap","strokeStyleLineDash","getLineDash","lineDash","strokeStyleLineDashOffset","getLineDashOffset","strokeStyleLineJoin","getLineJoin","strokeStyleWidth","getWidth","strokeStyleMiterLimit","getMiterLimit","createFill","applyStroke","createStroke","updateFillStyle","currentFillStyle","updateStrokeStyle","currentStrokeStyle","currentLineCap","currentLineDash","currentLineDashOffset","currentLineJoin","currentLineWidth","currentMiterLimit","endGeometryInstruction"],"sources":["../../../../src/ol/render/canvas/Replay.js"],"sourcesContent":["/**\n * @module ol/render/canvas/Replay\n */\nimport {getUid} from '../../util.js';\nimport {equals, reverseSubArray} from '../../array.js';\nimport {asColorLike} from '../../colorlike.js';\nimport {buffer, clone, coordinateRelationship, createEmpty, createOrUpdate,\n  createOrUpdateEmpty, extend, extendCoordinate, intersects} from '../../extent.js';\nimport Relationship from '../../extent/Relationship.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport {inflateCoordinates, inflateCoordinatesArray, inflateMultiCoordinatesArray} from '../../geom/flat/inflate.js';\nimport {lineStringLength} from '../../geom/flat/length.js';\nimport {drawTextOnPath} from '../../geom/flat/textpath.js';\nimport {transform2D} from '../../geom/flat/transform.js';\nimport {CANVAS_LINE_DASH} from '../../has.js';\nimport {isEmpty} from '../../obj.js';\nimport VectorContext from '../VectorContext.js';\nimport {drawImage, resetTransform, defaultPadding, defaultFillStyle, defaultStrokeStyle,\n  defaultMiterLimit, defaultLineWidth, defaultLineJoin, defaultLineDashOffset,\n  defaultLineDash, defaultLineCap} from '../canvas.js';\nimport CanvasInstruction from './Instruction.js';\nimport {TEXT_ALIGN} from '../replay.js';\nimport {\n  create as createTransform,\n  compose as composeTransform,\n  apply as applyTransform,\n  setFromArray as transformSetFromArray\n} from '../../transform.js';\n\n\n/**\n * @type {import(\"../../extent.js\").Extent}\n */\nconst tmpExtent = createEmpty();\n\n\n/**\n * @type {!import(\"../../transform.js\").Transform}\n */\nconst tmpTransform = createTransform();\n\n\nclass CanvasReplay extends VectorContext {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Maximum extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay can have overlapping geometries.\n   * @param {?} declutterTree Declutter tree.\n   */\n  constructor(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {\n    super();\n\n    /**\n     * @type {?}\n     */\n    this.declutterTree = declutterTree;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.tolerance = tolerance;\n\n    /**\n     * @protected\n     * @const\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent = maxExtent;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.overlaps = overlaps;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.pixelRatio = pixelRatio;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.maxLineWidth = 0;\n\n    /**\n     * @protected\n     * @const\n     * @type {number}\n     */\n    this.resolution = resolution;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.alignFill_;\n\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    this.beginGeometryInstruction1_ = null;\n\n    /**\n     * @private\n     * @type {Array<*>}\n     */\n    this.beginGeometryInstruction2_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.bufferedMaxExtent_ = null;\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.instructions = [];\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.coordinates = [];\n\n    /**\n     * @private\n     * @type {!Object<number,import(\"../../coordinate.js\").Coordinate|Array<import(\"../../coordinate.js\").Coordinate>|Array<Array<import(\"../../coordinate.js\").Coordinate>>>}\n     */\n    this.coordinateCache_ = {};\n\n    /**\n     * @private\n     * @type {!import(\"../../transform.js\").Transform}\n     */\n    this.renderedTransform_ = createTransform();\n\n    /**\n     * @protected\n     * @type {Array<*>}\n     */\n    this.hitDetectionInstructions = [];\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.pixelCoordinates_ = null;\n\n    /**\n     * @protected\n     * @type {import(\"../canvas.js\").FillStrokeState}\n     */\n    this.state = /** @type {import(\"../canvas.js\").FillStrokeState} */ ({});\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.viewRotation_ = 0;\n\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../coordinate.js\").Coordinate} p1 1st point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p2 2nd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p3 3rd point of the background box.\n   * @param {import(\"../../coordinate.js\").Coordinate} p4 4th point of the background box.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   */\n  replayTextBackground_(context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {\n    context.beginPath();\n    context.moveTo.apply(context, p1);\n    context.lineTo.apply(context, p2);\n    context.lineTo.apply(context, p3);\n    context.lineTo.apply(context, p4);\n    context.lineTo.apply(context, p1);\n    if (fillInstruction) {\n      this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);\n      this.fill_(context);\n    }\n    if (strokeInstruction) {\n      this.setStrokeStyle_(context, /** @type {Array<*>} */ (strokeInstruction));\n      context.stroke();\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.\n   * @param {number} anchorX Anchor X.\n   * @param {number} anchorY Anchor Y.\n   * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n   * @param {number} height Height.\n   * @param {number} opacity Opacity.\n   * @param {number} originX Origin X.\n   * @param {number} originY Origin Y.\n   * @param {number} rotation Rotation.\n   * @param {number} scale Scale.\n   * @param {boolean} snapToPixel Snap to pixel.\n   * @param {number} width Width.\n   * @param {Array<number>} padding Padding.\n   * @param {Array<*>} fillInstruction Fill instruction.\n   * @param {Array<*>} strokeInstruction Stroke instruction.\n   */\n  replayImage_(\n    context,\n    x,\n    y,\n    image,\n    anchorX,\n    anchorY,\n    declutterGroup,\n    height,\n    opacity,\n    originX,\n    originY,\n    rotation,\n    scale,\n    snapToPixel,\n    width,\n    padding,\n    fillInstruction,\n    strokeInstruction\n  ) {\n    const fillStroke = fillInstruction || strokeInstruction;\n    anchorX *= scale;\n    anchorY *= scale;\n    x -= anchorX;\n    y -= anchorY;\n\n    const w = (width + originX > image.width) ? image.width - originX : width;\n    const h = (height + originY > image.height) ? image.height - originY : height;\n    const boxW = padding[3] + w * scale + padding[1];\n    const boxH = padding[0] + h * scale + padding[2];\n    const boxX = x - padding[3];\n    const boxY = y - padding[0];\n\n    /** @type {import(\"../../coordinate.js\").Coordinate} */\n    let p1;\n    /** @type {import(\"../../coordinate.js\").Coordinate} */\n    let p2;\n    /** @type {import(\"../../coordinate.js\").Coordinate} */\n    let p3;\n    /** @type {import(\"../../coordinate.js\").Coordinate} */\n    let p4;\n    if (fillStroke || rotation !== 0) {\n      p1 = [boxX, boxY];\n      p2 = [boxX + boxW, boxY];\n      p3 = [boxX + boxW, boxY + boxH];\n      p4 = [boxX, boxY + boxH];\n    }\n\n    let transform = null;\n    if (rotation !== 0) {\n      const centerX = x + anchorX;\n      const centerY = y + anchorY;\n      transform = composeTransform(tmpTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);\n\n      createOrUpdateEmpty(tmpExtent);\n      extendCoordinate(tmpExtent, applyTransform(tmpTransform, p1));\n      extendCoordinate(tmpExtent, applyTransform(tmpTransform, p2));\n      extendCoordinate(tmpExtent, applyTransform(tmpTransform, p3));\n      extendCoordinate(tmpExtent, applyTransform(tmpTransform, p4));\n    } else {\n      createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);\n    }\n    const canvas = context.canvas;\n    const strokePadding = strokeInstruction ? (strokeInstruction[2] * scale / 2) : 0;\n    const intersects =\n        tmpExtent[0] - strokePadding <= canvas.width && tmpExtent[2] + strokePadding >= 0 &&\n        tmpExtent[1] - strokePadding <= canvas.height && tmpExtent[3] + strokePadding >= 0;\n\n    if (snapToPixel) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n\n    if (declutterGroup) {\n      if (!intersects && declutterGroup[4] == 1) {\n        return;\n      }\n      extend(declutterGroup, tmpExtent);\n      const declutterArgs = intersects ?\n        [context, transform ? transform.slice(0) : null, opacity, image, originX, originY, w, h, x, y, scale] :\n        null;\n      if (declutterArgs && fillStroke) {\n        declutterArgs.push(fillInstruction, strokeInstruction, p1, p2, p3, p4);\n      }\n      declutterGroup.push(declutterArgs);\n    } else if (intersects) {\n      if (fillStroke) {\n        this.replayTextBackground_(context, p1, p2, p3, p4,\n          /** @type {Array<*>} */ (fillInstruction),\n          /** @type {Array<*>} */ (strokeInstruction));\n      }\n      drawImage(context, transform, opacity, image, originX, originY, w, h, x, y, scale);\n    }\n  }\n\n  /**\n   * @protected\n   * @param {Array<number>} dashArray Dash array.\n   * @return {Array<number>} Dash array with pixel ratio applied\n   */\n  applyPixelRatio(dashArray) {\n    const pixelRatio = this.pixelRatio;\n    return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {\n      return dash * pixelRatio;\n    });\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {number} end End.\n   * @param {number} stride Stride.\n   * @param {boolean} closed Last input coordinate equals first.\n   * @param {boolean} skipFirst Skip first coordinate.\n   * @protected\n   * @return {number} My end.\n   */\n  appendFlatCoordinates(flatCoordinates, offset, end, stride, closed, skipFirst) {\n\n    let myEnd = this.coordinates.length;\n    const extent = this.getBufferedMaxExtent();\n    if (skipFirst) {\n      offset += stride;\n    }\n    const lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n    const nextCoord = [NaN, NaN];\n    let skipped = true;\n\n    let i, lastRel, nextRel;\n    for (i = offset + stride; i < end; i += stride) {\n      nextCoord[0] = flatCoordinates[i];\n      nextCoord[1] = flatCoordinates[i + 1];\n      nextRel = coordinateRelationship(extent, nextCoord);\n      if (nextRel !== lastRel) {\n        if (skipped) {\n          this.coordinates[myEnd++] = lastCoord[0];\n          this.coordinates[myEnd++] = lastCoord[1];\n        }\n        this.coordinates[myEnd++] = nextCoord[0];\n        this.coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else if (nextRel === Relationship.INTERSECTING) {\n        this.coordinates[myEnd++] = nextCoord[0];\n        this.coordinates[myEnd++] = nextCoord[1];\n        skipped = false;\n      } else {\n        skipped = true;\n      }\n      lastCoord[0] = nextCoord[0];\n      lastCoord[1] = nextCoord[1];\n      lastRel = nextRel;\n    }\n\n    // Last coordinate equals first or only one point to append:\n    if ((closed && skipped) || i === offset + stride) {\n      this.coordinates[myEnd++] = lastCoord[0];\n      this.coordinates[myEnd++] = lastCoord[1];\n    }\n    return myEnd;\n  }\n\n  /**\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   * @param {number} offset Offset.\n   * @param {Array<number>} ends Ends.\n   * @param {number} stride Stride.\n   * @param {Array<number>} replayEnds Replay ends.\n   * @return {number} Offset.\n   */\n  drawCustomCoordinates_(flatCoordinates, offset, ends, stride, replayEnds) {\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const replayEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);\n      replayEnds.push(replayEnd);\n      offset = end;\n    }\n    return offset;\n  }\n\n  /**\n   * @inheritDoc.\n   */\n  drawCustom(geometry, feature, renderer) {\n    this.beginGeometry(geometry, feature);\n    const type = geometry.getType();\n    const stride = geometry.getStride();\n    const replayBegin = this.coordinates.length;\n    let flatCoordinates, replayEnd, replayEnds, replayEndss;\n    let offset;\n    if (type == GeometryType.MULTI_POLYGON) {\n      geometry = /** @type {import(\"../../geom/MultiPolygon.js\").default} */ (geometry);\n      flatCoordinates = geometry.getOrientedFlatCoordinates();\n      replayEndss = [];\n      const endss = geometry.getEndss();\n      offset = 0;\n      for (let i = 0, ii = endss.length; i < ii; ++i) {\n        const myEnds = [];\n        offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);\n        replayEndss.push(myEnds);\n      }\n      this.instructions.push([CanvasInstruction.CUSTOM,\n        replayBegin, replayEndss, geometry, renderer, inflateMultiCoordinatesArray]);\n    } else if (type == GeometryType.POLYGON || type == GeometryType.MULTI_LINE_STRING) {\n      replayEnds = [];\n      flatCoordinates = (type == GeometryType.POLYGON) ?\n        /** @type {import(\"../../geom/Polygon.js\").default} */ (geometry).getOrientedFlatCoordinates() :\n        geometry.getFlatCoordinates();\n      offset = this.drawCustomCoordinates_(flatCoordinates, 0,\n        /** @type {import(\"../../geom/Polygon.js\").default|import(\"../../geom/MultiLineString.js\").default} */ (geometry).getEnds(),\n        stride, replayEnds);\n      this.instructions.push([CanvasInstruction.CUSTOM,\n        replayBegin, replayEnds, geometry, renderer, inflateCoordinatesArray]);\n    } else if (type == GeometryType.LINE_STRING || type == GeometryType.MULTI_POINT) {\n      flatCoordinates = geometry.getFlatCoordinates();\n      replayEnd = this.appendFlatCoordinates(\n        flatCoordinates, 0, flatCoordinates.length, stride, false, false);\n      this.instructions.push([CanvasInstruction.CUSTOM,\n        replayBegin, replayEnd, geometry, renderer, inflateCoordinates]);\n    } else if (type == GeometryType.POINT) {\n      flatCoordinates = geometry.getFlatCoordinates();\n      this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);\n      replayEnd = this.coordinates.length;\n      this.instructions.push([CanvasInstruction.CUSTOM,\n        replayBegin, replayEnd, geometry, renderer]);\n    }\n    this.endGeometry(geometry, feature);\n  }\n\n  /**\n   * @protected\n   * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n   */\n  beginGeometry(geometry, feature) {\n    this.beginGeometryInstruction1_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0];\n    this.instructions.push(this.beginGeometryInstruction1_);\n    this.beginGeometryInstruction2_ = [CanvasInstruction.BEGIN_GEOMETRY, feature, 0];\n    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  finish() {}\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n  fill_(context) {\n    if (this.alignFill_) {\n      const origin = applyTransform(this.renderedTransform_, [0, 0]);\n      const repeatSize = 512 * this.pixelRatio;\n      context.translate(origin[0] % repeatSize, origin[1] % repeatSize);\n      context.rotate(this.viewRotation_);\n    }\n    context.fill();\n    if (this.alignFill_) {\n      context.setTransform.apply(context, resetTransform);\n    }\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {Array<*>} instruction Instruction.\n   */\n  setStrokeStyle_(context, instruction) {\n    context.strokeStyle = /** @type {import(\"../../colorlike.js\").ColorLike} */ (instruction[1]);\n    context.lineWidth = /** @type {number} */ (instruction[2]);\n    context.lineCap = /** @type {CanvasLineCap} */ (instruction[3]);\n    context.lineJoin = /** @type {CanvasLineJoin} */ (instruction[4]);\n    context.miterLimit = /** @type {number} */ (instruction[5]);\n    if (CANVAS_LINE_DASH) {\n      context.lineDashOffset = /** @type {number} */ (instruction[7]);\n      context.setLineDash(/** @type {Array<number>} */ (instruction[6]));\n    }\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").DeclutterGroup} declutterGroup Declutter group.\n   * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n   */\n  renderDeclutter_(declutterGroup, feature) {\n    if (declutterGroup && declutterGroup.length > 5) {\n      const groupCount = declutterGroup[4];\n      if (groupCount == 1 || groupCount == declutterGroup.length - 5) {\n        /** @type {import(\"../../structs/RBush.js\").Entry} */\n        const box = {\n          minX: /** @type {number} */ (declutterGroup[0]),\n          minY: /** @type {number} */ (declutterGroup[1]),\n          maxX: /** @type {number} */ (declutterGroup[2]),\n          maxY: /** @type {number} */ (declutterGroup[3]),\n          value: feature\n        };\n        if (!this.declutterTree.collides(box)) {\n          this.declutterTree.insert(box);\n          for (let j = 5, jj = declutterGroup.length; j < jj; ++j) {\n            const declutterData = /** @type {Array} */ (declutterGroup[j]);\n            if (declutterData) {\n              if (declutterData.length > 11) {\n                this.replayTextBackground_(declutterData[0],\n                  declutterData[13], declutterData[14], declutterData[15], declutterData[16],\n                  declutterData[11], declutterData[12]);\n              }\n              drawImage.apply(undefined, declutterData);\n            }\n          }\n        }\n        declutterGroup.length = 5;\n        createOrUpdateEmpty(declutterGroup);\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   * @param {Array<*>} instructions Instructions array.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T|undefined} featureCallback Feature callback.\n   * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  replay_(\n    context,\n    transform,\n    skippedFeaturesHash,\n    instructions,\n    snapToPixel,\n    featureCallback,\n    opt_hitExtent\n  ) {\n    /** @type {Array<number>} */\n    let pixelCoordinates;\n    if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {\n      pixelCoordinates = this.pixelCoordinates_;\n    } else {\n      if (!this.pixelCoordinates_) {\n        this.pixelCoordinates_ = [];\n      }\n      pixelCoordinates = transform2D(\n        this.coordinates, 0, this.coordinates.length, 2,\n        transform, this.pixelCoordinates_);\n      transformSetFromArray(this.renderedTransform_, transform);\n    }\n    const skipFeatures = !isEmpty(skippedFeaturesHash);\n    let i = 0; // instruction index\n    const ii = instructions.length; // end of instructions\n    let d = 0; // data index\n    let dd; // end of per-instruction data\n    let anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;\n    let pendingFill = 0;\n    let pendingStroke = 0;\n    let lastFillInstruction = null;\n    let lastStrokeInstruction = null;\n    const coordinateCache = this.coordinateCache_;\n    const viewRotation = this.viewRotation_;\n\n    const state = /** @type {import(\"../../render.js\").State} */ ({\n      context: context,\n      pixelRatio: this.pixelRatio,\n      resolution: this.resolution,\n      rotation: viewRotation\n    });\n\n    // When the batch size gets too big, performance decreases. 200 is a good\n    // balance between batch size and number of fill/stroke instructions.\n    const batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;\n    let /** @type {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} */ feature;\n    let x, y;\n    while (i < ii) {\n      const instruction = instructions[i];\n      const type = /** @type {CanvasInstruction} */ (instruction[0]);\n      switch (type) {\n        case CanvasInstruction.BEGIN_GEOMETRY:\n          feature = /** @type {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} */ (instruction[1]);\n          if ((skipFeatures && skippedFeaturesHash[getUid(feature)]) || !feature.getGeometry()) {\n            i = /** @type {number} */ (instruction[2]);\n          } else if (opt_hitExtent !== undefined && !intersects(\n            opt_hitExtent, feature.getGeometry().getExtent())) {\n            i = /** @type {number} */ (instruction[2]) + 1;\n          } else {\n            ++i;\n          }\n          break;\n        case CanvasInstruction.BEGIN_PATH:\n          if (pendingFill > batchSize) {\n            this.fill_(context);\n            pendingFill = 0;\n          }\n          if (pendingStroke > batchSize) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          if (!pendingFill && !pendingStroke) {\n            context.beginPath();\n            prevX = prevY = NaN;\n          }\n          ++i;\n          break;\n        case CanvasInstruction.CIRCLE:\n          d = /** @type {number} */ (instruction[1]);\n          const x1 = pixelCoordinates[d];\n          const y1 = pixelCoordinates[d + 1];\n          const x2 = pixelCoordinates[d + 2];\n          const y2 = pixelCoordinates[d + 3];\n          const dx = x2 - x1;\n          const dy = y2 - y1;\n          const r = Math.sqrt(dx * dx + dy * dy);\n          context.moveTo(x1 + r, y1);\n          context.arc(x1, y1, r, 0, 2 * Math.PI, true);\n          ++i;\n          break;\n        case CanvasInstruction.CLOSE_PATH:\n          context.closePath();\n          ++i;\n          break;\n        case CanvasInstruction.CUSTOM:\n          d = /** @type {number} */ (instruction[1]);\n          dd = instruction[2];\n          const geometry = /** @type {import(\"../../geom/SimpleGeometry.js\").default} */ (instruction[3]);\n          const renderer = instruction[4];\n          const fn = instruction.length == 6 ? instruction[5] : undefined;\n          state.geometry = geometry;\n          state.feature = feature;\n          if (!(i in coordinateCache)) {\n            coordinateCache[i] = [];\n          }\n          const coords = coordinateCache[i];\n          if (fn) {\n            fn(pixelCoordinates, d, dd, 2, coords);\n          } else {\n            coords[0] = pixelCoordinates[d];\n            coords[1] = pixelCoordinates[d + 1];\n            coords.length = 2;\n          }\n          renderer(coords, state);\n          ++i;\n          break;\n        case CanvasInstruction.DRAW_IMAGE:\n          d = /** @type {number} */ (instruction[1]);\n          dd = /** @type {number} */ (instruction[2]);\n          image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */\n              (instruction[3]);\n          // Remaining arguments in DRAW_IMAGE are in alphabetical order\n          anchorX = /** @type {number} */ (instruction[4]);\n          anchorY = /** @type {number} */ (instruction[5]);\n          declutterGroup = featureCallback ? null : /** @type {import(\"../canvas.js\").DeclutterGroup} */ (instruction[6]);\n          const height = /** @type {number} */ (instruction[7]);\n          const opacity = /** @type {number} */ (instruction[8]);\n          const originX = /** @type {number} */ (instruction[9]);\n          const originY = /** @type {number} */ (instruction[10]);\n          const rotateWithView = /** @type {boolean} */ (instruction[11]);\n          let rotation = /** @type {number} */ (instruction[12]);\n          const scale = /** @type {number} */ (instruction[13]);\n          const width = /** @type {number} */ (instruction[14]);\n\n          let padding, backgroundFill, backgroundStroke;\n          if (instruction.length > 16) {\n            padding = /** @type {Array<number>} */ (instruction[15]);\n            backgroundFill = /** @type {boolean} */ (instruction[16]);\n            backgroundStroke = /** @type {boolean} */ (instruction[17]);\n          } else {\n            padding = defaultPadding;\n            backgroundFill = backgroundStroke = false;\n          }\n\n          if (rotateWithView) {\n            rotation += viewRotation;\n          }\n          for (; d < dd; d += 2) {\n            this.replayImage_(context,\n              pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY,\n              declutterGroup, height, opacity, originX, originY, rotation, scale,\n              snapToPixel, width, padding,\n              backgroundFill ? /** @type {Array<*>} */ (lastFillInstruction) : null,\n              backgroundStroke ? /** @type {Array<*>} */ (lastStrokeInstruction) : null);\n          }\n          this.renderDeclutter_(declutterGroup, feature);\n          ++i;\n          break;\n        case CanvasInstruction.DRAW_CHARS:\n          const begin = /** @type {number} */ (instruction[1]);\n          const end = /** @type {number} */ (instruction[2]);\n          const baseline = /** @type {number} */ (instruction[3]);\n          declutterGroup = featureCallback ? null : /** @type {import(\"../canvas.js\").DeclutterGroup} */ (instruction[4]);\n          const overflow = /** @type {number} */ (instruction[5]);\n          const fillKey = /** @type {string} */ (instruction[6]);\n          const maxAngle = /** @type {number} */ (instruction[7]);\n          const measure = /** @type {function(string):number} */ (instruction[8]);\n          const offsetY = /** @type {number} */ (instruction[9]);\n          const strokeKey = /** @type {string} */ (instruction[10]);\n          const strokeWidth = /** @type {number} */ (instruction[11]);\n          const text = /** @type {string} */ (instruction[12]);\n          const textKey = /** @type {string} */ (instruction[13]);\n          const textScale = /** @type {number} */ (instruction[14]);\n\n          const pathLength = lineStringLength(pixelCoordinates, begin, end, 2);\n          const textLength = measure(text);\n          if (overflow || textLength <= pathLength) {\n            /** @type {import(\"./TextReplay.js\").default} */\n            const textReplay = /** @type {?} */ (this);\n            const textAlign = textReplay.textStates[textKey].textAlign;\n            const startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];\n            const parts = drawTextOnPath(\n              pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);\n            if (parts) {\n              let c, cc, chars, label, part;\n              if (strokeKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */ (part[4]);\n                  label = textReplay.getImage(chars, textKey, '', strokeKey);\n                  anchorX = /** @type {number} */ (part[2]) + strokeWidth;\n                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;\n                  this.replayImage_(context,\n                    /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label,\n                    anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\n                    /** @type {number} */ (part[3]), textScale, false, label.width,\n                    defaultPadding, null, null);\n                }\n              }\n              if (fillKey) {\n                for (c = 0, cc = parts.length; c < cc; ++c) {\n                  part = parts[c]; // x, y, anchorX, rotation, chunk\n                  chars = /** @type {string} */ (part[4]);\n                  label = textReplay.getImage(chars, textKey, fillKey, '');\n                  anchorX = /** @type {number} */ (part[2]);\n                  anchorY = baseline * label.height - offsetY;\n                  this.replayImage_(context,\n                    /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label,\n                    anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,\n                    /** @type {number} */ (part[3]), textScale, false, label.width,\n                    defaultPadding, null, null);\n                }\n              }\n            }\n          }\n          this.renderDeclutter_(declutterGroup, feature);\n          ++i;\n          break;\n        case CanvasInstruction.END_GEOMETRY:\n          if (featureCallback !== undefined) {\n            feature = /** @type {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} */ (instruction[1]);\n            const result = featureCallback(feature);\n            if (result) {\n              return result;\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.FILL:\n          if (batchSize) {\n            pendingFill++;\n          } else {\n            this.fill_(context);\n          }\n          ++i;\n          break;\n        case CanvasInstruction.MOVE_TO_LINE_TO:\n          d = /** @type {number} */ (instruction[1]);\n          dd = /** @type {number} */ (instruction[2]);\n          x = pixelCoordinates[d];\n          y = pixelCoordinates[d + 1];\n          roundX = (x + 0.5) | 0;\n          roundY = (y + 0.5) | 0;\n          if (roundX !== prevX || roundY !== prevY) {\n            context.moveTo(x, y);\n            prevX = roundX;\n            prevY = roundY;\n          }\n          for (d += 2; d < dd; d += 2) {\n            x = pixelCoordinates[d];\n            y = pixelCoordinates[d + 1];\n            roundX = (x + 0.5) | 0;\n            roundY = (y + 0.5) | 0;\n            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {\n              context.lineTo(x, y);\n              prevX = roundX;\n              prevY = roundY;\n            }\n          }\n          ++i;\n          break;\n        case CanvasInstruction.SET_FILL_STYLE:\n          lastFillInstruction = instruction;\n          this.alignFill_ = instruction[2];\n\n          if (pendingFill) {\n            this.fill_(context);\n            pendingFill = 0;\n            if (pendingStroke) {\n              context.stroke();\n              pendingStroke = 0;\n            }\n          }\n\n          context.fillStyle = /** @type {import(\"../../colorlike.js\").ColorLike} */ (instruction[1]);\n          ++i;\n          break;\n        case CanvasInstruction.SET_STROKE_STYLE:\n          lastStrokeInstruction = instruction;\n          if (pendingStroke) {\n            context.stroke();\n            pendingStroke = 0;\n          }\n          this.setStrokeStyle_(context, /** @type {Array<*>} */ (instruction));\n          ++i;\n          break;\n        case CanvasInstruction.STROKE:\n          if (batchSize) {\n            pendingStroke++;\n          } else {\n            context.stroke();\n          }\n          ++i;\n          break;\n        default:\n          ++i; // consume the instruction anyway, to avoid an infinite loop\n          break;\n      }\n    }\n    if (pendingFill) {\n      this.fill_(context);\n    }\n    if (pendingStroke) {\n      context.stroke();\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n   */\n  replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel) {\n    this.viewRotation_ = viewRotation;\n    this.replay_(context, transform,\n      skippedFeaturesHash, this.instructions, snapToPixel, undefined, undefined);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features\n   *     to skip.\n   * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T=} opt_featureCallback\n   *     Feature callback.\n   * @param {import(\"../../extent.js\").Extent=} opt_hitExtent Only check features that intersect this\n   *     extent.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  replayHitDetection(\n    context,\n    transform,\n    viewRotation,\n    skippedFeaturesHash,\n    opt_featureCallback,\n    opt_hitExtent\n  ) {\n    this.viewRotation_ = viewRotation;\n    return this.replay_(context, transform, skippedFeaturesHash,\n      this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);\n  }\n\n  /**\n   * Reverse the hit detection instructions.\n   */\n  reverseHitDetectionInstructions() {\n    const hitDetectionInstructions = this.hitDetectionInstructions;\n    // step 1 - reverse array\n    hitDetectionInstructions.reverse();\n    // step 2 - reverse instructions within geometry blocks\n    let i;\n    const n = hitDetectionInstructions.length;\n    let instruction;\n    let type;\n    let begin = -1;\n    for (i = 0; i < n; ++i) {\n      instruction = hitDetectionInstructions[i];\n      type = /** @type {CanvasInstruction} */ (instruction[0]);\n      if (type == CanvasInstruction.END_GEOMETRY) {\n        begin = i;\n      } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {\n        instruction[2] = i;\n        reverseSubArray(this.hitDetectionInstructions, begin, i);\n        begin = -1;\n      }\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setFillStrokeStyle(fillStyle, strokeStyle) {\n    const state = this.state;\n    if (fillStyle) {\n      const fillStyleColor = fillStyle.getColor();\n      state.fillStyle = asColorLike(fillStyleColor ?\n        fillStyleColor : defaultFillStyle);\n    } else {\n      state.fillStyle = undefined;\n    }\n    if (strokeStyle) {\n      const strokeStyleColor = strokeStyle.getColor();\n      state.strokeStyle = asColorLike(strokeStyleColor ?\n        strokeStyleColor : defaultStrokeStyle);\n      const strokeStyleLineCap = strokeStyle.getLineCap();\n      state.lineCap = strokeStyleLineCap !== undefined ?\n        strokeStyleLineCap : defaultLineCap;\n      const strokeStyleLineDash = strokeStyle.getLineDash();\n      state.lineDash = strokeStyleLineDash ?\n        strokeStyleLineDash.slice() : defaultLineDash;\n      const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();\n      state.lineDashOffset = strokeStyleLineDashOffset ?\n        strokeStyleLineDashOffset : defaultLineDashOffset;\n      const strokeStyleLineJoin = strokeStyle.getLineJoin();\n      state.lineJoin = strokeStyleLineJoin !== undefined ?\n        strokeStyleLineJoin : defaultLineJoin;\n      const strokeStyleWidth = strokeStyle.getWidth();\n      state.lineWidth = strokeStyleWidth !== undefined ?\n        strokeStyleWidth : defaultLineWidth;\n      const strokeStyleMiterLimit = strokeStyle.getMiterLimit();\n      state.miterLimit = strokeStyleMiterLimit !== undefined ?\n        strokeStyleMiterLimit : defaultMiterLimit;\n\n      if (state.lineWidth > this.maxLineWidth) {\n        this.maxLineWidth = state.lineWidth;\n        // invalidate the buffered max extent cache\n        this.bufferedMaxExtent_ = null;\n      }\n    } else {\n      state.strokeStyle = undefined;\n      state.lineCap = undefined;\n      state.lineDash = null;\n      state.lineDashOffset = undefined;\n      state.lineJoin = undefined;\n      state.lineWidth = undefined;\n      state.miterLimit = undefined;\n    }\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n   * @return {Array<*>} Fill instruction.\n   */\n  createFill(state, geometry) {\n    const fillStyle = state.fillStyle;\n    /** @type {Array<*>} */\n    const fillInstruction = [CanvasInstruction.SET_FILL_STYLE, fillStyle];\n    if (typeof fillStyle !== 'string') {\n      // Fill is a pattern or gradient - align it!\n      fillInstruction.push(true);\n    }\n    return fillInstruction;\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   */\n  applyStroke(state) {\n    this.instructions.push(this.createStroke(state));\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @return {Array<*>} Stroke instruction.\n   */\n  createStroke(state) {\n    return [\n      CanvasInstruction.SET_STROKE_STYLE,\n      state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap,\n      state.lineJoin, state.miterLimit,\n      this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio\n    ];\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasReplay, import(\"../canvas.js\").FillStrokeState, (import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default)):Array<*>} createFill Create fill.\n   * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n   */\n  updateFillStyle(state, createFill, geometry) {\n    const fillStyle = state.fillStyle;\n    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {\n      if (fillStyle !== undefined) {\n        this.instructions.push(createFill.call(this, state, geometry));\n      }\n      state.currentFillStyle = fillStyle;\n    }\n  }\n\n  /**\n   * @param {import(\"../canvas.js\").FillStrokeState} state State.\n   * @param {function(this:CanvasReplay, import(\"../canvas.js\").FillStrokeState)} applyStroke Apply stroke.\n   */\n  updateStrokeStyle(state, applyStroke) {\n    const strokeStyle = state.strokeStyle;\n    const lineCap = state.lineCap;\n    const lineDash = state.lineDash;\n    const lineDashOffset = state.lineDashOffset;\n    const lineJoin = state.lineJoin;\n    const lineWidth = state.lineWidth;\n    const miterLimit = state.miterLimit;\n    if (state.currentStrokeStyle != strokeStyle ||\n        state.currentLineCap != lineCap ||\n        (lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash)) ||\n        state.currentLineDashOffset != lineDashOffset ||\n        state.currentLineJoin != lineJoin ||\n        state.currentLineWidth != lineWidth ||\n        state.currentMiterLimit != miterLimit) {\n      if (strokeStyle !== undefined) {\n        applyStroke.call(this, state);\n      }\n      state.currentStrokeStyle = strokeStyle;\n      state.currentLineCap = lineCap;\n      state.currentLineDash = lineDash;\n      state.currentLineDashOffset = lineDashOffset;\n      state.currentLineJoin = lineJoin;\n      state.currentLineWidth = lineWidth;\n      state.currentMiterLimit = miterLimit;\n    }\n  }\n\n  /**\n   * @param {import(\"../../geom/Geometry.js\").default|import(\"../Feature.js\").default} geometry Geometry.\n   * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n   */\n  endGeometry(geometry, feature) {\n    this.beginGeometryInstruction1_[2] = this.instructions.length;\n    this.beginGeometryInstruction1_ = null;\n    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;\n    this.beginGeometryInstruction2_ = null;\n    const endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];\n    this.instructions.push(endGeometryInstruction);\n    this.hitDetectionInstructions.push(endGeometryInstruction);\n  }\n\n  /**\n   * Get the buffered rendering extent.  Rendering will be clipped to the extent\n   * provided to the constructor.  To account for symbolizers that may intersect\n   * this extent, we calculate a buffered extent (e.g. based on stroke width).\n   * @return {import(\"../../extent.js\").Extent} The buffered rendering extent.\n   * @protected\n   */\n  getBufferedMaxExtent() {\n    if (!this.bufferedMaxExtent_) {\n      this.bufferedMaxExtent_ = clone(this.maxExtent);\n      if (this.maxLineWidth > 0) {\n        const width = this.resolution * (this.maxLineWidth + 1) / 2;\n        buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);\n      }\n    }\n    return this.bufferedMaxExtent_;\n  }\n}\n\n\nexport default CanvasReplay;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}