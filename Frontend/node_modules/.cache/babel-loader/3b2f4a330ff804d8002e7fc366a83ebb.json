{"ast":null,"code":"/**\n * @module ol/style/AtlasManager\n */\nimport { MAX_TEXTURE_SIZE as WEBGL_MAX_TEXTURE_SIZE } from '../webgl.js';\nimport { VOID } from '../functions.js';\nimport Atlas from './Atlas.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [initialSize=256] The size in pixels of the first atlas image.\n * @property {number} [maxSize] The maximum size in pixels of atlas images. Default is\n * `webgl/MAX_TEXTURE_SIZE` or 2048 if WebGL is not supported.\n * @property {number} [space=1] The space in pixels between images.\n */\n\n/**\n * Provides information for an image inside an atlas manager.\n * `offsetX` and `offsetY` is the position of the image inside\n * the atlas image `image` and the position of the hit-detection image\n * inside the hit-detection atlas image `hitImage`.\n * @typedef {Object} AtlasManagerInfo\n * @property {number} offsetX\n * @property {number} offsetY\n * @property {HTMLCanvasElement} image\n * @property {HTMLCanvasElement} hitImage\n */\n\n/**\n * The size in pixels of the first atlas image.\n * @type {number}\n */\nvar INITIAL_ATLAS_SIZE = 256;\n\n/**\n * The maximum size in pixels of atlas images.\n * @type {number}\n */\nvar MAX_ATLAS_SIZE = -1;\n\n/**\n * @classdesc\n * Manages the creation of image atlases.\n *\n * Images added to this manager will be inserted into an atlas, which\n * will be used for rendering.\n * The `size` given in the constructor is the size for the first\n * atlas. After that, when new atlases are created, they will have\n * twice the size as the latest atlas (until `maxSize` is reached).\n *\n * If an application uses many images or very large images, it is recommended\n * to set a higher `size` value to avoid the creation of too many atlases.\n * @api\n */\nvar AtlasManager = function AtlasManager(opt_options) {\n  var options = opt_options || {};\n\n  /**\n   * The size in pixels of the latest atlas image.\n   * @private\n   * @type {number}\n   */\n  this.currentSize_ = options.initialSize !== undefined ? options.initialSize : INITIAL_ATLAS_SIZE;\n\n  /**\n   * The maximum size in pixels of atlas images.\n   * @private\n   * @type {number}\n   */\n  this.maxSize_ = options.maxSize !== undefined ? options.maxSize : MAX_ATLAS_SIZE != -1 ? MAX_ATLAS_SIZE : WEBGL_MAX_TEXTURE_SIZE !== undefined ? WEBGL_MAX_TEXTURE_SIZE : 2048;\n\n  /**\n   * The size in pixels between images.\n   * @private\n   * @type {number}\n   */\n  this.space_ = options.space !== undefined ? options.space : 1;\n\n  /**\n   * @private\n   * @type {Array<import(\"./Atlas.js\").default>}\n   */\n  this.atlases_ = [new Atlas(this.currentSize_, this.space_)];\n\n  /**\n   * The size in pixels of the latest atlas image for hit-detection images.\n   * @private\n   * @type {number}\n   */\n  this.currentHitSize_ = this.currentSize_;\n\n  /**\n   * @private\n   * @type {Array<import(\"./Atlas.js\").default>}\n   */\n  this.hitAtlases_ = [new Atlas(this.currentHitSize_, this.space_)];\n};\n\n/**\n * @param {string} id The identifier of the entry to check.\n * @return {?AtlasManagerInfo} The position and atlas image for the\n *  entry, or `null` if the entry is not part of the atlas manager.\n */\nAtlasManager.prototype.getInfo = function getInfo(id) {\n  /** @type {?import(\"./Atlas.js\").AtlasInfo} */\n  var info = this.getInfo_(this.atlases_, id);\n  if (!info) {\n    return null;\n  }\n  var hitInfo = /** @type {import(\"./Atlas.js\").AtlasInfo} */this.getInfo_(this.hitAtlases_, id);\n  return this.mergeInfos_(info, hitInfo);\n};\n\n/**\n * @private\n * @param {Array<import(\"./Atlas.js\").default>} atlases The atlases to search.\n * @param {string} id The identifier of the entry to check.\n * @return {?import(\"./Atlas.js\").AtlasInfo} The position and atlas image for the entry,\n *  or `null` if the entry is not part of the atlases.\n */\nAtlasManager.prototype.getInfo_ = function getInfo_(atlases, id) {\n  for (var i = 0, ii = atlases.length; i < ii; ++i) {\n    var atlas = atlases[i];\n    var info = atlas.get(id);\n    if (info) {\n      return info;\n    }\n  }\n  return null;\n};\n\n/**\n * @private\n * @param {import(\"./Atlas.js\").AtlasInfo} info The info for the real image.\n * @param {import(\"./Atlas.js\").AtlasInfo} hitInfo The info for the hit-detection\n *  image.\n * @return {?AtlasManagerInfo} The position and atlas image for the\n *  entry, or `null` if the entry is not part of the atlases.\n */\nAtlasManager.prototype.mergeInfos_ = function mergeInfos_(info, hitInfo) {\n  return (/** @type {AtlasManagerInfo} */{\n      offsetX: info.offsetX,\n      offsetY: info.offsetY,\n      image: info.image,\n      hitImage: hitInfo.image\n    }\n  );\n};\n\n/**\n * Add an image to the atlas manager.\n *\n * If an entry for the given id already exists, the entry will\n * be overridden (but the space on the atlas graphic will not be freed).\n *\n * If `renderHitCallback` is provided, the image (or the hit-detection version\n * of the image) will be rendered into a separate hit-detection atlas image.\n *\n * @param {string} id The identifier of the entry to add.\n * @param {number} width The width.\n * @param {number} height The height.\n * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n *  Called to render the new image onto an atlas image.\n * @param {function(CanvasRenderingContext2D, number, number)=} opt_renderHitCallback Called to render a hit-detection image onto a hit\n *  detection atlas image.\n * @param {Object=} opt_this Value to use as `this` when executing\n *  `renderCallback` and `renderHitCallback`.\n * @return {?AtlasManagerInfo}The position and atlas image for the\n *  entry, or `null` if the image is too big.\n */\nAtlasManager.prototype.add = function add(id, width, height, renderCallback, opt_renderHitCallback, opt_this) {\n  if (width + this.space_ > this.maxSize_ || height + this.space_ > this.maxSize_) {\n    return null;\n  }\n\n  /** @type {?import(\"./Atlas.js\").AtlasInfo} */\n  var info = this.add_(false, id, width, height, renderCallback, opt_this);\n  if (!info) {\n    return null;\n  }\n\n  // even if no hit-detection entry is requested, we insert a fake entry into\n  // the hit-detection atlas, to make sure that the offset is the same for\n  // the original image and the hit-detection image.\n  var renderHitCallback = opt_renderHitCallback !== undefined ? opt_renderHitCallback : VOID;\n  var hitInfo = /** @type {import(\"./Atlas.js\").AtlasInfo} */this.add_(true, id, width, height, renderHitCallback, opt_this);\n  return this.mergeInfos_(info, hitInfo);\n};\n\n/**\n * @private\n * @param {boolean} isHitAtlas If the hit-detection atlases are used.\n * @param {string} id The identifier of the entry to add.\n * @param {number} width The width.\n * @param {number} height The height.\n * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n *  Called to render the new image onto an atlas image.\n * @param {Object=} opt_this Value to use as `this` when executing\n *  `renderCallback` and `renderHitCallback`.\n * @return {?import(\"./Atlas.js\").AtlasInfo}The position and atlas image for the entry,\n *  or `null` if the image is too big.\n */\nAtlasManager.prototype.add_ = function add_(isHitAtlas, id, width, height, renderCallback, opt_this) {\n  var atlases = isHitAtlas ? this.hitAtlases_ : this.atlases_;\n  var atlas, info, i, ii;\n  for (i = 0, ii = atlases.length; i < ii; ++i) {\n    atlas = atlases[i];\n    info = atlas.add(id, width, height, renderCallback, opt_this);\n    if (info) {\n      return info;\n    } else if (!info && i === ii - 1) {\n      // the entry could not be added to one of the existing atlases,\n      // create a new atlas that is twice as big and try to add to this one.\n      var size = void 0;\n      if (isHitAtlas) {\n        size = Math.min(this.currentHitSize_ * 2, this.maxSize_);\n        this.currentHitSize_ = size;\n      } else {\n        size = Math.min(this.currentSize_ * 2, this.maxSize_);\n        this.currentSize_ = size;\n      }\n      atlas = new Atlas(size, this.space_);\n      atlases.push(atlas);\n      // run the loop another time\n      ++ii;\n    }\n  }\n  return null;\n};\nexport default AtlasManager;","map":{"version":3,"names":["MAX_TEXTURE_SIZE","WEBGL_MAX_TEXTURE_SIZE","VOID","Atlas","INITIAL_ATLAS_SIZE","MAX_ATLAS_SIZE","AtlasManager","opt_options","options","currentSize_","initialSize","undefined","maxSize_","maxSize","space_","space","atlases_","currentHitSize_","hitAtlases_","prototype","getInfo","id","info","getInfo_","hitInfo","mergeInfos_","atlases","i","ii","length","atlas","get","offsetX","offsetY","image","hitImage","add","width","height","renderCallback","opt_renderHitCallback","opt_this","add_","renderHitCallback","isHitAtlas","size","Math","min","push"],"sources":["../../../src/ol/style/AtlasManager.js"],"sourcesContent":["/**\n * @module ol/style/AtlasManager\n */\nimport {MAX_TEXTURE_SIZE as WEBGL_MAX_TEXTURE_SIZE} from '../webgl.js';\nimport {VOID} from '../functions.js';\nimport Atlas from './Atlas.js';\n\n\n/**\n * @typedef {Object} Options\n * @property {number} [initialSize=256] The size in pixels of the first atlas image.\n * @property {number} [maxSize] The maximum size in pixels of atlas images. Default is\n * `webgl/MAX_TEXTURE_SIZE` or 2048 if WebGL is not supported.\n * @property {number} [space=1] The space in pixels between images.\n */\n\n\n/**\n * Provides information for an image inside an atlas manager.\n * `offsetX` and `offsetY` is the position of the image inside\n * the atlas image `image` and the position of the hit-detection image\n * inside the hit-detection atlas image `hitImage`.\n * @typedef {Object} AtlasManagerInfo\n * @property {number} offsetX\n * @property {number} offsetY\n * @property {HTMLCanvasElement} image\n * @property {HTMLCanvasElement} hitImage\n */\n\n\n/**\n * The size in pixels of the first atlas image.\n * @type {number}\n */\nconst INITIAL_ATLAS_SIZE = 256;\n\n/**\n * The maximum size in pixels of atlas images.\n * @type {number}\n */\nconst MAX_ATLAS_SIZE = -1;\n\n\n/**\n * @classdesc\n * Manages the creation of image atlases.\n *\n * Images added to this manager will be inserted into an atlas, which\n * will be used for rendering.\n * The `size` given in the constructor is the size for the first\n * atlas. After that, when new atlases are created, they will have\n * twice the size as the latest atlas (until `maxSize` is reached).\n *\n * If an application uses many images or very large images, it is recommended\n * to set a higher `size` value to avoid the creation of too many atlases.\n * @api\n */\nclass AtlasManager {\n  /**\n   * @param {Options=} opt_options Options.\n   */\n  constructor(opt_options) {\n\n    const options = opt_options || {};\n\n    /**\n     * The size in pixels of the latest atlas image.\n     * @private\n     * @type {number}\n     */\n    this.currentSize_ = options.initialSize !== undefined ?\n      options.initialSize : INITIAL_ATLAS_SIZE;\n\n    /**\n     * The maximum size in pixels of atlas images.\n     * @private\n     * @type {number}\n     */\n    this.maxSize_ = options.maxSize !== undefined ?\n      options.maxSize : MAX_ATLAS_SIZE != -1 ?\n        MAX_ATLAS_SIZE : WEBGL_MAX_TEXTURE_SIZE !== undefined ?\n          WEBGL_MAX_TEXTURE_SIZE : 2048;\n\n    /**\n     * The size in pixels between images.\n     * @private\n     * @type {number}\n     */\n    this.space_ = options.space !== undefined ? options.space : 1;\n\n    /**\n     * @private\n     * @type {Array<import(\"./Atlas.js\").default>}\n     */\n    this.atlases_ = [new Atlas(this.currentSize_, this.space_)];\n\n    /**\n     * The size in pixels of the latest atlas image for hit-detection images.\n     * @private\n     * @type {number}\n     */\n    this.currentHitSize_ = this.currentSize_;\n\n    /**\n     * @private\n     * @type {Array<import(\"./Atlas.js\").default>}\n     */\n    this.hitAtlases_ = [new Atlas(this.currentHitSize_, this.space_)];\n  }\n\n  /**\n   * @param {string} id The identifier of the entry to check.\n   * @return {?AtlasManagerInfo} The position and atlas image for the\n   *    entry, or `null` if the entry is not part of the atlas manager.\n   */\n  getInfo(id) {\n    /** @type {?import(\"./Atlas.js\").AtlasInfo} */\n    const info = this.getInfo_(this.atlases_, id);\n\n    if (!info) {\n      return null;\n    }\n    const hitInfo = /** @type {import(\"./Atlas.js\").AtlasInfo} */ (this.getInfo_(this.hitAtlases_, id));\n\n    return this.mergeInfos_(info, hitInfo);\n  }\n\n  /**\n   * @private\n   * @param {Array<import(\"./Atlas.js\").default>} atlases The atlases to search.\n   * @param {string} id The identifier of the entry to check.\n   * @return {?import(\"./Atlas.js\").AtlasInfo} The position and atlas image for the entry,\n   *    or `null` if the entry is not part of the atlases.\n   */\n  getInfo_(atlases, id) {\n    for (let i = 0, ii = atlases.length; i < ii; ++i) {\n      const atlas = atlases[i];\n      const info = atlas.get(id);\n      if (info) {\n        return info;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @private\n   * @param {import(\"./Atlas.js\").AtlasInfo} info The info for the real image.\n   * @param {import(\"./Atlas.js\").AtlasInfo} hitInfo The info for the hit-detection\n   *    image.\n   * @return {?AtlasManagerInfo} The position and atlas image for the\n   *    entry, or `null` if the entry is not part of the atlases.\n   */\n  mergeInfos_(info, hitInfo) {\n    return (\n      /** @type {AtlasManagerInfo} */ ({\n        offsetX: info.offsetX,\n        offsetY: info.offsetY,\n        image: info.image,\n        hitImage: hitInfo.image\n      })\n    );\n  }\n\n  /**\n   * Add an image to the atlas manager.\n   *\n   * If an entry for the given id already exists, the entry will\n   * be overridden (but the space on the atlas graphic will not be freed).\n   *\n   * If `renderHitCallback` is provided, the image (or the hit-detection version\n   * of the image) will be rendered into a separate hit-detection atlas image.\n   *\n   * @param {string} id The identifier of the entry to add.\n   * @param {number} width The width.\n   * @param {number} height The height.\n   * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n   *    Called to render the new image onto an atlas image.\n   * @param {function(CanvasRenderingContext2D, number, number)=} opt_renderHitCallback Called to render a hit-detection image onto a hit\n   *    detection atlas image.\n   * @param {Object=} opt_this Value to use as `this` when executing\n   *    `renderCallback` and `renderHitCallback`.\n   * @return {?AtlasManagerInfo}  The position and atlas image for the\n   *    entry, or `null` if the image is too big.\n   */\n  add(id, width, height, renderCallback, opt_renderHitCallback, opt_this) {\n    if (width + this.space_ > this.maxSize_ ||\n        height + this.space_ > this.maxSize_) {\n      return null;\n    }\n\n    /** @type {?import(\"./Atlas.js\").AtlasInfo} */\n    const info = this.add_(false, id, width, height, renderCallback, opt_this);\n    if (!info) {\n      return null;\n    }\n\n    // even if no hit-detection entry is requested, we insert a fake entry into\n    // the hit-detection atlas, to make sure that the offset is the same for\n    // the original image and the hit-detection image.\n    const renderHitCallback = opt_renderHitCallback !== undefined ?\n      opt_renderHitCallback : VOID;\n\n    const hitInfo = /** @type {import(\"./Atlas.js\").AtlasInfo} */ (this.add_(true,\n      id, width, height, renderHitCallback, opt_this));\n\n    return this.mergeInfos_(info, hitInfo);\n  }\n\n  /**\n   * @private\n   * @param {boolean} isHitAtlas If the hit-detection atlases are used.\n   * @param {string} id The identifier of the entry to add.\n   * @param {number} width The width.\n   * @param {number} height The height.\n   * @param {function(CanvasRenderingContext2D, number, number)} renderCallback\n   *    Called to render the new image onto an atlas image.\n   * @param {Object=} opt_this Value to use as `this` when executing\n   *    `renderCallback` and `renderHitCallback`.\n   * @return {?import(\"./Atlas.js\").AtlasInfo}  The position and atlas image for the entry,\n   *    or `null` if the image is too big.\n   */\n  add_(isHitAtlas, id, width, height, renderCallback, opt_this) {\n    const atlases = (isHitAtlas) ? this.hitAtlases_ : this.atlases_;\n    let atlas, info, i, ii;\n    for (i = 0, ii = atlases.length; i < ii; ++i) {\n      atlas = atlases[i];\n      info = atlas.add(id, width, height, renderCallback, opt_this);\n      if (info) {\n        return info;\n      } else if (!info && i === ii - 1) {\n        // the entry could not be added to one of the existing atlases,\n        // create a new atlas that is twice as big and try to add to this one.\n        let size;\n        if (isHitAtlas) {\n          size = Math.min(this.currentHitSize_ * 2, this.maxSize_);\n          this.currentHitSize_ = size;\n        } else {\n          size = Math.min(this.currentSize_ * 2, this.maxSize_);\n          this.currentSize_ = size;\n        }\n        atlas = new Atlas(size, this.space_);\n        atlases.push(atlas);\n        // run the loop another time\n        ++ii;\n      }\n    }\n    return null;\n  }\n}\n\nexport default AtlasManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}