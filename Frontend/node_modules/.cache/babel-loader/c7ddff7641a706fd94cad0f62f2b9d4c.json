{"ast":null,"code":"/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\nimport { squaredSegmentDistance, squaredDistance } from '../../math.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>=} opt_simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\nexport function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {\n  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ? opt_simplifiedFlatCoordinates : [];\n  if (!highQuality) {\n    end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n  simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);\n  return simplifiedFlatCoordinates;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  var n = (end - offset) / stride;\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  /** @type {Array<number>} */\n  var markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array<number>} */\n  var stack = [offset, end - stride];\n  var index = 0;\n  while (stack.length > 0) {\n    var last = stack.pop();\n    var first = stack.pop();\n    var maxSquaredDistance = 0;\n    var x1 = flatCoordinates[first];\n    var y1 = flatCoordinates[first + 1];\n    var x2 = flatCoordinates[last];\n    var y2 = flatCoordinates[last + 1];\n    for (var i = first + stride; i < last; i += stride) {\n      var x = flatCoordinates[i];\n      var y = flatCoordinates[i + 1];\n      var squaredDistance = squaredSegmentDistance(x, y, x1, y1, x2, y2);\n      if (squaredDistance > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance;\n      }\n    }\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n  for (var i$1 = 0; i$1 < n; ++i$1) {\n    if (markers[i$1]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i$1 * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i$1 * stride + 1];\n    }\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    var simplifiedEnds = [];\n    simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  // copy first point\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  var x2 = x1;\n  var y2 = y1;\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\nexport function snap(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n}\n\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  }\n  // snap the first coordinate (P1)\n  var x1 = snap(flatCoordinates[offset], tolerance);\n  var y1 = snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride;\n  // add the first coordinate to the output\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n  var x2, y2;\n  do {\n    x2 = snap(flatCoordinates[offset], tolerance);\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n  while (offset < end) {\n    // snap the next coordinate (P3)\n    var x3 = snap(flatCoordinates[offset], tolerance);\n    var y3 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // skip P3 if it is equal to P2\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    }\n    // calculate the delta between P1 and P2\n    var dx1 = x2 - x1;\n    var dy1 = y2 - y1;\n    // calculate the delta between P3 and P1\n    var dx2 = x3 - x1;\n    var dy2 = y3 - y1;\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    }\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  }\n  // add the last point (P2)\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    var simplifiedEnds = [];\n    simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}","map":{"version":3,"names":["squaredSegmentDistance","squaredDistance","simplifyLineString","flatCoordinates","offset","end","stride","squaredTolerance","highQuality","opt_simplifiedFlatCoordinates","simplifiedFlatCoordinates","undefined","radialDistance","length","douglasPeucker","simplifiedOffset","n","markers","Array","stack","index","last","pop","first","maxSquaredDistance","x1","y1","x2","y2","i","x","y","push","i$1","douglasPeuckerArray","ends","simplifiedEnds","ii","douglasPeuckerMultiArray","endss","simplifiedEndss","snap","value","tolerance","Math","round","quantize","x3","y3","dx1","dy1","dx2","dy2","quantizeArray","quantizeMultiArray"],"sources":["../../../../src/ol/geom/flat/simplify.js"],"sourcesContent":["/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\nimport {squaredSegmentDistance, squaredDistance} from '../../math.js';\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>=} opt_simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\nexport function simplifyLineString(flatCoordinates, offset, end,\n  stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {\n  const simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ?\n    opt_simplifiedFlatCoordinates : [];\n  if (!highQuality) {\n    end = radialDistance(flatCoordinates, offset, end,\n      stride, squaredTolerance,\n      simplifiedFlatCoordinates, 0);\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n  simplifiedFlatCoordinates.length = douglasPeucker(\n    flatCoordinates, offset, end, stride, squaredTolerance,\n    simplifiedFlatCoordinates, 0);\n  return simplifiedFlatCoordinates;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function douglasPeucker(flatCoordinates, offset, end,\n  stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  const n = (end - offset) / stride;\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  /** @type {Array<number>} */\n  const markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array<number>} */\n  const stack = [offset, end - stride];\n  let index = 0;\n  while (stack.length > 0) {\n    const last = stack.pop();\n    const first = stack.pop();\n    let maxSquaredDistance = 0;\n    const x1 = flatCoordinates[first];\n    const y1 = flatCoordinates[first + 1];\n    const x2 = flatCoordinates[last];\n    const y2 = flatCoordinates[last + 1];\n    for (let i = first + stride; i < last; i += stride) {\n      const x = flatCoordinates[i];\n      const y = flatCoordinates[i + 1];\n      const squaredDistance = squaredSegmentDistance(\n        x, y, x1, y1, x2, y2);\n      if (squaredDistance > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance;\n      }\n    }\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n  for (let i = 0; i < n; ++i) {\n    if (markers[i]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + i * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + i * stride + 1];\n    }\n  }\n  return simplifiedOffset;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerArray(flatCoordinates, offset,\n  ends, stride, squaredTolerance, simplifiedFlatCoordinates,\n  simplifiedOffset, simplifiedEnds) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = douglasPeucker(\n      flatCoordinates, offset, end, stride, squaredTolerance,\n      simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerMultiArray(\n  flatCoordinates, offset, endss, stride, squaredTolerance,\n  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    const simplifiedEnds = [];\n    simplifiedOffset = douglasPeuckerArray(\n      flatCoordinates, offset, ends, stride, squaredTolerance,\n      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function radialDistance(flatCoordinates, offset, end,\n  stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  // copy first point\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  let x2 = x1;\n  let y2 = y1;\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n  return simplifiedOffset;\n}\n\n\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\nexport function snap(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n}\n\n\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function quantize(flatCoordinates, offset, end, stride,\n  tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  }\n  // snap the first coordinate (P1)\n  let x1 = snap(flatCoordinates[offset], tolerance);\n  let y1 = snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride;\n  // add the first coordinate to the output\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n  let x2, y2;\n  do {\n    x2 = snap(flatCoordinates[offset], tolerance);\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n  while (offset < end) {\n    // snap the next coordinate (P3)\n    const x3 = snap(flatCoordinates[offset], tolerance);\n    const y3 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // skip P3 if it is equal to P2\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    }\n    // calculate the delta between P1 and P2\n    const dx1 = x2 - x1;\n    const dy1 = y2 - y1;\n    // calculate the delta between P3 and P1\n    const dx2 = x3 - x1;\n    const dy2 = y3 - y1;\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n    if ((dx1 * dy2 == dy1 * dx2) &&\n        ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\n        ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    }\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  }\n  // add the last point (P2)\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function quantizeArray(\n  flatCoordinates, offset, ends, stride,\n  tolerance,\n  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = quantize(\n      flatCoordinates, offset, end, stride,\n      tolerance,\n      simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function quantizeMultiArray(\n  flatCoordinates, offset, endss, stride,\n  tolerance,\n  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    const simplifiedEnds = [];\n    simplifiedOffset = quantizeArray(\n      flatCoordinates, offset, ends, stride,\n      tolerance,\n      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}