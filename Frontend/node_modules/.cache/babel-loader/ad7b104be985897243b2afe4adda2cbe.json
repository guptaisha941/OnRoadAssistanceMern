{"ast":null,"code":"/**\n * @module ol/geom/Geometry\n */\nimport { abstract } from '../util.js';\nimport BaseObject from '../Object.js';\nimport { createEmpty, getHeight, returnOrUpdate } from '../extent.js';\nimport { transform2D } from './flat/transform.js';\nimport { get as getProjection, getTransform } from '../proj.js';\nimport Units from '../proj/Units.js';\nimport { create as createTransform, compose as composeTransform } from '../transform.js';\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nvar tmpTransform = createTransform();\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for vector geometries.\n *\n * To get notified of changes to the geometry, register a listener for the\n * generic `change` event on your geometry instance.\n *\n * @abstract\n * @api\n */\nvar Geometry = /*@__PURE__*/function (BaseObject) {\n  function Geometry() {\n    BaseObject.call(this);\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.extentRevision_ = -1;\n\n    /**\n     * @protected\n     * @type {Object<string, Geometry>}\n     */\n    this.simplifiedGeometryCache = {};\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.simplifiedGeometryRevision = 0;\n  }\n  if (BaseObject) Geometry.__proto__ = BaseObject;\n  Geometry.prototype = Object.create(BaseObject && BaseObject.prototype);\n  Geometry.prototype.constructor = Geometry;\n\n  /**\n   * Make a complete copy of the geometry.\n   * @abstract\n   * @return {!Geometry} Clone.\n   */\n  Geometry.prototype.clone = function clone() {\n    return abstract();\n  };\n\n  /**\n   * @abstract\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  Geometry.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    return abstract();\n  };\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  Geometry.prototype.containsXY = function containsXY(x, y) {\n    return false;\n  };\n\n  /**\n   * Return the closest point of the geometry to the passed point as\n   * {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} point Point.\n   * @param {import(\"../coordinate.js\").Coordinate=} opt_closestPoint Closest point.\n   * @return {import(\"../coordinate.js\").Coordinate} Closest point.\n   * @api\n   */\n  Geometry.prototype.getClosestPoint = function getClosestPoint(point, opt_closestPoint) {\n    var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];\n    this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n    return closestPoint;\n  };\n\n  /**\n   * Returns true if this geometry includes the specified coordinate. If the\n   * coordinate is on the boundary of the geometry, returns false.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {boolean} Contains coordinate.\n   * @api\n   */\n  Geometry.prototype.intersectsCoordinate = function intersectsCoordinate(coordinate) {\n    return this.containsXY(coordinate[0], coordinate[1]);\n  };\n\n  /**\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  Geometry.prototype.computeExtent = function computeExtent(extent) {\n    return abstract();\n  };\n\n  /**\n   * Get the extent of the geometry.\n   * @param {import(\"../extent.js\").Extent=} opt_extent Extent.\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  Geometry.prototype.getExtent = function getExtent(opt_extent) {\n    if (this.extentRevision_ != this.getRevision()) {\n      this.extent_ = this.computeExtent(this.extent_);\n      this.extentRevision_ = this.getRevision();\n    }\n    return returnOrUpdate(this.extent_, opt_extent);\n  };\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} angle Rotation angle in radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  Geometry.prototype.rotate = function rotate(angle, anchor) {\n    abstract();\n  };\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number=} opt_sy The scaling factor in the y-direction (defaults to\n   *     sx).\n   * @param {import(\"../coordinate.js\").Coordinate=} opt_anchor The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  Geometry.prototype.scale = function scale(sx, opt_sy, opt_anchor) {\n    abstract();\n  };\n\n  /**\n   * Create a simplified version of this geometry.  For linestrings, this uses\n   * the the {@link\n   * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n   * Douglas Peucker} algorithm.  For polygons, a quantization-based\n   * simplification is used to preserve topology.\n   * @param {number} tolerance The tolerance distance for simplification.\n   * @return {Geometry} A new, simplified version of the original geometry.\n   * @api\n   */\n  Geometry.prototype.simplify = function simplify(tolerance) {\n    return this.getSimplifiedGeometry(tolerance * tolerance);\n  };\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker\n   * algorithm.\n   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Geometry} Simplified geometry.\n   */\n  Geometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry(squaredTolerance) {\n    return abstract();\n  };\n\n  /**\n   * Get the type of this geometry.\n   * @abstract\n   * @return {import(\"./GeometryType.js\").default} Geometry type.\n   */\n  Geometry.prototype.getType = function getType() {\n    return abstract();\n  };\n\n  /**\n   * Apply a transform function to each coordinate of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @abstract\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform.\n   */\n  Geometry.prototype.applyTransform = function applyTransform(transformFn) {\n    abstract();\n  };\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   */\n  Geometry.prototype.intersectsExtent = function intersectsExtent(extent) {\n    return abstract();\n  };\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @abstract\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  Geometry.prototype.translate = function translate(deltaX, deltaY) {\n    abstract();\n  };\n\n  /**\n   * Transform each coordinate of the geometry from one coordinate reference\n   * system to another. The geometry is modified in place.\n   * For example, a line will be transformed to a line and a circle to a circle.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @return {Geometry} This geometry.  Note that original geometry is\n   *     modified in place.\n   * @api\n   */\n  Geometry.prototype.transform = function transform(source, destination) {\n    /** @type {import(\"../proj/Projection.js\").default} */\n    var sourceProj = getProjection(source);\n    var transformFn = sourceProj.getUnits() == Units.TILE_PIXELS ? function (inCoordinates, outCoordinates, stride) {\n      var pixelExtent = sourceProj.getExtent();\n      var projectedExtent = sourceProj.getWorldExtent();\n      var scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n      composeTransform(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);\n      transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);\n      return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);\n    } : getTransform(sourceProj, destination);\n    this.applyTransform(transformFn);\n    return this;\n  };\n  return Geometry;\n}(BaseObject);\nexport default Geometry;","map":{"version":3,"names":["abstract","BaseObject","createEmpty","getHeight","returnOrUpdate","transform2D","get","getProjection","getTransform","Units","create","createTransform","compose","composeTransform","tmpTransform","Geometry","call","extent_","extentRevision_","simplifiedGeometryCache","simplifiedGeometryMaxMinSquaredTolerance","simplifiedGeometryRevision","clone","closestPointXY","x","y","closestPoint","minSquaredDistance","containsXY","getClosestPoint","point","opt_closestPoint","NaN","Infinity","intersectsCoordinate","coordinate","computeExtent","extent","getExtent","opt_extent","getRevision","rotate","angle","anchor","scale","sx","opt_sy","opt_anchor","simplify","tolerance","getSimplifiedGeometry","squaredTolerance","getType","applyTransform","transformFn","intersectsExtent","translate","deltaX","deltaY","transform","source","destination","sourceProj","getUnits","TILE_PIXELS","inCoordinates","outCoordinates","stride","pixelExtent","projectedExtent","getWorldExtent","length"],"sources":["../../../src/ol/geom/Geometry.js"],"sourcesContent":["/**\n * @module ol/geom/Geometry\n */\nimport {abstract} from '../util.js';\nimport BaseObject from '../Object.js';\nimport {createEmpty, getHeight, returnOrUpdate} from '../extent.js';\nimport {transform2D} from './flat/transform.js';\nimport {get as getProjection, getTransform} from '../proj.js';\nimport Units from '../proj/Units.js';\nimport {create as createTransform, compose as composeTransform} from '../transform.js';\n\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nconst tmpTransform = createTransform();\n\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for vector geometries.\n *\n * To get notified of changes to the geometry, register a listener for the\n * generic `change` event on your geometry instance.\n *\n * @abstract\n * @api\n */\nclass Geometry extends BaseObject {\n  constructor() {\n\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.extentRevision_ = -1;\n\n    /**\n     * @protected\n     * @type {Object<string, Geometry>}\n     */\n    this.simplifiedGeometryCache = {};\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.simplifiedGeometryRevision = 0;\n\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @abstract\n   * @return {!Geometry} Clone.\n   */\n  clone() {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    return abstract();\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    return false;\n  }\n\n  /**\n   * Return the closest point of the geometry to the passed point as\n   * {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} point Point.\n   * @param {import(\"../coordinate.js\").Coordinate=} opt_closestPoint Closest point.\n   * @return {import(\"../coordinate.js\").Coordinate} Closest point.\n   * @api\n   */\n  getClosestPoint(point, opt_closestPoint) {\n    const closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];\n    this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n    return closestPoint;\n  }\n\n  /**\n   * Returns true if this geometry includes the specified coordinate. If the\n   * coordinate is on the boundary of the geometry, returns false.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {boolean} Contains coordinate.\n   * @api\n   */\n  intersectsCoordinate(coordinate) {\n    return this.containsXY(coordinate[0], coordinate[1]);\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    return abstract();\n  }\n\n  /**\n   * Get the extent of the geometry.\n   * @param {import(\"../extent.js\").Extent=} opt_extent Extent.\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  getExtent(opt_extent) {\n    if (this.extentRevision_ != this.getRevision()) {\n      this.extent_ = this.computeExtent(this.extent_);\n      this.extentRevision_ = this.getRevision();\n    }\n    return returnOrUpdate(this.extent_, opt_extent);\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} angle Rotation angle in radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    abstract();\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number=} opt_sy The scaling factor in the y-direction (defaults to\n   *     sx).\n   * @param {import(\"../coordinate.js\").Coordinate=} opt_anchor The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  scale(sx, opt_sy, opt_anchor) {\n    abstract();\n  }\n\n  /**\n   * Create a simplified version of this geometry.  For linestrings, this uses\n   * the the {@link\n   * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n   * Douglas Peucker} algorithm.  For polygons, a quantization-based\n   * simplification is used to preserve topology.\n   * @param {number} tolerance The tolerance distance for simplification.\n   * @return {Geometry} A new, simplified version of the original geometry.\n   * @api\n   */\n  simplify(tolerance) {\n    return this.getSimplifiedGeometry(tolerance * tolerance);\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker\n   * algorithm.\n   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Geometry} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    return abstract();\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @abstract\n   * @return {import(\"./GeometryType.js\").default} Geometry type.\n   */\n  getType() {\n    return abstract();\n  }\n\n  /**\n   * Apply a transform function to each coordinate of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @abstract\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform.\n   */\n  applyTransform(transformFn) {\n    abstract();\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   */\n  intersectsExtent(extent) {\n    return abstract();\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @abstract\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  translate(deltaX, deltaY) {\n    abstract();\n  }\n\n  /**\n   * Transform each coordinate of the geometry from one coordinate reference\n   * system to another. The geometry is modified in place.\n   * For example, a line will be transformed to a line and a circle to a circle.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @return {Geometry} This geometry.  Note that original geometry is\n   *     modified in place.\n   * @api\n   */\n  transform(source, destination) {\n    /** @type {import(\"../proj/Projection.js\").default} */\n    const sourceProj = getProjection(source);\n    const transformFn = sourceProj.getUnits() == Units.TILE_PIXELS ?\n      function(inCoordinates, outCoordinates, stride) {\n        const pixelExtent = sourceProj.getExtent();\n        const projectedExtent = sourceProj.getWorldExtent();\n        const scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n        composeTransform(tmpTransform,\n          projectedExtent[0], projectedExtent[3],\n          scale, -scale, 0,\n          0, 0);\n        transform2D(inCoordinates, 0, inCoordinates.length, stride,\n          tmpTransform, outCoordinates);\n        return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);\n      } :\n      getTransform(sourceProj, destination);\n    this.applyTransform(transformFn);\n    return this;\n  }\n\n}\n\n\nexport default Geometry;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}