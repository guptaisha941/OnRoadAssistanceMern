{"ast":null,"code":"/**\n * @module ol/geom/flat/textpath\n */\nimport { lerp } from '../../math.js';\n\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {function(string):number} measure Measure function returning the\n * width of the character passed as 1st argument.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @return {Array<Array<*>>} The result array of null if `maxAngle` was\n * exceeded. Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(flatCoordinates, offset, end, stride, text, measure, startM, maxAngle) {\n  var result = [];\n\n  // Keep text upright\n  var reverse = flatCoordinates[offset] > flatCoordinates[end - stride];\n  var numChars = text.length;\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  offset += stride;\n  var x2 = flatCoordinates[offset];\n  var y2 = flatCoordinates[offset + 1];\n  var segmentM = 0;\n  var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n  var chunk = '';\n  var chunkLength = 0;\n  var data, index, previousAngle;\n  for (var i = 0; i < numChars; ++i) {\n    index = reverse ? numChars - i - 1 : i;\n    var char = text.charAt(index);\n    chunk = reverse ? char + chunk : chunk + char;\n    var charLength = measure(chunk) - chunkLength;\n    chunkLength += charLength;\n    var charM = startM + charLength / 2;\n    while (offset < end - stride && segmentM + segmentLength < charM) {\n      x1 = x2;\n      y1 = y2;\n      offset += stride;\n      x2 = flatCoordinates[offset];\n      y2 = flatCoordinates[offset + 1];\n      segmentM += segmentLength;\n      segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    }\n    var segmentPos = charM - segmentM;\n    var angle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      angle += angle > 0 ? -Math.PI : Math.PI;\n    }\n    if (previousAngle !== undefined) {\n      var delta = angle - previousAngle;\n      delta += delta > Math.PI ? -2 * Math.PI : delta < -Math.PI ? 2 * Math.PI : 0;\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n    var interpolate = segmentPos / segmentLength;\n    var x = lerp(x1, x2, interpolate);\n    var y = lerp(y1, y2, interpolate);\n    if (previousAngle == angle) {\n      if (reverse) {\n        data[0] = x;\n        data[1] = y;\n        data[2] = charLength / 2;\n      }\n      data[4] = chunk;\n    } else {\n      chunk = char;\n      chunkLength = charLength;\n      data = [x, y, charLength / 2, angle, chunk];\n      if (reverse) {\n        result.unshift(data);\n      } else {\n        result.push(data);\n      }\n      previousAngle = angle;\n    }\n    startM += charLength;\n  }\n  return result;\n}","map":{"version":3,"names":["lerp","drawTextOnPath","flatCoordinates","offset","end","stride","text","measure","startM","maxAngle","result","reverse","numChars","length","x1","y1","x2","y2","segmentM","segmentLength","Math","sqrt","pow","chunk","chunkLength","data","index","previousAngle","i","char","charAt","charLength","charM","segmentPos","angle","atan2","PI","undefined","delta","abs","interpolate","x","y","unshift","push"],"sources":["../../../../src/ol/geom/flat/textpath.js"],"sourcesContent":["/**\n * @module ol/geom/flat/textpath\n */\nimport {lerp} from '../../math.js';\n\n\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {function(string):number} measure Measure function returning the\n * width of the character passed as 1st argument.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @return {Array<Array<*>>} The result array of null if `maxAngle` was\n * exceeded. Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(\n  flatCoordinates, offset, end, stride, text, measure, startM, maxAngle) {\n  const result = [];\n\n  // Keep text upright\n  const reverse = flatCoordinates[offset] > flatCoordinates[end - stride];\n\n  const numChars = text.length;\n\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  offset += stride;\n  let x2 = flatCoordinates[offset];\n  let y2 = flatCoordinates[offset + 1];\n  let segmentM = 0;\n  let segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n\n  let chunk = '';\n  let chunkLength = 0;\n  let data, index, previousAngle;\n  for (let i = 0; i < numChars; ++i) {\n    index = reverse ? numChars - i - 1 : i;\n    const char = text.charAt(index);\n    chunk = reverse ? char + chunk : chunk + char;\n    const charLength = measure(chunk) - chunkLength;\n    chunkLength += charLength;\n    const charM = startM + charLength / 2;\n    while (offset < end - stride && segmentM + segmentLength < charM) {\n      x1 = x2;\n      y1 = y2;\n      offset += stride;\n      x2 = flatCoordinates[offset];\n      y2 = flatCoordinates[offset + 1];\n      segmentM += segmentLength;\n      segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    }\n    const segmentPos = charM - segmentM;\n    let angle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      angle += angle > 0 ? -Math.PI : Math.PI;\n    }\n    if (previousAngle !== undefined) {\n      let delta = angle - previousAngle;\n      delta += (delta > Math.PI) ? -2 * Math.PI : (delta < -Math.PI) ? 2 * Math.PI : 0;\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n    const interpolate = segmentPos / segmentLength;\n    const x = lerp(x1, x2, interpolate);\n    const y = lerp(y1, y2, interpolate);\n    if (previousAngle == angle) {\n      if (reverse) {\n        data[0] = x;\n        data[1] = y;\n        data[2] = charLength / 2;\n      }\n      data[4] = chunk;\n    } else {\n      chunk = char;\n      chunkLength = charLength;\n      data = [x, y, charLength / 2, angle, chunk];\n      if (reverse) {\n        result.unshift(data);\n      } else {\n        result.push(data);\n      }\n      previousAngle = angle;\n    }\n    startM += charLength;\n  }\n  return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}