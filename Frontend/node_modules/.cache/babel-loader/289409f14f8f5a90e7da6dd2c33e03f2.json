{"ast":null,"code":"/**\n * @module ol/renderer/canvas/IntermediateCanvas\n */\nimport { abstract } from '../../util.js';\nimport { scale as scaleCoordinate } from '../../coordinate.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { containsExtent, intersects } from '../../extent.js';\nimport CanvasLayerRenderer from './Layer.js';\nimport { create as createTransform, apply as applyTransform } from '../../transform.js';\n\n/**\n * @abstract\n */\nvar IntermediateCanvasRenderer = /*@__PURE__*/function (CanvasLayerRenderer) {\n  function IntermediateCanvasRenderer(layer) {\n    CanvasLayerRenderer.call(this, layer);\n\n    /**\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.coordinateToCanvasPixelTransform = createTransform();\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitCanvasContext_ = null;\n  }\n  if (CanvasLayerRenderer) IntermediateCanvasRenderer.__proto__ = CanvasLayerRenderer;\n  IntermediateCanvasRenderer.prototype = Object.create(CanvasLayerRenderer && CanvasLayerRenderer.prototype);\n  IntermediateCanvasRenderer.prototype.constructor = IntermediateCanvasRenderer;\n\n  /**\n   * @inheritDoc\n   */\n  IntermediateCanvasRenderer.prototype.composeFrame = function composeFrame(frameState, layerState, context) {\n    this.preCompose(context, frameState);\n    var image = this.getImage();\n    if (image) {\n      // clipped rendering if layer extent is set\n      var extent = layerState.extent;\n      var clipped = extent !== undefined && !containsExtent(extent, frameState.extent) && intersects(extent, frameState.extent);\n      if (clipped) {\n        this.clip(context, frameState, /** @type {import(\"../../extent.js\").Extent} */extent);\n      }\n      var imageTransform = this.getImageTransform();\n      // for performance reasons, context.save / context.restore is not used\n      // to save and restore the transformation matrix and the opacity.\n      // see http://jsperf.com/context-save-restore-versus-variable\n      var alpha = context.globalAlpha;\n      context.globalAlpha = layerState.opacity;\n\n      // for performance reasons, context.setTransform is only used\n      // when the view is rotated. see http://jsperf.com/canvas-transform\n      var dx = imageTransform[4];\n      var dy = imageTransform[5];\n      var dw = image.width * imageTransform[0];\n      var dh = image.height * imageTransform[3];\n      if (dw >= 0.5 && dh >= 0.5) {\n        context.drawImage(image, 0, 0, +image.width, +image.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));\n      }\n      context.globalAlpha = alpha;\n      if (clipped) {\n        context.restore();\n      }\n    }\n    this.postCompose(context, frameState, layerState);\n  };\n\n  /**\n   * @abstract\n   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Canvas.\n   */\n  IntermediateCanvasRenderer.prototype.getImage = function getImage() {\n    return abstract();\n  };\n\n  /**\n   * @abstract\n   * @return {!import(\"../../transform.js\").Transform} Image transform.\n   */\n  IntermediateCanvasRenderer.prototype.getImageTransform = function getImageTransform() {\n    return abstract();\n  };\n\n  /**\n   * @inheritDoc\n   */\n  IntermediateCanvasRenderer.prototype.forEachLayerAtCoordinate = function forEachLayerAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    if (!this.getImage()) {\n      return undefined;\n    }\n    var pixel = applyTransform(this.coordinateToCanvasPixelTransform, coordinate.slice());\n    scaleCoordinate(pixel, frameState.viewState.resolution / this.renderedResolution);\n    if (!this.hitCanvasContext_) {\n      this.hitCanvasContext_ = createCanvasContext2D(1, 1);\n    }\n    this.hitCanvasContext_.clearRect(0, 0, 1, 1);\n    this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);\n    var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;\n    if (imageData[3] > 0) {\n      return callback.call(thisArg, this.getLayer(), imageData);\n    } else {\n      return undefined;\n    }\n  };\n  return IntermediateCanvasRenderer;\n}(CanvasLayerRenderer);\nexport default IntermediateCanvasRenderer;","map":{"version":3,"names":["abstract","scale","scaleCoordinate","createCanvasContext2D","containsExtent","intersects","CanvasLayerRenderer","create","createTransform","apply","applyTransform","IntermediateCanvasRenderer","layer","call","coordinateToCanvasPixelTransform","hitCanvasContext_","composeFrame","frameState","layerState","context","preCompose","image","getImage","extent","clipped","undefined","clip","imageTransform","getImageTransform","alpha","globalAlpha","opacity","dx","dy","dw","width","dh","height","drawImage","Math","round","restore","postCompose","forEachLayerAtCoordinate","coordinate","hitTolerance","callback","thisArg","pixel","slice","viewState","resolution","renderedResolution","clearRect","imageData","getImageData","data","getLayer"],"sources":["../../../../src/ol/renderer/canvas/IntermediateCanvas.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/IntermediateCanvas\n */\nimport {abstract} from '../../util.js';\nimport {scale as scaleCoordinate} from '../../coordinate.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {containsExtent, intersects} from '../../extent.js';\nimport CanvasLayerRenderer from './Layer.js';\nimport {create as createTransform, apply as applyTransform} from '../../transform.js';\n\n/**\n * @abstract\n */\nclass IntermediateCanvasRenderer extends CanvasLayerRenderer {\n\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   */\n  constructor(layer) {\n\n    super(layer);\n\n    /**\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.coordinateToCanvasPixelTransform = createTransform();\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitCanvasContext_ = null;\n\n  }\n\n  /**\n   * @inheritDoc\n   */\n  composeFrame(frameState, layerState, context) {\n\n    this.preCompose(context, frameState);\n\n    const image = this.getImage();\n    if (image) {\n\n      // clipped rendering if layer extent is set\n      const extent = layerState.extent;\n      const clipped = extent !== undefined &&\n          !containsExtent(extent, frameState.extent) &&\n          intersects(extent, frameState.extent);\n      if (clipped) {\n        this.clip(context, frameState, /** @type {import(\"../../extent.js\").Extent} */ (extent));\n      }\n\n      const imageTransform = this.getImageTransform();\n      // for performance reasons, context.save / context.restore is not used\n      // to save and restore the transformation matrix and the opacity.\n      // see http://jsperf.com/context-save-restore-versus-variable\n      const alpha = context.globalAlpha;\n      context.globalAlpha = layerState.opacity;\n\n      // for performance reasons, context.setTransform is only used\n      // when the view is rotated. see http://jsperf.com/canvas-transform\n      const dx = imageTransform[4];\n      const dy = imageTransform[5];\n      const dw = image.width * imageTransform[0];\n      const dh = image.height * imageTransform[3];\n      if (dw >= 0.5 && dh >= 0.5) {\n        context.drawImage(image, 0, 0, +image.width, +image.height,\n          Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));\n      }\n      context.globalAlpha = alpha;\n\n      if (clipped) {\n        context.restore();\n      }\n    }\n\n    this.postCompose(context, frameState, layerState);\n  }\n\n  /**\n   * @abstract\n   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Canvas.\n   */\n  getImage() {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @return {!import(\"../../transform.js\").Transform} Image transform.\n   */\n  getImageTransform() {\n    return abstract();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  forEachLayerAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    if (!this.getImage()) {\n      return undefined;\n    }\n\n    const pixel = applyTransform(this.coordinateToCanvasPixelTransform, coordinate.slice());\n    scaleCoordinate(pixel, frameState.viewState.resolution / this.renderedResolution);\n\n    if (!this.hitCanvasContext_) {\n      this.hitCanvasContext_ = createCanvasContext2D(1, 1);\n    }\n\n    this.hitCanvasContext_.clearRect(0, 0, 1, 1);\n    this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);\n\n    const imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;\n    if (imageData[3] > 0) {\n      return callback.call(thisArg, this.getLayer(), imageData);\n    } else {\n      return undefined;\n    }\n  }\n}\n\n\nexport default IntermediateCanvasRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}