{"ast":null,"code":"/**\n * @module ol/renderer/Layer\n */\nimport { getUid } from '../util.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport TileState from '../TileState.js';\nimport { listen } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport SourceState from '../source/State.js';\nvar LayerRenderer = /*@__PURE__*/function (Observable) {\n  function LayerRenderer(layer) {\n    Observable.call(this);\n\n    /**\n     * @private\n     * @type {import(\"../layer/Layer.js\").default}\n     */\n    this.layer_ = layer;\n  }\n  if (Observable) LayerRenderer.__proto__ = Observable;\n  LayerRenderer.prototype = Object.create(Observable && Observable.prototype);\n  LayerRenderer.prototype.constructor = LayerRenderer;\n\n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n   * @protected\n   */\n  LayerRenderer.prototype.createLoadedTileFinder = function createLoadedTileFinder(source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       */\n      function (zoom, tileRange) {\n        /**\n         * @param {import(\"../Tile.js\").default} tile Tile.\n         */\n        function callback(tile) {\n          if (!tiles[zoom]) {\n            tiles[zoom] = {};\n          }\n          tiles[zoom][tile.tileCoord.toString()] = tile;\n        }\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }\n    );\n  };\n\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default): T} callback Feature callback.\n   * @return {T|void} Callback result.\n   * @template T\n   */\n  LayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback) {};\n\n  /**\n   * @return {import(\"../layer/Layer.js\").default} Layer.\n   */\n  LayerRenderer.prototype.getLayer = function getLayer() {\n    return this.layer_;\n  };\n\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n  LayerRenderer.prototype.handleImageChange_ = function handleImageChange_(event) {\n    var image = /** @type {import(\"../Image.js\").default} */event.target;\n    if (image.getState() === ImageState.LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  };\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Is there a feature at the given coordinate?\n   */\n  LayerRenderer.prototype.hasFeatureAtCoordinate = function hasFeatureAtCoordinate(coordinate, frameState) {\n    return false;\n  };\n\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../ImageBase.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  LayerRenderer.prototype.loadImage = function loadImage(image) {\n    var imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      listen(image, EventType.CHANGE, this.handleImageChange_, this);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  };\n\n  /**\n   * @protected\n   */\n  LayerRenderer.prototype.renderIfReadyAndVisible = function renderIfReadyAndVisible() {\n    var layer = this.getLayer();\n    if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {\n      this.changed();\n    }\n  };\n\n  /**\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  LayerRenderer.prototype.scheduleExpireCache = function scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../PluggableMap.js\").default} map Map.\n       * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n       */\n      var postRenderFunction = function (tileSource, map, frameState) {\n        var tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);\n        }\n      }.bind(null, tileSource);\n      frameState.postRenderFunctions.push( /** @type {import(\"../PluggableMap.js\").PostRenderFunction} */postRenderFunction);\n    }\n  };\n\n  /**\n   * @param {!Object<string, !Object<string, import(\"../TileRange.js\").default>>} usedTiles Used tiles.\n   * @param {import(\"../source/Tile.js\").default} tileSource Tile source.\n   * @param {number} z Z.\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n   * @protected\n   */\n  LayerRenderer.prototype.updateUsedTiles = function updateUsedTiles(usedTiles, tileSource, z, tileRange) {\n    // FIXME should we use tilesToDrawByZ instead?\n    var tileSourceKey = getUid(tileSource);\n    var zKey = z.toString();\n    if (tileSourceKey in usedTiles) {\n      if (zKey in usedTiles[tileSourceKey]) {\n        usedTiles[tileSourceKey][zKey].extend(tileRange);\n      } else {\n        usedTiles[tileSourceKey][zKey] = tileRange;\n      }\n    } else {\n      usedTiles[tileSourceKey] = {};\n      usedTiles[tileSourceKey][zKey] = tileRange;\n    }\n  };\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to 'preload' levels.\n   * @param {function(this: T, import(\"../Tile.js\").default)=} opt_tileCallback Tile callback.\n   * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.\n   * @protected\n   * @template T\n   */\n  LayerRenderer.prototype.manageTilePyramid = function manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback, opt_this) {\n    var tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    var wantedTiles = frameState.wantedTiles[tileSourceKey];\n    var tileQueue = frameState.tileQueue;\n    var minZoom = tileGrid.getMinZoom();\n    var tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (currentZ - z <= preload) {\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n              }\n            }\n            if (opt_tileCallback !== undefined) {\n              opt_tileCallback.call(opt_this, tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n  };\n  return LayerRenderer;\n}(Observable);\nexport default LayerRenderer;","map":{"version":3,"names":["getUid","ImageState","Observable","TileState","listen","EventType","SourceState","LayerRenderer","layer","call","layer_","createLoadedTileFinder","source","projection","tiles","zoom","tileRange","callback","tile","tileCoord","toString","forEachLoadedTile","forEachFeatureAtCoordinate","coordinate","frameState","hitTolerance","getLayer","handleImageChange_","event","image","target","getState","LOADED","renderIfReadyAndVisible","hasFeatureAtCoordinate","loadImage","imageState","ERROR","CHANGE","IDLE","load","getVisible","getSourceState","READY","changed","scheduleExpireCache","tileSource","canExpireCache","postRenderFunction","map","tileSourceKey","usedTiles","expireCache","viewState","bind","postRenderFunctions","push","updateUsedTiles","z","zKey","extend","manageTilePyramid","tileGrid","pixelRatio","extent","currentZ","preload","opt_tileCallback","opt_this","wantedTiles","tileQueue","minZoom","getMinZoom","tileResolution","x","y","getTileRangeForExtentAndZ","getResolution","minX","maxX","minY","maxY","getTile","getKey","isKeyQueued","enqueue","getTileCoordCenter","undefined","useTile"],"sources":["../../../src/ol/renderer/Layer.js"],"sourcesContent":["/**\n * @module ol/renderer/Layer\n */\nimport {getUid} from '../util.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport TileState from '../TileState.js';\nimport {listen} from '../events.js';\nimport EventType from '../events/EventType.js';\nimport SourceState from '../source/State.js';\n\nclass LayerRenderer extends Observable {\n\n  /**\n   * @param {import(\"../layer/Layer.js\").default} layer Layer.\n   */\n  constructor(layer) {\n\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../layer/Layer.js\").default}\n     */\n    this.layer_ = layer;\n\n  }\n\n  /**\n   * Create a function that adds loaded tiles to the tile lookup.\n   * @param {import(\"../source/Tile.js\").default} source Tile source.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection of the tiles.\n   * @param {Object<number, Object<string, import(\"../Tile.js\").default>>} tiles Lookup of loaded tiles by zoom level.\n   * @return {function(number, import(\"../TileRange.js\").default):boolean} A function that can be\n   *     called with a zoom level and a tile range to add loaded tiles to the lookup.\n   * @protected\n   */\n  createLoadedTileFinder(source, projection, tiles) {\n    return (\n      /**\n       * @param {number} zoom Zoom level.\n       * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n       * @return {boolean} The tile range is fully loaded.\n       */\n      function(zoom, tileRange) {\n        /**\n         * @param {import(\"../Tile.js\").default} tile Tile.\n         */\n        function callback(tile) {\n          if (!tiles[zoom]) {\n            tiles[zoom] = {};\n          }\n          tiles[zoom][tile.tileCoord.toString()] = tile;\n        }\n        return source.forEachLoadedTile(projection, zoom, tileRange, callback);\n      }\n    );\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default): T} callback Feature callback.\n   * @return {T|void} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback) {}\n\n  /**\n   * @return {import(\"../layer/Layer.js\").default} Layer.\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n  handleImageChange_(event) {\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\n    if (image.getState() === ImageState.LOADED) {\n      this.renderIfReadyAndVisible();\n    }\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @return {boolean} Is there a feature at the given coordinate?\n   */\n  hasFeatureAtCoordinate(coordinate, frameState) {\n    return false;\n  }\n\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../ImageBase.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  loadImage(image) {\n    let imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      listen(image, EventType.CHANGE, this.handleImageChange_, this);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  }\n\n  /**\n   * @protected\n   */\n  renderIfReadyAndVisible() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {\n      this.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../source/Tile.js\").default} tileSource Tile source.\n   * @protected\n   */\n  scheduleExpireCache(frameState, tileSource) {\n    if (tileSource.canExpireCache()) {\n      /**\n       * @param {import(\"../source/Tile.js\").default} tileSource Tile source.\n       * @param {import(\"../PluggableMap.js\").default} map Map.\n       * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = function(tileSource, map, frameState) {\n        const tileSourceKey = getUid(tileSource);\n        if (tileSourceKey in frameState.usedTiles) {\n          tileSource.expireCache(frameState.viewState.projection,\n            frameState.usedTiles[tileSourceKey]);\n        }\n      }.bind(null, tileSource);\n\n      frameState.postRenderFunctions.push(\n        /** @type {import(\"../PluggableMap.js\").PostRenderFunction} */ (postRenderFunction)\n      );\n    }\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, import(\"../TileRange.js\").default>>} usedTiles Used tiles.\n   * @param {import(\"../source/Tile.js\").default} tileSource Tile source.\n   * @param {number} z Z.\n   * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, z, tileRange) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    const zKey = z.toString();\n    if (tileSourceKey in usedTiles) {\n      if (zKey in usedTiles[tileSourceKey]) {\n        usedTiles[tileSourceKey][zKey].extend(tileRange);\n      } else {\n        usedTiles[tileSourceKey][zKey] = tileRange;\n      }\n    } else {\n      usedTiles[tileSourceKey] = {};\n      usedTiles[tileSourceKey][zKey] = tileRange;\n    }\n  }\n\n  /**\n   * Manage tile pyramid.\n   * This function performs a number of functions related to the tiles at the\n   * current zoom and lower zoom levels:\n   * - registers idle tiles in frameState.wantedTiles so that they are not\n   *   discarded by the tile queue\n   * - enqueues missing tiles\n   * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../source/Tile.js\").default} tileSource Tile source.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} currentZ Current Z.\n   * @param {number} preload Load low resolution tiles up to 'preload' levels.\n   * @param {function(this: T, import(\"../Tile.js\").default)=} opt_tileCallback Tile callback.\n   * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.\n   * @protected\n   * @template T\n   */\n  manageTilePyramid(\n    frameState,\n    tileSource,\n    tileGrid,\n    pixelRatio,\n    projection,\n    extent,\n    currentZ,\n    preload,\n    opt_tileCallback,\n    opt_this\n  ) {\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileQueue = frameState.tileQueue;\n    const minZoom = tileGrid.getMinZoom();\n    let tile, tileRange, tileResolution, x, y, z;\n    for (z = minZoom; z <= currentZ; ++z) {\n      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);\n      tileResolution = tileGrid.getResolution(z);\n      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (currentZ - z <= preload) {\n            tile = tileSource.getTile(z, x, y, pixelRatio, projection);\n            if (tile.getState() == TileState.IDLE) {\n              wantedTiles[tile.getKey()] = true;\n              if (!tileQueue.isKeyQueued(tile.getKey())) {\n                tileQueue.enqueue([tile, tileSourceKey,\n                  tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);\n              }\n            }\n            if (opt_tileCallback !== undefined) {\n              opt_tileCallback.call(opt_this, tile);\n            }\n          } else {\n            tileSource.useTile(z, x, y, projection);\n          }\n        }\n      }\n    }\n  }\n}\n\nexport default LayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}