{"ast":null,"code":"/**\n * @module ol/TileQueue\n */\nimport TileState from './TileState.js';\nimport { listen, unlisten } from './events.js';\nimport EventType from './events/EventType.js';\nimport PriorityQueue from './structs/PriorityQueue.js';\n\n/**\n * @typedef {function(import(\"./Tile.js\").default, string, import(\"./coordinate.js\").Coordinate, number): number} PriorityFunction\n */\n\nvar TileQueue = /*@__PURE__*/function (PriorityQueue) {\n  function TileQueue(tilePriorityFunction, tileChangeCallback) {\n    PriorityQueue.call(\n    /**\n     * @param {Array} element Element.\n     * @return {number} Priority.\n     */\n    this, function (element) {\n      return tilePriorityFunction.apply(null, element);\n    },\n    /**\n     * @param {Array} element Element.\n     * @return {string} Key.\n     */\n    function (element) {\n      return (/** @type {import(\"./Tile.js\").default} */element[0].getKey()\n      );\n    });\n\n    /**\n     * @private\n     * @type {function(): ?}\n     */\n    this.tileChangeCallback_ = tileChangeCallback;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tilesLoading_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string,boolean>}\n     */\n    this.tilesLoadingKeys_ = {};\n  }\n  if (PriorityQueue) TileQueue.__proto__ = PriorityQueue;\n  TileQueue.prototype = Object.create(PriorityQueue && PriorityQueue.prototype);\n  TileQueue.prototype.constructor = TileQueue;\n\n  /**\n   * @inheritDoc\n   */\n  TileQueue.prototype.enqueue = function enqueue(element) {\n    var added = PriorityQueue.prototype.enqueue.call(this, element);\n    if (added) {\n      var tile = element[0];\n      listen(tile, EventType.CHANGE, this.handleTileChange, this);\n    }\n    return added;\n  };\n\n  /**\n   * @return {number} Number of tiles loading.\n   */\n  TileQueue.prototype.getTilesLoading = function getTilesLoading() {\n    return this.tilesLoading_;\n  };\n\n  /**\n   * @param {import(\"./events/Event.js\").default} event Event.\n   * @protected\n   */\n  TileQueue.prototype.handleTileChange = function handleTileChange(event) {\n    var tile = /** @type {import(\"./Tile.js\").default} */event.target;\n    var state = tile.getState();\n    if (state === TileState.LOADED || state === TileState.ERROR || state === TileState.EMPTY || state === TileState.ABORT) {\n      unlisten(tile, EventType.CHANGE, this.handleTileChange, this);\n      var tileKey = tile.getKey();\n      if (tileKey in this.tilesLoadingKeys_) {\n        delete this.tilesLoadingKeys_[tileKey];\n        --this.tilesLoading_;\n      }\n      this.tileChangeCallback_();\n    }\n  };\n\n  /**\n   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.\n   * @param {number} maxNewLoads Maximum number of new tiles to load.\n   */\n  TileQueue.prototype.loadMoreTiles = function loadMoreTiles(maxTotalLoading, maxNewLoads) {\n    var newLoads = 0;\n    var abortedTiles = false;\n    var state, tile, tileKey;\n    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {\n      tile = /** @type {import(\"./Tile.js\").default} */this.dequeue()[0];\n      tileKey = tile.getKey();\n      state = tile.getState();\n      if (state === TileState.ABORT) {\n        abortedTiles = true;\n      } else if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {\n        this.tilesLoadingKeys_[tileKey] = true;\n        ++this.tilesLoading_;\n        ++newLoads;\n        tile.load();\n      }\n    }\n    if (newLoads === 0 && abortedTiles) {\n      // Do not stop the render loop when all wanted tiles were aborted due to\n      // a small, saturated tile cache.\n      this.tileChangeCallback_();\n    }\n  };\n  return TileQueue;\n}(PriorityQueue);\nexport default TileQueue;","map":{"version":3,"names":["TileState","listen","unlisten","EventType","PriorityQueue","TileQueue","tilePriorityFunction","tileChangeCallback","call","element","apply","getKey","tileChangeCallback_","tilesLoading_","tilesLoadingKeys_","enqueue","added","prototype","tile","CHANGE","handleTileChange","getTilesLoading","event","target","state","getState","LOADED","ERROR","EMPTY","ABORT","tileKey","loadMoreTiles","maxTotalLoading","maxNewLoads","newLoads","abortedTiles","getCount","dequeue","IDLE","load"],"sources":["../../src/ol/TileQueue.js"],"sourcesContent":["/**\n * @module ol/TileQueue\n */\nimport TileState from './TileState.js';\nimport {listen, unlisten} from './events.js';\nimport EventType from './events/EventType.js';\nimport PriorityQueue from './structs/PriorityQueue.js';\n\n\n/**\n * @typedef {function(import(\"./Tile.js\").default, string, import(\"./coordinate.js\").Coordinate, number): number} PriorityFunction\n */\n\n\nclass TileQueue extends PriorityQueue {\n\n  /**\n   * @param {PriorityFunction} tilePriorityFunction Tile priority function.\n   * @param {function(): ?} tileChangeCallback Function called on each tile change event.\n   */\n  constructor(tilePriorityFunction, tileChangeCallback) {\n\n    super(\n      /**\n       * @param {Array} element Element.\n       * @return {number} Priority.\n       */\n      function(element) {\n        return tilePriorityFunction.apply(null, element);\n      },\n      /**\n       * @param {Array} element Element.\n       * @return {string} Key.\n       */\n      function(element) {\n        return (/** @type {import(\"./Tile.js\").default} */ (element[0]).getKey());\n      });\n\n    /**\n     * @private\n     * @type {function(): ?}\n     */\n    this.tileChangeCallback_ = tileChangeCallback;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tilesLoading_ = 0;\n\n    /**\n     * @private\n     * @type {!Object<string,boolean>}\n     */\n    this.tilesLoadingKeys_ = {};\n\n  }\n\n  /**\n   * @inheritDoc\n   */\n  enqueue(element) {\n    const added = super.enqueue(element);\n    if (added) {\n      const tile = element[0];\n      listen(tile, EventType.CHANGE, this.handleTileChange, this);\n    }\n    return added;\n  }\n\n  /**\n   * @return {number} Number of tiles loading.\n   */\n  getTilesLoading() {\n    return this.tilesLoading_;\n  }\n\n  /**\n   * @param {import(\"./events/Event.js\").default} event Event.\n   * @protected\n   */\n  handleTileChange(event) {\n    const tile = /** @type {import(\"./Tile.js\").default} */ (event.target);\n    const state = tile.getState();\n    if (state === TileState.LOADED || state === TileState.ERROR ||\n        state === TileState.EMPTY || state === TileState.ABORT) {\n      unlisten(tile, EventType.CHANGE, this.handleTileChange, this);\n      const tileKey = tile.getKey();\n      if (tileKey in this.tilesLoadingKeys_) {\n        delete this.tilesLoadingKeys_[tileKey];\n        --this.tilesLoading_;\n      }\n      this.tileChangeCallback_();\n    }\n  }\n\n  /**\n   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.\n   * @param {number} maxNewLoads Maximum number of new tiles to load.\n   */\n  loadMoreTiles(maxTotalLoading, maxNewLoads) {\n    let newLoads = 0;\n    let abortedTiles = false;\n    let state, tile, tileKey;\n    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads &&\n           this.getCount() > 0) {\n      tile = /** @type {import(\"./Tile.js\").default} */ (this.dequeue()[0]);\n      tileKey = tile.getKey();\n      state = tile.getState();\n      if (state === TileState.ABORT) {\n        abortedTiles = true;\n      } else if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {\n        this.tilesLoadingKeys_[tileKey] = true;\n        ++this.tilesLoading_;\n        ++newLoads;\n        tile.load();\n      }\n    }\n    if (newLoads === 0 && abortedTiles) {\n      // Do not stop the render loop when all wanted tiles were aborted due to\n      // a small, saturated tile cache.\n      this.tileChangeCallback_();\n    }\n  }\n}\n\n\nexport default TileQueue;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}