{"ast":null,"code":"/**\n * @module ol/reproj/Tile\n */\nimport { ERROR_THRESHOLD } from './common.js';\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport { listen, unlistenByKey } from '../events.js';\nimport EventType from '../events/EventType.js';\nimport { getArea, getCenter, getIntersection } from '../extent.js';\nimport { clamp } from '../math.js';\nimport { calculateSourceResolution, render as renderReprojected } from '../reproj.js';\nimport Triangulation from './Triangulation.js';\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nvar ReprojTile = /*@__PURE__*/function (Tile) {\n  function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges) {\n    Tile.call(this, tileCoord, TileState.IDLE);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<import(\"../Tile.js\").default>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n    var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);\n    var maxTargetExtent = this.targetTileGrid_.getExtent();\n    var maxSourceExtent = this.sourceTileGrid_.getExtent();\n    var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n    var sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n    var targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);\n    var targetCenter = getCenter(limitedTargetExtent);\n    var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n    var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels);\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    var sourceExtent = this.triangulation_.calculateSourceExtent();\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, this.sourceZ_);\n      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          var tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n  if (Tile) ReprojTile.__proto__ = Tile;\n  ReprojTile.prototype = Object.create(Tile && Tile.prototype);\n  ReprojTile.prototype.constructor = ReprojTile;\n\n  /**\n   * @inheritDoc\n   */\n  ReprojTile.prototype.disposeInternal = function disposeInternal() {\n    if (this.state == TileState.LOADING) {\n      this.unlistenSources_();\n    }\n    Tile.prototype.disposeInternal.call(this);\n  };\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  ReprojTile.prototype.getImage = function getImage() {\n    return this.canvas_;\n  };\n\n  /**\n   * @private\n   */\n  ReprojTile.prototype.reproject_ = function reproject_() {\n    var sources = [];\n    this.sourceTiles_.forEach(function (tile, i, arr) {\n      if (tile && tile.getState() == TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage()\n        });\n      }\n    }.bind(this));\n    this.sourceTiles_.length = 0;\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      var z = this.wrappedTileCoord_[0];\n      var size = this.targetTileGrid_.getTileSize(z);\n      var width = typeof size === 'number' ? size : size[0];\n      var height = typeof size === 'number' ? size : size[1];\n      var targetResolution = this.targetTileGrid_.getResolution(z);\n      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n      var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);\n      this.canvas_ = renderReprojected(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_);\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  };\n\n  /**\n   * @inheritDoc\n   */\n  ReprojTile.prototype.load = function load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n      var leftToLoad = 0;\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        var state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n          var sourceListenKey = listen(tile, EventType.CHANGE, function (e) {\n            var state = tile.getState();\n            if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {\n              unlistenByKey(sourceListenKey);\n              leftToLoad--;\n              if (leftToLoad === 0) {\n                this.unlistenSources_();\n                this.reproject_();\n              }\n            }\n          }, this);\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      }.bind(this));\n      this.sourceTiles_.forEach(function (tile, i, arr) {\n        var state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      }\n    }\n  };\n\n  /**\n   * @private\n   */\n  ReprojTile.prototype.unlistenSources_ = function unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  };\n  return ReprojTile;\n}(Tile);\nexport default ReprojTile;","map":{"version":3,"names":["ERROR_THRESHOLD","Tile","TileState","listen","unlistenByKey","EventType","getArea","getCenter","getIntersection","clamp","calculateSourceResolution","render","renderReprojected","Triangulation","ReprojTile","sourceProj","sourceTileGrid","targetProj","targetTileGrid","tileCoord","wrappedTileCoord","pixelRatio","gutter","getTileFunction","opt_errorThreshold","opt_renderEdges","call","IDLE","renderEdges_","undefined","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","targetExtent","getTileCoordExtent","maxTargetExtent","getExtent","maxSourceExtent","limitedTargetExtent","state","EMPTY","sourceProjExtent","targetResolution","getResolution","targetCenter","sourceResolution","isFinite","errorThresholdInPixels","triangulation_","getTriangles","length","getZForResolution","sourceExtent","calculateSourceExtent","canWrapX","sourceRange","getTileRangeForExtentAndZ","srcX","minX","maxX","srcY","minY","maxY","tile","push","disposeInternal","LOADING","unlistenSources_","prototype","getImage","reproject_","sources","forEach","i","arr","getState","LOADED","extent","image","bind","ERROR","z","size","getTileSize","width","height","changed","load","leftToLoad","sourceListenKey","CHANGE","e","setTimeout"],"sources":["../../../src/ol/reproj/Tile.js"],"sourcesContent":["/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport EventType from '../events/EventType.js';\nimport {getArea, getCenter, getIntersection} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {calculateSourceResolution, render as renderReprojected} from '../reproj.js';\nimport Triangulation from './Triangulation.js';\n\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nclass ReprojTile extends Tile {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} sourceTileGrid Source tile grid.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} targetTileGrid Target tile grid.\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Coordinate of the tile.\n   * @param {import(\"../tilecoord.js\").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} gutter Gutter of the source tiles.\n   * @param {FunctionType} getTileFunction\n   *     Function returning source tiles (z, x, y, pixelRatio).\n   * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).\n   * @param {boolean=} opt_renderEdges Render reprojection edges.\n   */\n  constructor(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    opt_errorThreshold,\n    opt_renderEdges\n  ) {\n    super(tileCoord, TileState.IDLE);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<import(\"../Tile.js\").default>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    const targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);\n    const maxTargetExtent = this.targetTileGrid_.getExtent();\n    let maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    const limitedTargetExtent = maxTargetExtent ?\n      getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    const targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0]);\n\n    const targetCenter = getCenter(limitedTargetExtent);\n    const sourceResolution = calculateSourceResolution(\n      sourceProj, targetProj, targetCenter, targetResolution);\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    const errorThresholdInPixels = opt_errorThreshold !== undefined ?\n      opt_errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj, targetProj, limitedTargetExtent, maxSourceExtent,\n      sourceResolution * errorThresholdInPixels);\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    let sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(\n          sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n        sourceExtent, this.sourceZ_);\n\n      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  disposeInternal() {\n    if (this.state == TileState.LOADING) {\n      this.unlistenSources_();\n    }\n    super.disposeInternal();\n  }\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sources = [];\n    this.sourceTiles_.forEach(function(tile, i, arr) {\n      if (tile && tile.getState() == TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage()\n        });\n      }\n    }.bind(this));\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      const z = this.wrappedTileCoord_[0];\n      const size = this.targetTileGrid_.getTileSize(z);\n      const width = typeof size === 'number' ? size : size[0];\n      const height = typeof size === 'number' ? size : size[1];\n      const targetResolution = this.targetTileGrid_.getResolution(z);\n      const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n\n      const targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_);\n      this.canvas_ = renderReprojected(width, height, this.pixelRatio_,\n        sourceResolution, this.sourceTileGrid_.getExtent(),\n        targetResolution, targetExtent, this.triangulation_, sources,\n        this.gutter_, this.renderEdges_);\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  load() {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      let leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(function(tile, i, arr) {\n        const state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          const sourceListenKey = listen(tile, EventType.CHANGE,\n            function(e) {\n              const state = tile.getState();\n              if (state == TileState.LOADED ||\n                    state == TileState.ERROR ||\n                    state == TileState.EMPTY) {\n                unlistenByKey(sourceListenKey);\n                leftToLoad--;\n                if (leftToLoad === 0) {\n                  this.unlistenSources_();\n                  this.reproject_();\n                }\n              }\n            }, this);\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      }.bind(this));\n\n      this.sourceTiles_.forEach(function(tile, i, arr) {\n        const state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSources_() {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  }\n}\n\n\nexport default ReprojTile;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}