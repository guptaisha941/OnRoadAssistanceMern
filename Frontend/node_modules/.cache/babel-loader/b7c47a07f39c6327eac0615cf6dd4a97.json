{"ast":null,"code":"/**\n * @module ol/geom/flat/closest\n */\nimport { lerp, squaredDistance as squaredDx } from '../../math.js';\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\nfunction assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n  var x1 = flatCoordinates[offset1];\n  var y1 = flatCoordinates[offset1 + 1];\n  var dx = flatCoordinates[offset2] - x1;\n  var dy = flatCoordinates[offset2 + 1] - y1;\n  var offset;\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (var i = 0; i < stride; ++i) {\n        closestPoint[i] = lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n  for (var i$1 = 0; i$1 < stride; ++i$1) {\n    closestPoint[i$1] = flatCoordinates[offset + i$1];\n  }\n  closestPoint.length = stride;\n}\n\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  for (offset += stride; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    var squaredDelta = squaredDx(x1, y1, x2, y2);\n    if (squaredDelta > max) {\n      max = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n    offset = end;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n    offset = ends[ends.length - 1];\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n  var i, squaredDistance;\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = squaredDx(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var index = offset + stride;\n  while (index < end) {\n    assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);\n    }\n  }\n  if (isRing) {\n    // Check the closing segment.\n    assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = end;\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n}","map":{"version":3,"names":["lerp","squaredDistance","squaredDx","assignClosest","flatCoordinates","offset1","offset2","stride","x","y","closestPoint","x1","y1","dx","dy","offset","t","i","length","i$1","maxSquaredDelta","end","max","x2","y2","squaredDelta","arrayMaxSquaredDelta","ends","ii","multiArrayMaxSquaredDelta","endss","assignClosestPoint","maxDelta","isRing","minSquaredDistance","opt_tmpPoint","tmpPoint","NaN","index","Math","sqrt","assignClosestArrayPoint","assignClosestMultiArrayPoint"],"sources":["../../../../src/ol/geom/flat/closest.js"],"sourcesContent":["/**\n * @module ol/geom/flat/closest\n */\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\n\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\nfunction assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n  const x1 = flatCoordinates[offset1];\n  const y1 = flatCoordinates[offset1 + 1];\n  const dx = flatCoordinates[offset2] - x1;\n  const dy = flatCoordinates[offset2 + 1] - y1;\n  let offset;\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (let i = 0; i < stride; ++i) {\n        closestPoint[i] = lerp(flatCoordinates[offset1 + i],\n          flatCoordinates[offset2 + i], t);\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n  for (let i = 0; i < stride; ++i) {\n    closestPoint[i] = flatCoordinates[offset + i];\n  }\n  closestPoint.length = stride;\n}\n\n\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  for (offset += stride; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    const squaredDelta = squaredDx(x1, y1, x2, y2);\n    if (squaredDelta > max) {\n      max = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return max;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    max = maxSquaredDelta(\n      flatCoordinates, offset, end, stride, max);\n    offset = end;\n  }\n  return max;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    max = arrayMaxSquaredDelta(\n      flatCoordinates, offset, ends, stride, max);\n    offset = ends[ends.length - 1];\n  }\n  return max;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestPoint(flatCoordinates, offset, end,\n  stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n  opt_tmpPoint) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n  let i, squaredDistance;\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = squaredDx(\n      x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n  const tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  let index = offset + stride;\n  while (index < end) {\n    assignClosest(\n      flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index += stride * Math.max(\n        ((Math.sqrt(squaredDistance) -\n            Math.sqrt(minSquaredDistance)) / maxDelta) | 0, 1);\n    }\n  }\n  if (isRing) {\n    // Check the closing segment.\n    assignClosest(\n      flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestArrayPoint(flatCoordinates, offset, ends,\n  stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n  opt_tmpPoint) {\n  const tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    minSquaredDistance = assignClosestPoint(\n      flatCoordinates, offset, end, stride,\n      maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = end;\n  }\n  return minSquaredDistance;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestMultiArrayPoint(flatCoordinates, offset,\n  endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n  opt_tmpPoint) {\n  const tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    minSquaredDistance = assignClosestArrayPoint(\n      flatCoordinates, offset, ends, stride,\n      maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}