{"ast":null,"code":"/**\n * @module ol/PluggableMap\n */\nimport { getUid } from './util.js';\nimport Collection from './Collection.js';\nimport CollectionEventType from './CollectionEventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventHandler from './MapBrowserEventHandler.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport MapEvent from './MapEvent.js';\nimport MapEventType from './MapEventType.js';\nimport MapProperty from './MapProperty.js';\nimport RenderEventType from './render/EventType.js';\nimport BaseObject, { getChangeEventType } from './Object.js';\nimport ObjectEventType from './ObjectEventType.js';\nimport TileQueue from './TileQueue.js';\nimport View from './View.js';\nimport ViewHint from './ViewHint.js';\nimport { assert } from './asserts.js';\nimport { removeNode } from './dom.js';\nimport { listen, unlistenByKey, unlisten } from './events.js';\nimport { stopPropagation } from './events/Event.js';\nimport EventType from './events/EventType.js';\nimport { createEmpty, clone, createOrUpdateEmpty, equals, getForViewAndSize, isEmpty } from './extent.js';\nimport { TRUE } from './functions.js';\nimport { DEVICE_PIXEL_RATIO, TOUCH } from './has.js';\nimport LayerGroup from './layer/Group.js';\nimport { hasArea } from './size.js';\nimport { DROP } from './structs/PriorityQueue.js';\nimport { create as createTransform, apply as applyTransform } from './transform.js';\n\n/**\n * State of the current frame. Only `pixelRatio`, `time` and `viewState` should\n * be used in applications.\n * @typedef {Object} FrameState\n * @property {number} pixelRatio The pixel ratio of the frame.\n * @property {number} time The time when rendering of the frame was requested.\n * @property {import(\"./View.js\").State} viewState The state of the current view.\n * @property {boolean} animate\n * @property {import(\"./transform.js\").Transform} coordinateToPixelTransform\n * @property {null|import(\"./extent.js\").Extent} extent\n * @property {import(\"./coordinate.js\").Coordinate} focus\n * @property {number} index\n * @property {Object<string, import(\"./layer/Layer.js\").State>} layerStates\n * @property {Array<import(\"./layer/Layer.js\").State>} layerStatesArray\n * @property {import(\"./transform.js\").Transform} pixelToCoordinateTransform\n * @property {Array<PostRenderFunction>} postRenderFunctions\n * @property {import(\"./size.js\").Size} size\n * @property {!Object<string, boolean>} skippedFeatureUids\n * @property {TileQueue} tileQueue\n * @property {Object<string, Object<string, import(\"./TileRange.js\").default>>} usedTiles\n * @property {Array<number>} viewHints\n * @property {!Object<string, Object<string, boolean>>} wantedTiles\n */\n\n/**\n * @typedef {function(PluggableMap, ?FrameState): boolean} PostRenderFunction\n */\n\n/**\n * @typedef {Object} AtPixelOptions\n * @property {undefined|function(import(\"./layer/Layer.js\").default): boolean} layerFilter Layer filter\n * function. The filter function will receive one argument, the\n * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.\n * Only layers which are visible and for which this function returns `true`\n * will be tested for features. By default, all visible layers will be tested.\n * @property {number} [hitTolerance=0] Hit-detection tolerance in pixels. Pixels\n * inside the radius around the given position will be checked for features. This only\n * works for the canvas renderer and not for WebGL.\n */\n\n/**\n * @typedef {Object} MapOptionsInternal\n * @property {Collection<import(\"./control/Control.js\").default>} [controls]\n * @property {Collection<import(\"./interaction/Interaction.js\").default>} [interactions]\n * @property {HTMLElement|Document} keyboardEventTarget\n * @property {Collection<import(\"./Overlay.js\").default>} overlays\n * @property {Object<string, *>} values\n */\n\n/**\n * Object literal with config options for the map.\n * @typedef {Object} MapOptions\n * @property {Collection<import(\"./control/Control.js\").default>|Array<import(\"./control/Control.js\").default>} [controls]\n * Controls initially added to the map. If not specified,\n * {@link module:ol/control~defaults} is used.\n * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between\n * physical pixels and device-independent pixels (dips) on the device.\n * @property {Collection<import(\"./interaction/Interaction.js\").default>|Array<import(\"./interaction/Interaction.js\").default>} [interactions]\n * Interactions that are initially added to the map. If not specified,\n * {@link module:ol/interaction~defaults} is used.\n * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to\n * listen to keyboard events on. This determines when the `KeyboardPan` and\n * `KeyboardZoom` interactions trigger. For example, if this option is set to\n * `document` the keyboard interactions will always trigger. If this option is\n * not specified, the element the library listens to keyboard events on is the\n * map target (i.e. the user-provided div for the map). If this is not\n * `document`, the target element needs to be focused for key events to be\n * emitted, requiring that the target element has a `tabindex` attribute.\n * @property {Array<import(\"./layer/Base.js\").default>|Collection<import(\"./layer/Base.js\").default>|LayerGroup} [layers]\n * Layers. If this is not defined, a map with no layers will be rendered. Note\n * that layers are rendered in the order supplied, so if you want, for example,\n * a vector layer to appear on top of a tile layer, it must come after the tile\n * layer.\n * @property {number} [maxTilesLoading=16] Maximum number tiles to load\n * simultaneously.\n * @property {boolean} [loadTilesWhileAnimating=false] When set to `true`, tiles\n * will be loaded during animations. This may improve the user experience, but\n * can also make animations stutter on devices with slow memory.\n * @property {boolean} [loadTilesWhileInteracting=false] When set to `true`,\n * tiles will be loaded while interacting with the map. This may improve the\n * user experience, but can also make map panning and zooming choppy on devices\n * with slow memory.\n * @property {number} [moveTolerance=1] The minimum distance in pixels the\n * cursor must move to be detected as a map move event instead of a click.\n * Increasing this value can make it easier to click on the map.\n * @property {Collection<import(\"./Overlay.js\").default>|Array<import(\"./Overlay.js\").default>} [overlays]\n * Overlays initially added to the map. By default, no overlays are added.\n * @property {HTMLElement|string} [target] The container for the map, either the\n * element itself or the `id` of the element. If not specified at construction\n * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be\n * rendered.\n * @property {View} [view] The map's view.  No layer sources will be\n * fetched unless this is specified at construction time or through\n * {@link module:ol/Map~Map#setView}.\n */\n\n/**\n * @fires import(\"./MapBrowserEvent.js\").MapBrowserEvent\n * @fires import(\"./MapEvent.js\").MapEvent\n * @fires module:ol/render/Event~RenderEvent#postcompose\n * @fires module:ol/render/Event~RenderEvent#precompose\n * @fires module:ol/render/Event~RenderEvent#rendercomplete\n * @api\n */\nvar PluggableMap = /*@__PURE__*/function (BaseObject) {\n  function PluggableMap(options) {\n    BaseObject.call(this);\n    var optionsInternal = createOptionsInternal(options);\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.loadTilesWhileAnimating_ = options.loadTilesWhileAnimating !== undefined ? options.loadTilesWhileAnimating : false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.loadTilesWhileInteracting_ = options.loadTilesWhileInteracting !== undefined ? options.loadTilesWhileInteracting : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : DEVICE_PIXEL_RATIO;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.animationDelayKey_;\n\n    /**\n     * @private\n     */\n    this.animationDelay_ = function () {\n      this.animationDelayKey_ = undefined;\n      this.renderFrame_.call(this, Date.now());\n    }.bind(this);\n\n    /**\n     * @private\n     * @type {import(\"./transform.js\").Transform}\n     */\n    this.coordinateToPixelTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {import(\"./transform.js\").Transform}\n     */\n    this.pixelToCoordinateTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.frameIndex_ = 0;\n\n    /**\n     * @private\n     * @type {?FrameState}\n     */\n    this.frameState_ = null;\n\n    /**\n     * The extent at the previous 'moveend' event.\n     * @private\n     * @type {import(\"./extent.js\").Extent}\n     */\n    this.previousExtent_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n    this.viewPropertyListenerKey_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n    this.viewChangeListenerKey_ = null;\n\n    /**\n     * @private\n     * @type {Array<import(\"./events.js\").EventsKey>}\n     */\n    this.layerGroupPropertyListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n    this.viewport_ = document.createElement('div');\n    this.viewport_.className = 'ol-viewport' + (TOUCH ? ' ol-touch' : '');\n    this.viewport_.style.position = 'relative';\n    this.viewport_.style.overflow = 'hidden';\n    this.viewport_.style.width = '100%';\n    this.viewport_.style.height = '100%';\n    // prevent page zoom on IE >= 10 browsers\n    this.viewport_.style.msTouchAction = 'none';\n    this.viewport_.style.touchAction = 'none';\n\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n    this.overlayContainer_ = document.createElement('div');\n    this.overlayContainer_.className = 'ol-overlaycontainer';\n    this.viewport_.appendChild(this.overlayContainer_);\n\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n    this.overlayContainerStopEvent_ = document.createElement('div');\n    this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';\n    var overlayEvents = [EventType.CLICK, EventType.DBLCLICK, EventType.MOUSEDOWN, EventType.TOUCHSTART, EventType.MSPOINTERDOWN, MapBrowserEventType.POINTERDOWN, EventType.MOUSEWHEEL, EventType.WHEEL];\n    for (var i = 0, ii = overlayEvents.length; i < ii; ++i) {\n      listen(this.overlayContainerStopEvent_, overlayEvents[i], stopPropagation);\n    }\n    this.viewport_.appendChild(this.overlayContainerStopEvent_);\n\n    /**\n     * @private\n     * @type {MapBrowserEventHandler}\n     */\n    this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, options.moveTolerance);\n    for (var key in MapBrowserEventType) {\n      listen(this.mapBrowserEventHandler_, MapBrowserEventType[key], this.handleMapBrowserEvent, this);\n    }\n\n    /**\n     * @private\n     * @type {HTMLElement|Document}\n     */\n    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;\n\n    /**\n     * @private\n     * @type {Array<import(\"./events.js\").EventsKey>}\n     */\n    this.keyHandlerKeys_ = null;\n    listen(this.viewport_, EventType.CONTEXTMENU, this.handleBrowserEvent, this);\n    listen(this.viewport_, EventType.WHEEL, this.handleBrowserEvent, this);\n    listen(this.viewport_, EventType.MOUSEWHEEL, this.handleBrowserEvent, this);\n\n    /**\n     * @type {Collection<import(\"./control/Control.js\").default>}\n     * @protected\n     */\n    this.controls = optionsInternal.controls || new Collection();\n\n    /**\n     * @type {Collection<import(\"./interaction/Interaction.js\").default>}\n     * @protected\n     */\n    this.interactions = optionsInternal.interactions || new Collection();\n\n    /**\n     * @type {Collection<import(\"./Overlay.js\").default>}\n     * @private\n     */\n    this.overlays_ = optionsInternal.overlays;\n\n    /**\n     * A lookup of overlays by id.\n     * @private\n     * @type {Object<string, import(\"./Overlay.js\").default>}\n     */\n    this.overlayIdIndex_ = {};\n\n    /**\n     * @type {import(\"./renderer/Map.js\").default}\n     * @private\n     */\n    this.renderer_ = this.createRenderer();\n\n    /**\n     * @type {function(Event)|undefined}\n     * @private\n     */\n    this.handleResize_;\n\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate}\n     */\n    this.focus_ = null;\n\n    /**\n     * @private\n     * @type {!Array<PostRenderFunction>}\n     */\n    this.postRenderFunctions_ = [];\n\n    /**\n     * @private\n     * @type {TileQueue}\n     */\n    this.tileQueue_ = new TileQueue(this.getTilePriority.bind(this), this.handleTileChange_.bind(this));\n\n    /**\n     * Uids of features to skip at rendering time.\n     * @type {Object<string, boolean>}\n     * @private\n     */\n    this.skippedFeatureUids_ = {};\n    listen(this, getChangeEventType(MapProperty.LAYERGROUP), this.handleLayerGroupChanged_, this);\n    listen(this, getChangeEventType(MapProperty.VIEW), this.handleViewChanged_, this);\n    listen(this, getChangeEventType(MapProperty.SIZE), this.handleSizeChanged_, this);\n    listen(this, getChangeEventType(MapProperty.TARGET), this.handleTargetChanged_, this);\n\n    // setProperties will trigger the rendering of the map if the map\n    // is \"defined\" already.\n    this.setProperties(optionsInternal.values);\n    this.controls.forEach(\n    /**\n     * @param {import(\"./control/Control.js\").default} control Control.\n     * @this {PluggableMap}\n     */\n    function (control) {\n      control.setMap(this);\n    }.bind(this));\n    listen(this.controls, CollectionEventType.ADD,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(this);\n    }, this);\n    listen(this.controls, CollectionEventType.REMOVE,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(null);\n    }, this);\n    this.interactions.forEach(\n    /**\n     * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction.\n     * @this {PluggableMap}\n     */\n    function (interaction) {\n      interaction.setMap(this);\n    }.bind(this));\n    listen(this.interactions, CollectionEventType.ADD,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(this);\n    }, this);\n    listen(this.interactions, CollectionEventType.REMOVE,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      event.element.setMap(null);\n    }, this);\n    this.overlays_.forEach(this.addOverlayInternal_.bind(this));\n    listen(this.overlays_, CollectionEventType.ADD,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      this.addOverlayInternal_( /** @type {import(\"./Overlay.js\").default} */event.element);\n    }, this);\n    listen(this.overlays_, CollectionEventType.REMOVE,\n    /**\n     * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n     */\n    function (event) {\n      var overlay = /** @type {import(\"./Overlay.js\").default} */event.element;\n      var id = overlay.getId();\n      if (id !== undefined) {\n        delete this.overlayIdIndex_[id.toString()];\n      }\n      event.element.setMap(null);\n    }, this);\n  }\n  if (BaseObject) PluggableMap.__proto__ = BaseObject;\n  PluggableMap.prototype = Object.create(BaseObject && BaseObject.prototype);\n  PluggableMap.prototype.constructor = PluggableMap;\n\n  /**\n   * @abstract\n   * @return {import(\"./renderer/Map.js\").default} The map renderer\n   */\n  PluggableMap.prototype.createRenderer = function createRenderer() {\n    throw new Error('Use a map type that has a createRenderer method');\n  };\n\n  /**\n   * Add the given control to the map.\n   * @param {import(\"./control/Control.js\").default} control Control.\n   * @api\n   */\n  PluggableMap.prototype.addControl = function addControl(control) {\n    this.getControls().push(control);\n  };\n\n  /**\n   * Add the given interaction to the map.\n   * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to add.\n   * @api\n   */\n  PluggableMap.prototype.addInteraction = function addInteraction(interaction) {\n    this.getInteractions().push(interaction);\n  };\n\n  /**\n   * Adds the given layer to the top of this map. If you want to add a layer\n   * elsewhere in the stack, use `getLayers()` and the methods available on\n   * {@link module:ol/Collection~Collection}.\n   * @param {import(\"./layer/Base.js\").default} layer Layer.\n   * @api\n   */\n  PluggableMap.prototype.addLayer = function addLayer(layer) {\n    var layers = this.getLayerGroup().getLayers();\n    layers.push(layer);\n  };\n\n  /**\n   * Add the given overlay to the map.\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\n   * @api\n   */\n  PluggableMap.prototype.addOverlay = function addOverlay(overlay) {\n    this.getOverlays().push(overlay);\n  };\n\n  /**\n   * This deals with map's overlay collection changes.\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\n   * @private\n   */\n  PluggableMap.prototype.addOverlayInternal_ = function addOverlayInternal_(overlay) {\n    var id = overlay.getId();\n    if (id !== undefined) {\n      this.overlayIdIndex_[id.toString()] = overlay;\n    }\n    overlay.setMap(this);\n  };\n\n  /**\n   *\n   * @inheritDoc\n   */\n  PluggableMap.prototype.disposeInternal = function disposeInternal() {\n    this.mapBrowserEventHandler_.dispose();\n    unlisten(this.viewport_, EventType.CONTEXTMENU, this.handleBrowserEvent, this);\n    unlisten(this.viewport_, EventType.WHEEL, this.handleBrowserEvent, this);\n    unlisten(this.viewport_, EventType.MOUSEWHEEL, this.handleBrowserEvent, this);\n    if (this.handleResize_ !== undefined) {\n      removeEventListener(EventType.RESIZE, this.handleResize_, false);\n      this.handleResize_ = undefined;\n    }\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n      this.animationDelayKey_ = undefined;\n    }\n    this.setTarget(null);\n    BaseObject.prototype.disposeInternal.call(this);\n  };\n\n  /**\n   * Detect features that intersect a pixel on the viewport, and execute a\n   * callback with each intersecting feature. Layers included in the detection can\n   * be configured through the `layerFilter` option in `opt_options`.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {function(this: S, import(\"./Feature.js\").FeatureLike,\n   *     import(\"./layer/Layer.js\").default): T} callback Feature callback. The callback will be\n   *     called with two arguments. The first argument is one\n   *     {@link module:ol/Feature feature} or\n   *     {@link module:ol/render/Feature render feature} at the pixel, the second is\n   *     the {@link module:ol/layer/Layer layer} of the feature and will be null for\n   *     unmanaged layers. To stop detection, callback functions can return a\n   *     truthy value.\n   * @param {AtPixelOptions=} opt_options Optional options.\n   * @return {T|undefined} Callback result, i.e. the return value of last\n   * callback execution, or the first truthy callback return value.\n   * @template S,T\n   * @api\n   */\n  PluggableMap.prototype.forEachFeatureAtPixel = function forEachFeatureAtPixel(pixel, callback, opt_options) {\n    if (!this.frameState_) {\n      return;\n    }\n    var coordinate = this.getCoordinateFromPixel(pixel);\n    opt_options = opt_options !== undefined ? opt_options : /** @type {AtPixelOptions} */{};\n    var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\n    return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, callback, null, layerFilter, null);\n  };\n\n  /**\n   * Get all features that intersect a pixel on the viewport.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {AtPixelOptions=} opt_options Optional options.\n   * @return {Array<import(\"./Feature.js\").FeatureLike>} The detected features or\n   * `null` if none were found.\n   * @api\n   */\n  PluggableMap.prototype.getFeaturesAtPixel = function getFeaturesAtPixel(pixel, opt_options) {\n    var features = null;\n    this.forEachFeatureAtPixel(pixel, function (feature) {\n      if (!features) {\n        features = [];\n      }\n      features.push(feature);\n    }, opt_options);\n    return features;\n  };\n\n  /**\n   * Detect layers that have a color value at a pixel on the viewport, and\n   * execute a callback with each matching layer. Layers included in the\n   * detection can be configured through `opt_layerFilter`.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {function(this: S, import(\"./layer/Layer.js\").default, (Uint8ClampedArray|Uint8Array)): T} callback\n   *     Layer callback. This callback will receive two arguments: first is the\n   *     {@link module:ol/layer/Layer layer}, second argument is an array representing\n   *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types\n   *     that do not currently support this argument. To stop detection, callback\n   *     functions can return a truthy value.\n   * @param {AtPixelOptions=} opt_options Configuration options.\n   * @return {T|undefined} Callback result, i.e. the return value of last\n   * callback execution, or the first truthy callback return value.\n   * @template S,T\n   * @api\n   */\n  PluggableMap.prototype.forEachLayerAtPixel = function forEachLayerAtPixel(pixel, callback, opt_options) {\n    if (!this.frameState_) {\n      return;\n    }\n    var options = opt_options || /** @type {AtPixelOptions} */{};\n    var hitTolerance = options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    var layerFilter = options.layerFilter || TRUE;\n    return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, null, layerFilter, null);\n  };\n\n  /**\n   * Detect if features intersect a pixel on the viewport. Layers included in the\n   * detection can be configured through `opt_layerFilter`.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {AtPixelOptions=} opt_options Optional options.\n   * @return {boolean} Is there a feature at the given pixel?\n   * @template U\n   * @api\n   */\n  PluggableMap.prototype.hasFeatureAtPixel = function hasFeatureAtPixel(pixel, opt_options) {\n    if (!this.frameState_) {\n      return false;\n    }\n    var coordinate = this.getCoordinateFromPixel(pixel);\n    opt_options = opt_options !== undefined ? opt_options : /** @type {AtPixelOptions} */{};\n    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\n    var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, layerFilter, null);\n  };\n\n  /**\n   * Returns the coordinate in view projection for a browser event.\n   * @param {Event} event Event.\n   * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n  PluggableMap.prototype.getEventCoordinate = function getEventCoordinate(event) {\n    return this.getCoordinateFromPixel(this.getEventPixel(event));\n  };\n\n  /**\n   * Returns the map pixel position for a browser event relative to the viewport.\n   * @param {Event|TouchEvent} event Event.\n   * @return {import(\"./pixel.js\").Pixel} Pixel.\n   * @api\n   */\n  PluggableMap.prototype.getEventPixel = function getEventPixel(event) {\n    var viewportPosition = this.viewport_.getBoundingClientRect();\n    var eventPosition = 'changedTouches' in event ? /** @type {TouchEvent} */event.changedTouches[0] : /** @type {MouseEvent} */event;\n    return [eventPosition.clientX - viewportPosition.left, eventPosition.clientY - viewportPosition.top];\n  };\n\n  /**\n   * Get the target in which this map is rendered.\n   * Note that this returns what is entered as an option or in setTarget:\n   * if that was an element, it returns an element; if a string, it returns that.\n   * @return {HTMLElement|string|undefined} The Element or id of the Element that the\n   *     map is rendered in.\n   * @observable\n   * @api\n   */\n  PluggableMap.prototype.getTarget = function getTarget() {\n    return (/** @type {HTMLElement|string|undefined} */this.get(MapProperty.TARGET)\n    );\n  };\n\n  /**\n   * Get the DOM element into which this map is rendered. In contrast to\n   * `getTarget` this method always return an `Element`, or `null` if the\n   * map has no target.\n   * @return {HTMLElement} The element that the map is rendered in.\n   * @api\n   */\n  PluggableMap.prototype.getTargetElement = function getTargetElement() {\n    var target = this.getTarget();\n    if (target !== undefined) {\n      return typeof target === 'string' ? document.getElementById(target) : target;\n    } else {\n      return null;\n    }\n  };\n\n  /**\n   * Get the coordinate for a given pixel.  This returns a coordinate in the\n   * map view projection.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\n   * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\n   * @api\n   */\n  PluggableMap.prototype.getCoordinateFromPixel = function getCoordinateFromPixel(pixel) {\n    var frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    } else {\n      return applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    }\n  };\n\n  /**\n   * Get the map controls. Modifying this collection changes the controls\n   * associated with the map.\n   * @return {Collection<import(\"./control/Control.js\").default>} Controls.\n   * @api\n   */\n  PluggableMap.prototype.getControls = function getControls() {\n    return this.controls;\n  };\n\n  /**\n   * Get the map overlays. Modifying this collection changes the overlays\n   * associated with the map.\n   * @return {Collection<import(\"./Overlay.js\").default>} Overlays.\n   * @api\n   */\n  PluggableMap.prototype.getOverlays = function getOverlays() {\n    return this.overlays_;\n  };\n\n  /**\n   * Get an overlay by its identifier (the value returned by overlay.getId()).\n   * Note that the index treats string and numeric identifiers as the same. So\n   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.\n   * @param {string|number} id Overlay identifier.\n   * @return {import(\"./Overlay.js\").default} Overlay.\n   * @api\n   */\n  PluggableMap.prototype.getOverlayById = function getOverlayById(id) {\n    var overlay = this.overlayIdIndex_[id.toString()];\n    return overlay !== undefined ? overlay : null;\n  };\n\n  /**\n   * Get the map interactions. Modifying this collection changes the interactions\n   * associated with the map.\n   *\n   * Interactions are used for e.g. pan, zoom and rotate.\n   * @return {Collection<import(\"./interaction/Interaction.js\").default>} Interactions.\n   * @api\n   */\n  PluggableMap.prototype.getInteractions = function getInteractions() {\n    return this.interactions;\n  };\n\n  /**\n   * Get the layergroup associated with this map.\n   * @return {LayerGroup} A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n  PluggableMap.prototype.getLayerGroup = function getLayerGroup() {\n    return (/** @type {LayerGroup} */this.get(MapProperty.LAYERGROUP)\n    );\n  };\n\n  /**\n   * Get the collection of layers associated with this map.\n   * @return {!Collection<import(\"./layer/Base.js\").default>} Layers.\n   * @api\n   */\n  PluggableMap.prototype.getLayers = function getLayers() {\n    var layers = this.getLayerGroup().getLayers();\n    return layers;\n  };\n\n  /**\n   * Get the pixel for a coordinate.  This takes a coordinate in the map view\n   * projection and returns the corresponding pixel.\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\n   * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\n   * @api\n   */\n  PluggableMap.prototype.getPixelFromCoordinate = function getPixelFromCoordinate(coordinate) {\n    var frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    } else {\n      return applyTransform(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));\n    }\n  };\n\n  /**\n   * Get the map renderer.\n   * @return {import(\"./renderer/Map.js\").default} Renderer\n   */\n  PluggableMap.prototype.getRenderer = function getRenderer() {\n    return this.renderer_;\n  };\n\n  /**\n   * Get the size of this map.\n   * @return {import(\"./size.js\").Size|undefined} The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n  PluggableMap.prototype.getSize = function getSize() {\n    return (/** @type {import(\"./size.js\").Size|undefined} */this.get(MapProperty.SIZE)\n    );\n  };\n\n  /**\n   * Get the view associated with this map. A view manages properties such as\n   * center and resolution.\n   * @return {View} The view that controls this map.\n   * @observable\n   * @api\n   */\n  PluggableMap.prototype.getView = function getView() {\n    return (/** @type {View} */this.get(MapProperty.VIEW)\n    );\n  };\n\n  /**\n   * Get the element that serves as the map viewport.\n   * @return {HTMLElement} Viewport.\n   * @api\n   */\n  PluggableMap.prototype.getViewport = function getViewport() {\n    return this.viewport_;\n  };\n\n  /**\n   * Get the element that serves as the container for overlays.  Elements added to\n   * this container will let mousedown and touchstart events through to the map,\n   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}\n   * events.\n   * @return {!HTMLElement} The map's overlay container.\n   */\n  PluggableMap.prototype.getOverlayContainer = function getOverlayContainer() {\n    return this.overlayContainer_;\n  };\n\n  /**\n   * Get the element that serves as a container for overlays that don't allow\n   * event propagation. Elements added to this container won't let mousedown and\n   * touchstart events through to the map, so clicks and gestures on an overlay\n   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   * @return {!HTMLElement} The map's overlay container that stops events.\n   */\n  PluggableMap.prototype.getOverlayContainerStopEvent = function getOverlayContainerStopEvent() {\n    return this.overlayContainerStopEvent_;\n  };\n\n  /**\n   * @param {import(\"./Tile.js\").default} tile Tile.\n   * @param {string} tileSourceKey Tile source key.\n   * @param {import(\"./coordinate.js\").Coordinate} tileCenter Tile center.\n   * @param {number} tileResolution Tile resolution.\n   * @return {number} Tile priority.\n   */\n  PluggableMap.prototype.getTilePriority = function getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {\n    // Filter out tiles at higher zoom levels than the current zoom level, or that\n    // are outside the visible extent.\n    var frameState = this.frameState_;\n    if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {\n      return DROP;\n    }\n    if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {\n      return DROP;\n    }\n    // Prioritize the highest zoom level tiles closest to the focus.\n    // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).\n    // Within a zoom level, tiles are prioritized by the distance in pixels\n    // between the center of the tile and the focus.  The factor of 65536 means\n    // that the prioritization should behave as desired for tiles up to\n    // 65536 * Math.log(2) = 45426 pixels from the focus.\n    var deltaX = tileCenter[0] - frameState.focus[0];\n    var deltaY = tileCenter[1] - frameState.focus[1];\n    return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;\n  };\n\n  /**\n   * @param {Event} browserEvent Browser event.\n   * @param {string=} opt_type Type.\n   */\n  PluggableMap.prototype.handleBrowserEvent = function handleBrowserEvent(browserEvent, opt_type) {\n    var type = opt_type || browserEvent.type;\n    var mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);\n    this.handleMapBrowserEvent(mapBrowserEvent);\n  };\n\n  /**\n   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.\n   */\n  PluggableMap.prototype.handleMapBrowserEvent = function handleMapBrowserEvent(mapBrowserEvent) {\n    if (!this.frameState_) {\n      // With no view defined, we cannot translate pixels into geographical\n      // coordinates so interactions cannot be used.\n      return;\n    }\n    this.focus_ = mapBrowserEvent.coordinate;\n    mapBrowserEvent.frameState = this.frameState_;\n    var interactionsArray = this.getInteractions().getArray();\n    if (this.dispatchEvent(mapBrowserEvent) !== false) {\n      for (var i = interactionsArray.length - 1; i >= 0; i--) {\n        var interaction = interactionsArray[i];\n        if (!interaction.getActive()) {\n          continue;\n        }\n        var cont = interaction.handleEvent(mapBrowserEvent);\n        if (!cont) {\n          break;\n        }\n      }\n    }\n  };\n\n  /**\n   * @protected\n   */\n  PluggableMap.prototype.handlePostRender = function handlePostRender() {\n    var frameState = this.frameState_;\n\n    // Manage the tile queue\n    // Image loads are expensive and a limited resource, so try to use them\n    // efficiently:\n    // * When the view is static we allow a large number of parallel tile loads\n    //   to complete the frame as quickly as possible.\n    // * When animating or interacting, image loads can cause janks, so we reduce\n    //   the maximum number of loads per frame and limit the number of parallel\n    //   tile loads to remain reactive to view changes and to reduce the chance of\n    //   loading tiles that will quickly disappear from view.\n    var tileQueue = this.tileQueue_;\n    if (!tileQueue.isEmpty()) {\n      var maxTotalLoading = this.maxTilesLoading_;\n      var maxNewLoads = maxTotalLoading;\n      if (frameState) {\n        var hints = frameState.viewHints;\n        if (hints[ViewHint.ANIMATING]) {\n          maxTotalLoading = this.loadTilesWhileAnimating_ ? 8 : 0;\n          maxNewLoads = 2;\n        }\n        if (hints[ViewHint.INTERACTING]) {\n          maxTotalLoading = this.loadTilesWhileInteracting_ ? 8 : 0;\n          maxNewLoads = 2;\n        }\n      }\n      if (tileQueue.getTilesLoading() < maxTotalLoading) {\n        tileQueue.reprioritize(); // FIXME only call if view has changed\n        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);\n      }\n    }\n    if (frameState && this.hasListener(RenderEventType.RENDERCOMPLETE) && !frameState.animate && !this.tileQueue_.getTilesLoading() && !getLoading(this.getLayers().getArray())) {\n      this.renderer_.dispatchRenderEvent(RenderEventType.RENDERCOMPLETE, frameState);\n    }\n    var postRenderFunctions = this.postRenderFunctions_;\n    for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {\n      postRenderFunctions[i](this, frameState);\n    }\n    postRenderFunctions.length = 0;\n  };\n\n  /**\n   * @private\n   */\n  PluggableMap.prototype.handleSizeChanged_ = function handleSizeChanged_() {\n    this.render();\n  };\n\n  /**\n   * @private\n   */\n  PluggableMap.prototype.handleTargetChanged_ = function handleTargetChanged_() {\n    // target may be undefined, null, a string or an Element.\n    // If it's a string we convert it to an Element before proceeding.\n    // If it's not now an Element we remove the viewport from the DOM.\n    // If it's an Element we append the viewport element to it.\n\n    var targetElement;\n    if (this.getTarget()) {\n      targetElement = this.getTargetElement();\n    }\n    if (this.keyHandlerKeys_) {\n      for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {\n        unlistenByKey(this.keyHandlerKeys_[i]);\n      }\n      this.keyHandlerKeys_ = null;\n    }\n    if (!targetElement) {\n      this.renderer_.removeLayerRenderers();\n      removeNode(this.viewport_);\n      if (this.handleResize_ !== undefined) {\n        removeEventListener(EventType.RESIZE, this.handleResize_, false);\n        this.handleResize_ = undefined;\n      }\n    } else {\n      targetElement.appendChild(this.viewport_);\n      var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;\n      this.keyHandlerKeys_ = [listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this), listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this)];\n      if (!this.handleResize_) {\n        this.handleResize_ = this.updateSize.bind(this);\n        addEventListener(EventType.RESIZE, this.handleResize_, false);\n      }\n    }\n    this.updateSize();\n    // updateSize calls setSize, so no need to call this.render\n    // ourselves here.\n  };\n\n  /**\n   * @private\n   */\n  PluggableMap.prototype.handleTileChange_ = function handleTileChange_() {\n    this.render();\n  };\n\n  /**\n   * @private\n   */\n  PluggableMap.prototype.handleViewPropertyChanged_ = function handleViewPropertyChanged_() {\n    this.render();\n  };\n\n  /**\n   * @private\n   */\n  PluggableMap.prototype.handleViewChanged_ = function handleViewChanged_() {\n    if (this.viewPropertyListenerKey_) {\n      unlistenByKey(this.viewPropertyListenerKey_);\n      this.viewPropertyListenerKey_ = null;\n    }\n    if (this.viewChangeListenerKey_) {\n      unlistenByKey(this.viewChangeListenerKey_);\n      this.viewChangeListenerKey_ = null;\n    }\n    var view = this.getView();\n    if (view) {\n      this.viewport_.setAttribute('data-view', getUid(view));\n      this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);\n      this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);\n    }\n    this.render();\n  };\n\n  /**\n   * @private\n   */\n  PluggableMap.prototype.handleLayerGroupChanged_ = function handleLayerGroupChanged_() {\n    if (this.layerGroupPropertyListenerKeys_) {\n      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);\n      this.layerGroupPropertyListenerKeys_ = null;\n    }\n    var layerGroup = this.getLayerGroup();\n    if (layerGroup) {\n      this.layerGroupPropertyListenerKeys_ = [listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this), listen(layerGroup, EventType.CHANGE, this.render, this)];\n    }\n    this.render();\n  };\n\n  /**\n   * @return {boolean} Is rendered.\n   */\n  PluggableMap.prototype.isRendered = function isRendered() {\n    return !!this.frameState_;\n  };\n\n  /**\n   * Requests an immediate render in a synchronous manner.\n   * @api\n   */\n  PluggableMap.prototype.renderSync = function renderSync() {\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n    }\n    this.animationDelay_();\n  };\n\n  /**\n   * Request a map rendering (at the next animation frame).\n   * @api\n   */\n  PluggableMap.prototype.render = function render() {\n    if (this.animationDelayKey_ === undefined) {\n      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);\n    }\n  };\n\n  /**\n   * Remove the given control from the map.\n   * @param {import(\"./control/Control.js\").default} control Control.\n   * @return {import(\"./control/Control.js\").default|undefined} The removed control (or undefined\n   *     if the control was not found).\n   * @api\n   */\n  PluggableMap.prototype.removeControl = function removeControl(control) {\n    return this.getControls().remove(control);\n  };\n\n  /**\n   * Remove the given interaction from the map.\n   * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to remove.\n   * @return {import(\"./interaction/Interaction.js\").default|undefined} The removed interaction (or\n   *     undefined if the interaction was not found).\n   * @api\n   */\n  PluggableMap.prototype.removeInteraction = function removeInteraction(interaction) {\n    return this.getInteractions().remove(interaction);\n  };\n\n  /**\n   * Removes the given layer from the map.\n   * @param {import(\"./layer/Base.js\").default} layer Layer.\n   * @return {import(\"./layer/Base.js\").default|undefined} The removed layer (or undefined if the\n   *     layer was not found).\n   * @api\n   */\n  PluggableMap.prototype.removeLayer = function removeLayer(layer) {\n    var layers = this.getLayerGroup().getLayers();\n    return layers.remove(layer);\n  };\n\n  /**\n   * Remove the given overlay from the map.\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\n   * @return {import(\"./Overlay.js\").default|undefined} The removed overlay (or undefined\n   *     if the overlay was not found).\n   * @api\n   */\n  PluggableMap.prototype.removeOverlay = function removeOverlay(overlay) {\n    return this.getOverlays().remove(overlay);\n  };\n\n  /**\n   * @param {number} time Time.\n   * @private\n   */\n  PluggableMap.prototype.renderFrame_ = function renderFrame_(time) {\n    var viewState;\n    var size = this.getSize();\n    var view = this.getView();\n    var extent = createEmpty();\n    var previousFrameState = this.frameState_;\n    /** @type {?FrameState} */\n    var frameState = null;\n    if (size !== undefined && hasArea(size) && view && view.isDef()) {\n      var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);\n      var layerStatesArray = this.getLayerGroup().getLayerStatesArray();\n      var layerStates = {};\n      for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n        layerStates[getUid(layerStatesArray[i].layer)] = layerStatesArray[i];\n      }\n      viewState = view.getState(this.pixelRatio_);\n      frameState = /** @type {FrameState} */{\n        animate: false,\n        coordinateToPixelTransform: this.coordinateToPixelTransform_,\n        extent: extent,\n        focus: this.focus_ ? this.focus_ : viewState.center,\n        index: this.frameIndex_++,\n        layerStates: layerStates,\n        layerStatesArray: layerStatesArray,\n        pixelRatio: this.pixelRatio_,\n        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\n        postRenderFunctions: [],\n        size: size,\n        skippedFeatureUids: this.skippedFeatureUids_,\n        tileQueue: this.tileQueue_,\n        time: time,\n        usedTiles: {},\n        viewState: viewState,\n        viewHints: viewHints,\n        wantedTiles: {}\n      };\n    }\n    if (frameState) {\n      frameState.extent = getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, frameState.size, extent);\n    }\n    this.frameState_ = frameState;\n    this.renderer_.renderFrame(frameState);\n    if (frameState) {\n      if (frameState.animate) {\n        this.render();\n      }\n      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);\n      if (previousFrameState) {\n        var moveStart = !this.previousExtent_ || !isEmpty(this.previousExtent_) && !equals(frameState.extent, this.previousExtent_);\n        if (moveStart) {\n          this.dispatchEvent(new MapEvent(MapEventType.MOVESTART, this, previousFrameState));\n          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);\n        }\n      }\n      var idle = this.previousExtent_ && !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING] && !equals(frameState.extent, this.previousExtent_);\n      if (idle) {\n        this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));\n        clone(frameState.extent, this.previousExtent_);\n      }\n    }\n    this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));\n    setTimeout(this.handlePostRender.bind(this), 0);\n  };\n\n  /**\n   * Sets the layergroup of this map.\n   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n  PluggableMap.prototype.setLayerGroup = function setLayerGroup(layerGroup) {\n    this.set(MapProperty.LAYERGROUP, layerGroup);\n  };\n\n  /**\n   * Set the size of this map.\n   * @param {import(\"./size.js\").Size|undefined} size The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n  PluggableMap.prototype.setSize = function setSize(size) {\n    this.set(MapProperty.SIZE, size);\n  };\n\n  /**\n   * Set the target element to render this map into.\n   * @param {HTMLElement|string|undefined} target The Element or id of the Element\n   *     that the map is rendered in.\n   * @observable\n   * @api\n   */\n  PluggableMap.prototype.setTarget = function setTarget(target) {\n    this.set(MapProperty.TARGET, target);\n  };\n\n  /**\n   * Set the view for this map.\n   * @param {View} view The view that controls this map.\n   * @observable\n   * @api\n   */\n  PluggableMap.prototype.setView = function setView(view) {\n    this.set(MapProperty.VIEW, view);\n  };\n\n  /**\n   * @param {import(\"./Feature.js\").default} feature Feature.\n   */\n  PluggableMap.prototype.skipFeature = function skipFeature(feature) {\n    this.skippedFeatureUids_[getUid(feature)] = true;\n    this.render();\n  };\n\n  /**\n   * Force a recalculation of the map viewport size.  This should be called when\n   * third-party code changes the size of the map viewport.\n   * @api\n   */\n  PluggableMap.prototype.updateSize = function updateSize() {\n    var targetElement = this.getTargetElement();\n    if (!targetElement) {\n      this.setSize(undefined);\n    } else {\n      var computedStyle = getComputedStyle(targetElement);\n      this.setSize([targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']), targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth'])]);\n    }\n  };\n\n  /**\n   * @param {import(\"./Feature.js\").default} feature Feature.\n   */\n  PluggableMap.prototype.unskipFeature = function unskipFeature(feature) {\n    delete this.skippedFeatureUids_[getUid(feature)];\n    this.render();\n  };\n  return PluggableMap;\n}(BaseObject);\n\n/**\n * @param {MapOptions} options Map options.\n * @return {MapOptionsInternal} Internal map options.\n */\nfunction createOptionsInternal(options) {\n  /**\n   * @type {HTMLElement|Document}\n   */\n  var keyboardEventTarget = null;\n  if (options.keyboardEventTarget !== undefined) {\n    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;\n  }\n\n  /**\n   * @type {Object<string, *>}\n   */\n  var values = {};\n  var layerGroup = options.layers && typeof /** @type {?} */options.layers.getLayers === 'function' ? /** @type {LayerGroup} */options.layers : new LayerGroup({\n    layers: /** @type {Collection} */options.layers\n  });\n  values[MapProperty.LAYERGROUP] = layerGroup;\n  values[MapProperty.TARGET] = options.target;\n  values[MapProperty.VIEW] = options.view !== undefined ? options.view : new View();\n  var controls;\n  if (options.controls !== undefined) {\n    if (Array.isArray(options.controls)) {\n      controls = new Collection(options.controls.slice());\n    } else {\n      assert(typeof /** @type {?} */options.controls.getArray === 'function', 47); // Expected `controls` to be an array or an `import(\"./Collection.js\").Collection`\n      controls = /** @type {Collection} */options.controls;\n    }\n  }\n  var interactions;\n  if (options.interactions !== undefined) {\n    if (Array.isArray(options.interactions)) {\n      interactions = new Collection(options.interactions.slice());\n    } else {\n      assert(typeof /** @type {?} */options.interactions.getArray === 'function', 48); // Expected `interactions` to be an array or an `import(\"./Collection.js\").Collection`\n      interactions = /** @type {Collection} */options.interactions;\n    }\n  }\n  var overlays;\n  if (options.overlays !== undefined) {\n    if (Array.isArray(options.overlays)) {\n      overlays = new Collection(options.overlays.slice());\n    } else {\n      assert(typeof /** @type {?} */options.overlays.getArray === 'function', 49); // Expected `overlays` to be an array or an `import(\"./Collection.js\").Collection`\n      overlays = options.overlays;\n    }\n  } else {\n    overlays = new Collection();\n  }\n  return {\n    controls: controls,\n    interactions: interactions,\n    keyboardEventTarget: keyboardEventTarget,\n    overlays: overlays,\n    values: values\n  };\n}\nexport default PluggableMap;\n\n/**\n * @param  {Array<import(\"./layer/Base.js\").default>} layers Layers.\n * @return {boolean} Layers have sources that are still loading.\n */\nfunction getLoading(layers) {\n  for (var i = 0, ii = layers.length; i < ii; ++i) {\n    var layer = layers[i];\n    if (typeof /** @type {?} */layer.getLayers === 'function') {\n      return getLoading( /** @type {LayerGroup} */layer.getLayers().getArray());\n    } else {\n      var source = /** @type {import(\"./layer/Layer.js\").default} */layer.getSource();\n      if (source && source.loading) {\n        return true;\n      }\n    }\n  }\n  return false;\n}","map":{"version":3,"names":["getUid","Collection","CollectionEventType","MapBrowserEvent","MapBrowserEventHandler","MapBrowserEventType","MapEvent","MapEventType","MapProperty","RenderEventType","BaseObject","getChangeEventType","ObjectEventType","TileQueue","View","ViewHint","assert","removeNode","listen","unlistenByKey","unlisten","stopPropagation","EventType","createEmpty","clone","createOrUpdateEmpty","equals","getForViewAndSize","isEmpty","TRUE","DEVICE_PIXEL_RATIO","TOUCH","LayerGroup","hasArea","DROP","create","createTransform","apply","applyTransform","PluggableMap","options","call","optionsInternal","createOptionsInternal","maxTilesLoading_","maxTilesLoading","undefined","loadTilesWhileAnimating_","loadTilesWhileAnimating","loadTilesWhileInteracting_","loadTilesWhileInteracting","pixelRatio_","pixelRatio","animationDelayKey_","animationDelay_","renderFrame_","Date","now","bind","coordinateToPixelTransform_","pixelToCoordinateTransform_","frameIndex_","frameState_","previousExtent_","viewPropertyListenerKey_","viewChangeListenerKey_","layerGroupPropertyListenerKeys_","viewport_","document","createElement","className","style","position","overflow","width","height","msTouchAction","touchAction","overlayContainer_","appendChild","overlayContainerStopEvent_","overlayEvents","CLICK","DBLCLICK","MOUSEDOWN","TOUCHSTART","MSPOINTERDOWN","POINTERDOWN","MOUSEWHEEL","WHEEL","i","ii","length","mapBrowserEventHandler_","moveTolerance","key","handleMapBrowserEvent","keyboardEventTarget_","keyboardEventTarget","keyHandlerKeys_","CONTEXTMENU","handleBrowserEvent","controls","interactions","overlays_","overlays","overlayIdIndex_","renderer_","createRenderer","handleResize_","focus_","postRenderFunctions_","tileQueue_","getTilePriority","handleTileChange_","skippedFeatureUids_","LAYERGROUP","handleLayerGroupChanged_","VIEW","handleViewChanged_","SIZE","handleSizeChanged_","TARGET","handleTargetChanged_","setProperties","values","forEach","control","setMap","ADD","event","element","REMOVE","interaction","addOverlayInternal_","overlay","id","getId","toString","Error","addControl","getControls","push","addInteraction","getInteractions","addLayer","layer","layers","getLayerGroup","getLayers","addOverlay","getOverlays","disposeInternal","dispose","removeEventListener","RESIZE","cancelAnimationFrame","setTarget","prototype","forEachFeatureAtPixel","pixel","callback","opt_options","coordinate","getCoordinateFromPixel","hitTolerance","layerFilter","forEachFeatureAtCoordinate","getFeaturesAtPixel","features","feature","forEachLayerAtPixel","hasFeatureAtPixel","hasFeatureAtCoordinate","getEventCoordinate","getEventPixel","viewportPosition","getBoundingClientRect","eventPosition","changedTouches","clientX","left","clientY","top","getTarget","get","getTargetElement","target","getElementById","frameState","pixelToCoordinateTransform","slice","getOverlayById","getPixelFromCoordinate","coordinateToPixelTransform","getRenderer","getSize","getView","getViewport","getOverlayContainer","getOverlayContainerStopEvent","tile","tileSourceKey","tileCenter","tileResolution","wantedTiles","getKey","deltaX","focus","deltaY","Math","log","sqrt","browserEvent","opt_type","type","mapBrowserEvent","interactionsArray","getArray","dispatchEvent","getActive","cont","handleEvent","handlePostRender","tileQueue","maxTotalLoading","maxNewLoads","hints","viewHints","ANIMATING","INTERACTING","getTilesLoading","reprioritize","loadMoreTiles","hasListener","RENDERCOMPLETE","animate","getLoading","dispatchRenderEvent","postRenderFunctions","render","targetElement","removeLayerRenderers","KEYDOWN","KEYPRESS","updateSize","addEventListener","handleViewPropertyChanged_","view","setAttribute","PROPERTYCHANGE","CHANGE","layerGroup","isRendered","renderSync","requestAnimationFrame","removeControl","remove","removeInteraction","removeLayer","removeOverlay","time","viewState","size","extent","previousFrameState","isDef","getHints","layerStatesArray","getLayerStatesArray","layerStates","getState","center","index","skippedFeatureUids","usedTiles","resolution","rotation","renderFrame","Array","moveStart","MOVESTART","idle","MOVEEND","POSTRENDER","setTimeout","setLayerGroup","set","setSize","setView","skipFeature","computedStyle","getComputedStyle","offsetWidth","parseFloat","offsetHeight","unskipFeature","isArray","source","getSource","loading"],"sources":["../../src/ol/PluggableMap.js"],"sourcesContent":["/**\n * @module ol/PluggableMap\n */\nimport {getUid} from './util.js';\nimport Collection from './Collection.js';\nimport CollectionEventType from './CollectionEventType.js';\nimport MapBrowserEvent from './MapBrowserEvent.js';\nimport MapBrowserEventHandler from './MapBrowserEventHandler.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport MapEvent from './MapEvent.js';\nimport MapEventType from './MapEventType.js';\nimport MapProperty from './MapProperty.js';\nimport RenderEventType from './render/EventType.js';\nimport BaseObject, {getChangeEventType} from './Object.js';\nimport ObjectEventType from './ObjectEventType.js';\nimport TileQueue from './TileQueue.js';\nimport View from './View.js';\nimport ViewHint from './ViewHint.js';\nimport {assert} from './asserts.js';\nimport {removeNode} from './dom.js';\nimport {listen, unlistenByKey, unlisten} from './events.js';\nimport {stopPropagation} from './events/Event.js';\nimport EventType from './events/EventType.js';\nimport {createEmpty, clone, createOrUpdateEmpty, equals, getForViewAndSize, isEmpty} from './extent.js';\nimport {TRUE} from './functions.js';\nimport {DEVICE_PIXEL_RATIO, TOUCH} from './has.js';\nimport LayerGroup from './layer/Group.js';\nimport {hasArea} from './size.js';\nimport {DROP} from './structs/PriorityQueue.js';\nimport {create as createTransform, apply as applyTransform} from './transform.js';\n\n\n/**\n * State of the current frame. Only `pixelRatio`, `time` and `viewState` should\n * be used in applications.\n * @typedef {Object} FrameState\n * @property {number} pixelRatio The pixel ratio of the frame.\n * @property {number} time The time when rendering of the frame was requested.\n * @property {import(\"./View.js\").State} viewState The state of the current view.\n * @property {boolean} animate\n * @property {import(\"./transform.js\").Transform} coordinateToPixelTransform\n * @property {null|import(\"./extent.js\").Extent} extent\n * @property {import(\"./coordinate.js\").Coordinate} focus\n * @property {number} index\n * @property {Object<string, import(\"./layer/Layer.js\").State>} layerStates\n * @property {Array<import(\"./layer/Layer.js\").State>} layerStatesArray\n * @property {import(\"./transform.js\").Transform} pixelToCoordinateTransform\n * @property {Array<PostRenderFunction>} postRenderFunctions\n * @property {import(\"./size.js\").Size} size\n * @property {!Object<string, boolean>} skippedFeatureUids\n * @property {TileQueue} tileQueue\n * @property {Object<string, Object<string, import(\"./TileRange.js\").default>>} usedTiles\n * @property {Array<number>} viewHints\n * @property {!Object<string, Object<string, boolean>>} wantedTiles\n */\n\n\n/**\n * @typedef {function(PluggableMap, ?FrameState): boolean} PostRenderFunction\n */\n\n\n/**\n * @typedef {Object} AtPixelOptions\n * @property {undefined|function(import(\"./layer/Layer.js\").default): boolean} layerFilter Layer filter\n * function. The filter function will receive one argument, the\n * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.\n * Only layers which are visible and for which this function returns `true`\n * will be tested for features. By default, all visible layers will be tested.\n * @property {number} [hitTolerance=0] Hit-detection tolerance in pixels. Pixels\n * inside the radius around the given position will be checked for features. This only\n * works for the canvas renderer and not for WebGL.\n */\n\n\n/**\n * @typedef {Object} MapOptionsInternal\n * @property {Collection<import(\"./control/Control.js\").default>} [controls]\n * @property {Collection<import(\"./interaction/Interaction.js\").default>} [interactions]\n * @property {HTMLElement|Document} keyboardEventTarget\n * @property {Collection<import(\"./Overlay.js\").default>} overlays\n * @property {Object<string, *>} values\n */\n\n\n/**\n * Object literal with config options for the map.\n * @typedef {Object} MapOptions\n * @property {Collection<import(\"./control/Control.js\").default>|Array<import(\"./control/Control.js\").default>} [controls]\n * Controls initially added to the map. If not specified,\n * {@link module:ol/control~defaults} is used.\n * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between\n * physical pixels and device-independent pixels (dips) on the device.\n * @property {Collection<import(\"./interaction/Interaction.js\").default>|Array<import(\"./interaction/Interaction.js\").default>} [interactions]\n * Interactions that are initially added to the map. If not specified,\n * {@link module:ol/interaction~defaults} is used.\n * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to\n * listen to keyboard events on. This determines when the `KeyboardPan` and\n * `KeyboardZoom` interactions trigger. For example, if this option is set to\n * `document` the keyboard interactions will always trigger. If this option is\n * not specified, the element the library listens to keyboard events on is the\n * map target (i.e. the user-provided div for the map). If this is not\n * `document`, the target element needs to be focused for key events to be\n * emitted, requiring that the target element has a `tabindex` attribute.\n * @property {Array<import(\"./layer/Base.js\").default>|Collection<import(\"./layer/Base.js\").default>|LayerGroup} [layers]\n * Layers. If this is not defined, a map with no layers will be rendered. Note\n * that layers are rendered in the order supplied, so if you want, for example,\n * a vector layer to appear on top of a tile layer, it must come after the tile\n * layer.\n * @property {number} [maxTilesLoading=16] Maximum number tiles to load\n * simultaneously.\n * @property {boolean} [loadTilesWhileAnimating=false] When set to `true`, tiles\n * will be loaded during animations. This may improve the user experience, but\n * can also make animations stutter on devices with slow memory.\n * @property {boolean} [loadTilesWhileInteracting=false] When set to `true`,\n * tiles will be loaded while interacting with the map. This may improve the\n * user experience, but can also make map panning and zooming choppy on devices\n * with slow memory.\n * @property {number} [moveTolerance=1] The minimum distance in pixels the\n * cursor must move to be detected as a map move event instead of a click.\n * Increasing this value can make it easier to click on the map.\n * @property {Collection<import(\"./Overlay.js\").default>|Array<import(\"./Overlay.js\").default>} [overlays]\n * Overlays initially added to the map. By default, no overlays are added.\n * @property {HTMLElement|string} [target] The container for the map, either the\n * element itself or the `id` of the element. If not specified at construction\n * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be\n * rendered.\n * @property {View} [view] The map's view.  No layer sources will be\n * fetched unless this is specified at construction time or through\n * {@link module:ol/Map~Map#setView}.\n */\n\n\n/**\n * @fires import(\"./MapBrowserEvent.js\").MapBrowserEvent\n * @fires import(\"./MapEvent.js\").MapEvent\n * @fires module:ol/render/Event~RenderEvent#postcompose\n * @fires module:ol/render/Event~RenderEvent#precompose\n * @fires module:ol/render/Event~RenderEvent#rendercomplete\n * @api\n */\nclass PluggableMap extends BaseObject {\n\n  /**\n   * @param {MapOptions} options Map options.\n   */\n  constructor(options) {\n\n    super();\n\n    const optionsInternal = createOptionsInternal(options);\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.loadTilesWhileAnimating_ =\n        options.loadTilesWhileAnimating !== undefined ?\n          options.loadTilesWhileAnimating : false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.loadTilesWhileInteracting_ =\n        options.loadTilesWhileInteracting !== undefined ?\n          options.loadTilesWhileInteracting : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = options.pixelRatio !== undefined ?\n      options.pixelRatio : DEVICE_PIXEL_RATIO;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.animationDelayKey_;\n\n    /**\n     * @private\n     */\n    this.animationDelay_ = function() {\n      this.animationDelayKey_ = undefined;\n      this.renderFrame_.call(this, Date.now());\n    }.bind(this);\n\n    /**\n     * @private\n     * @type {import(\"./transform.js\").Transform}\n     */\n    this.coordinateToPixelTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {import(\"./transform.js\").Transform}\n     */\n    this.pixelToCoordinateTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.frameIndex_ = 0;\n\n    /**\n     * @private\n     * @type {?FrameState}\n     */\n    this.frameState_ = null;\n\n    /**\n     * The extent at the previous 'moveend' event.\n     * @private\n     * @type {import(\"./extent.js\").Extent}\n     */\n    this.previousExtent_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n    this.viewPropertyListenerKey_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n    this.viewChangeListenerKey_ = null;\n\n    /**\n     * @private\n     * @type {Array<import(\"./events.js\").EventsKey>}\n     */\n    this.layerGroupPropertyListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n    this.viewport_ = document.createElement('div');\n    this.viewport_.className = 'ol-viewport' + (TOUCH ? ' ol-touch' : '');\n    this.viewport_.style.position = 'relative';\n    this.viewport_.style.overflow = 'hidden';\n    this.viewport_.style.width = '100%';\n    this.viewport_.style.height = '100%';\n    // prevent page zoom on IE >= 10 browsers\n    this.viewport_.style.msTouchAction = 'none';\n    this.viewport_.style.touchAction = 'none';\n\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n    this.overlayContainer_ = document.createElement('div');\n    this.overlayContainer_.className = 'ol-overlaycontainer';\n    this.viewport_.appendChild(this.overlayContainer_);\n\n    /**\n     * @private\n     * @type {!HTMLElement}\n     */\n    this.overlayContainerStopEvent_ = document.createElement('div');\n    this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';\n    const overlayEvents = [\n      EventType.CLICK,\n      EventType.DBLCLICK,\n      EventType.MOUSEDOWN,\n      EventType.TOUCHSTART,\n      EventType.MSPOINTERDOWN,\n      MapBrowserEventType.POINTERDOWN,\n      EventType.MOUSEWHEEL,\n      EventType.WHEEL\n    ];\n    for (let i = 0, ii = overlayEvents.length; i < ii; ++i) {\n      listen(this.overlayContainerStopEvent_, overlayEvents[i], stopPropagation);\n    }\n    this.viewport_.appendChild(this.overlayContainerStopEvent_);\n\n    /**\n     * @private\n     * @type {MapBrowserEventHandler}\n     */\n    this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, options.moveTolerance);\n    for (const key in MapBrowserEventType) {\n      listen(this.mapBrowserEventHandler_, MapBrowserEventType[key],\n        this.handleMapBrowserEvent, this);\n    }\n\n    /**\n     * @private\n     * @type {HTMLElement|Document}\n     */\n    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;\n\n    /**\n     * @private\n     * @type {Array<import(\"./events.js\").EventsKey>}\n     */\n    this.keyHandlerKeys_ = null;\n\n    listen(this.viewport_, EventType.CONTEXTMENU, this.handleBrowserEvent, this);\n    listen(this.viewport_, EventType.WHEEL, this.handleBrowserEvent, this);\n    listen(this.viewport_, EventType.MOUSEWHEEL, this.handleBrowserEvent, this);\n\n    /**\n     * @type {Collection<import(\"./control/Control.js\").default>}\n     * @protected\n     */\n    this.controls = optionsInternal.controls || new Collection();\n\n    /**\n     * @type {Collection<import(\"./interaction/Interaction.js\").default>}\n     * @protected\n     */\n    this.interactions = optionsInternal.interactions || new Collection();\n\n    /**\n     * @type {Collection<import(\"./Overlay.js\").default>}\n     * @private\n     */\n    this.overlays_ = optionsInternal.overlays;\n\n    /**\n     * A lookup of overlays by id.\n     * @private\n     * @type {Object<string, import(\"./Overlay.js\").default>}\n     */\n    this.overlayIdIndex_ = {};\n\n    /**\n     * @type {import(\"./renderer/Map.js\").default}\n     * @private\n     */\n    this.renderer_ = this.createRenderer();\n\n    /**\n     * @type {function(Event)|undefined}\n     * @private\n     */\n    this.handleResize_;\n\n    /**\n     * @private\n     * @type {import(\"./coordinate.js\").Coordinate}\n     */\n    this.focus_ = null;\n\n    /**\n     * @private\n     * @type {!Array<PostRenderFunction>}\n     */\n    this.postRenderFunctions_ = [];\n\n    /**\n     * @private\n     * @type {TileQueue}\n     */\n    this.tileQueue_ = new TileQueue(\n      this.getTilePriority.bind(this),\n      this.handleTileChange_.bind(this));\n\n    /**\n     * Uids of features to skip at rendering time.\n     * @type {Object<string, boolean>}\n     * @private\n     */\n    this.skippedFeatureUids_ = {};\n\n    listen(\n      this, getChangeEventType(MapProperty.LAYERGROUP),\n      this.handleLayerGroupChanged_, this);\n    listen(this, getChangeEventType(MapProperty.VIEW),\n      this.handleViewChanged_, this);\n    listen(this, getChangeEventType(MapProperty.SIZE),\n      this.handleSizeChanged_, this);\n    listen(this, getChangeEventType(MapProperty.TARGET),\n      this.handleTargetChanged_, this);\n\n    // setProperties will trigger the rendering of the map if the map\n    // is \"defined\" already.\n    this.setProperties(optionsInternal.values);\n\n    this.controls.forEach(\n      /**\n       * @param {import(\"./control/Control.js\").default} control Control.\n       * @this {PluggableMap}\n       */\n      (function(control) {\n        control.setMap(this);\n      }).bind(this));\n\n    listen(this.controls, CollectionEventType.ADD,\n      /**\n       * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n       */\n      function(event) {\n        event.element.setMap(this);\n      }, this);\n\n    listen(this.controls, CollectionEventType.REMOVE,\n      /**\n       * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n       */\n      function(event) {\n        event.element.setMap(null);\n      }, this);\n\n    this.interactions.forEach(\n      /**\n       * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction.\n       * @this {PluggableMap}\n       */\n      (function(interaction) {\n        interaction.setMap(this);\n      }).bind(this));\n\n    listen(this.interactions, CollectionEventType.ADD,\n      /**\n       * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n       */\n      function(event) {\n        event.element.setMap(this);\n      }, this);\n\n    listen(this.interactions, CollectionEventType.REMOVE,\n      /**\n       * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n       */\n      function(event) {\n        event.element.setMap(null);\n      }, this);\n\n    this.overlays_.forEach(this.addOverlayInternal_.bind(this));\n\n    listen(this.overlays_, CollectionEventType.ADD,\n      /**\n       * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n       */\n      function(event) {\n        this.addOverlayInternal_(/** @type {import(\"./Overlay.js\").default} */ (event.element));\n      }, this);\n\n    listen(this.overlays_, CollectionEventType.REMOVE,\n      /**\n       * @param {import(\"./Collection.js\").CollectionEvent} event CollectionEvent.\n       */\n      function(event) {\n        const overlay = /** @type {import(\"./Overlay.js\").default} */ (event.element);\n        const id = overlay.getId();\n        if (id !== undefined) {\n          delete this.overlayIdIndex_[id.toString()];\n        }\n        event.element.setMap(null);\n      }, this);\n\n  }\n\n  /**\n   * @abstract\n   * @return {import(\"./renderer/Map.js\").default} The map renderer\n   */\n  createRenderer() {\n    throw new Error('Use a map type that has a createRenderer method');\n  }\n\n  /**\n   * Add the given control to the map.\n   * @param {import(\"./control/Control.js\").default} control Control.\n   * @api\n   */\n  addControl(control) {\n    this.getControls().push(control);\n  }\n\n  /**\n   * Add the given interaction to the map.\n   * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to add.\n   * @api\n   */\n  addInteraction(interaction) {\n    this.getInteractions().push(interaction);\n  }\n\n  /**\n   * Adds the given layer to the top of this map. If you want to add a layer\n   * elsewhere in the stack, use `getLayers()` and the methods available on\n   * {@link module:ol/Collection~Collection}.\n   * @param {import(\"./layer/Base.js\").default} layer Layer.\n   * @api\n   */\n  addLayer(layer) {\n    const layers = this.getLayerGroup().getLayers();\n    layers.push(layer);\n  }\n\n  /**\n   * Add the given overlay to the map.\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\n   * @api\n   */\n  addOverlay(overlay) {\n    this.getOverlays().push(overlay);\n  }\n\n  /**\n   * This deals with map's overlay collection changes.\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\n   * @private\n   */\n  addOverlayInternal_(overlay) {\n    const id = overlay.getId();\n    if (id !== undefined) {\n      this.overlayIdIndex_[id.toString()] = overlay;\n    }\n    overlay.setMap(this);\n  }\n\n  /**\n   *\n   * @inheritDoc\n   */\n  disposeInternal() {\n    this.mapBrowserEventHandler_.dispose();\n    unlisten(this.viewport_, EventType.CONTEXTMENU, this.handleBrowserEvent, this);\n    unlisten(this.viewport_, EventType.WHEEL, this.handleBrowserEvent, this);\n    unlisten(this.viewport_, EventType.MOUSEWHEEL, this.handleBrowserEvent, this);\n    if (this.handleResize_ !== undefined) {\n      removeEventListener(EventType.RESIZE, this.handleResize_, false);\n      this.handleResize_ = undefined;\n    }\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n      this.animationDelayKey_ = undefined;\n    }\n    this.setTarget(null);\n    super.disposeInternal();\n  }\n\n  /**\n   * Detect features that intersect a pixel on the viewport, and execute a\n   * callback with each intersecting feature. Layers included in the detection can\n   * be configured through the `layerFilter` option in `opt_options`.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {function(this: S, import(\"./Feature.js\").FeatureLike,\n   *     import(\"./layer/Layer.js\").default): T} callback Feature callback. The callback will be\n   *     called with two arguments. The first argument is one\n   *     {@link module:ol/Feature feature} or\n   *     {@link module:ol/render/Feature render feature} at the pixel, the second is\n   *     the {@link module:ol/layer/Layer layer} of the feature and will be null for\n   *     unmanaged layers. To stop detection, callback functions can return a\n   *     truthy value.\n   * @param {AtPixelOptions=} opt_options Optional options.\n   * @return {T|undefined} Callback result, i.e. the return value of last\n   * callback execution, or the first truthy callback return value.\n   * @template S,T\n   * @api\n   */\n  forEachFeatureAtPixel(pixel, callback, opt_options) {\n    if (!this.frameState_) {\n      return;\n    }\n    const coordinate = this.getCoordinateFromPixel(pixel);\n    opt_options = opt_options !== undefined ? opt_options :\n      /** @type {AtPixelOptions} */ ({});\n    const hitTolerance = opt_options.hitTolerance !== undefined ?\n      opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    const layerFilter = opt_options.layerFilter !== undefined ?\n      opt_options.layerFilter : TRUE;\n    return this.renderer_.forEachFeatureAtCoordinate(\n      coordinate, this.frameState_, hitTolerance, callback, null,\n      layerFilter, null);\n  }\n\n  /**\n   * Get all features that intersect a pixel on the viewport.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {AtPixelOptions=} opt_options Optional options.\n   * @return {Array<import(\"./Feature.js\").FeatureLike>} The detected features or\n   * `null` if none were found.\n   * @api\n   */\n  getFeaturesAtPixel(pixel, opt_options) {\n    let features = null;\n    this.forEachFeatureAtPixel(pixel, function(feature) {\n      if (!features) {\n        features = [];\n      }\n      features.push(feature);\n    }, opt_options);\n    return features;\n  }\n\n  /**\n   * Detect layers that have a color value at a pixel on the viewport, and\n   * execute a callback with each matching layer. Layers included in the\n   * detection can be configured through `opt_layerFilter`.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {function(this: S, import(\"./layer/Layer.js\").default, (Uint8ClampedArray|Uint8Array)): T} callback\n   *     Layer callback. This callback will receive two arguments: first is the\n   *     {@link module:ol/layer/Layer layer}, second argument is an array representing\n   *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types\n   *     that do not currently support this argument. To stop detection, callback\n   *     functions can return a truthy value.\n   * @param {AtPixelOptions=} opt_options Configuration options.\n   * @return {T|undefined} Callback result, i.e. the return value of last\n   * callback execution, or the first truthy callback return value.\n   * @template S,T\n   * @api\n   */\n  forEachLayerAtPixel(pixel, callback, opt_options) {\n    if (!this.frameState_) {\n      return;\n    }\n    const options = opt_options || /** @type {AtPixelOptions} */ ({});\n    const hitTolerance = options.hitTolerance !== undefined ?\n      opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    const layerFilter = options.layerFilter || TRUE;\n    return this.renderer_.forEachLayerAtPixel(\n      pixel, this.frameState_, hitTolerance, callback, null, layerFilter, null);\n  }\n\n  /**\n   * Detect if features intersect a pixel on the viewport. Layers included in the\n   * detection can be configured through `opt_layerFilter`.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel.\n   * @param {AtPixelOptions=} opt_options Optional options.\n   * @return {boolean} Is there a feature at the given pixel?\n   * @template U\n   * @api\n   */\n  hasFeatureAtPixel(pixel, opt_options) {\n    if (!this.frameState_) {\n      return false;\n    }\n    const coordinate = this.getCoordinateFromPixel(pixel);\n    opt_options = opt_options !== undefined ? opt_options :\n      /** @type {AtPixelOptions} */ ({});\n    const layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;\n    const hitTolerance = opt_options.hitTolerance !== undefined ?\n      opt_options.hitTolerance * this.frameState_.pixelRatio : 0;\n    return this.renderer_.hasFeatureAtCoordinate(\n      coordinate, this.frameState_, hitTolerance, layerFilter, null);\n  }\n\n  /**\n   * Returns the coordinate in view projection for a browser event.\n   * @param {Event} event Event.\n   * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n  getEventCoordinate(event) {\n    return this.getCoordinateFromPixel(this.getEventPixel(event));\n  }\n\n  /**\n   * Returns the map pixel position for a browser event relative to the viewport.\n   * @param {Event|TouchEvent} event Event.\n   * @return {import(\"./pixel.js\").Pixel} Pixel.\n   * @api\n   */\n  getEventPixel(event) {\n    const viewportPosition = this.viewport_.getBoundingClientRect();\n    const eventPosition = 'changedTouches' in event ?\n      /** @type {TouchEvent} */ (event).changedTouches[0] :\n      /** @type {MouseEvent} */ (event);\n\n    return [\n      eventPosition.clientX - viewportPosition.left,\n      eventPosition.clientY - viewportPosition.top\n    ];\n  }\n\n  /**\n   * Get the target in which this map is rendered.\n   * Note that this returns what is entered as an option or in setTarget:\n   * if that was an element, it returns an element; if a string, it returns that.\n   * @return {HTMLElement|string|undefined} The Element or id of the Element that the\n   *     map is rendered in.\n   * @observable\n   * @api\n   */\n  getTarget() {\n    return /** @type {HTMLElement|string|undefined} */ (this.get(MapProperty.TARGET));\n  }\n\n  /**\n   * Get the DOM element into which this map is rendered. In contrast to\n   * `getTarget` this method always return an `Element`, or `null` if the\n   * map has no target.\n   * @return {HTMLElement} The element that the map is rendered in.\n   * @api\n   */\n  getTargetElement() {\n    const target = this.getTarget();\n    if (target !== undefined) {\n      return typeof target === 'string' ? document.getElementById(target) : target;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get the coordinate for a given pixel.  This returns a coordinate in the\n   * map view projection.\n   * @param {import(\"./pixel.js\").Pixel} pixel Pixel position in the map viewport.\n   * @return {import(\"./coordinate.js\").Coordinate} The coordinate for the pixel position.\n   * @api\n   */\n  getCoordinateFromPixel(pixel) {\n    const frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    } else {\n      return applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    }\n  }\n\n  /**\n   * Get the map controls. Modifying this collection changes the controls\n   * associated with the map.\n   * @return {Collection<import(\"./control/Control.js\").default>} Controls.\n   * @api\n   */\n  getControls() {\n    return this.controls;\n  }\n\n  /**\n   * Get the map overlays. Modifying this collection changes the overlays\n   * associated with the map.\n   * @return {Collection<import(\"./Overlay.js\").default>} Overlays.\n   * @api\n   */\n  getOverlays() {\n    return this.overlays_;\n  }\n\n  /**\n   * Get an overlay by its identifier (the value returned by overlay.getId()).\n   * Note that the index treats string and numeric identifiers as the same. So\n   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.\n   * @param {string|number} id Overlay identifier.\n   * @return {import(\"./Overlay.js\").default} Overlay.\n   * @api\n   */\n  getOverlayById(id) {\n    const overlay = this.overlayIdIndex_[id.toString()];\n    return overlay !== undefined ? overlay : null;\n  }\n\n  /**\n   * Get the map interactions. Modifying this collection changes the interactions\n   * associated with the map.\n   *\n   * Interactions are used for e.g. pan, zoom and rotate.\n   * @return {Collection<import(\"./interaction/Interaction.js\").default>} Interactions.\n   * @api\n   */\n  getInteractions() {\n    return this.interactions;\n  }\n\n  /**\n   * Get the layergroup associated with this map.\n   * @return {LayerGroup} A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n  getLayerGroup() {\n    return (\n      /** @type {LayerGroup} */ (this.get(MapProperty.LAYERGROUP))\n    );\n  }\n\n  /**\n   * Get the collection of layers associated with this map.\n   * @return {!Collection<import(\"./layer/Base.js\").default>} Layers.\n   * @api\n   */\n  getLayers() {\n    const layers = this.getLayerGroup().getLayers();\n    return layers;\n  }\n\n  /**\n   * Get the pixel for a coordinate.  This takes a coordinate in the map view\n   * projection and returns the corresponding pixel.\n   * @param {import(\"./coordinate.js\").Coordinate} coordinate A map coordinate.\n   * @return {import(\"./pixel.js\").Pixel} A pixel position in the map viewport.\n   * @api\n   */\n  getPixelFromCoordinate(coordinate) {\n    const frameState = this.frameState_;\n    if (!frameState) {\n      return null;\n    } else {\n      return applyTransform(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));\n    }\n  }\n\n  /**\n   * Get the map renderer.\n   * @return {import(\"./renderer/Map.js\").default} Renderer\n   */\n  getRenderer() {\n    return this.renderer_;\n  }\n\n  /**\n   * Get the size of this map.\n   * @return {import(\"./size.js\").Size|undefined} The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n  getSize() {\n    return (\n      /** @type {import(\"./size.js\").Size|undefined} */ (this.get(MapProperty.SIZE))\n    );\n  }\n\n  /**\n   * Get the view associated with this map. A view manages properties such as\n   * center and resolution.\n   * @return {View} The view that controls this map.\n   * @observable\n   * @api\n   */\n  getView() {\n    return (\n      /** @type {View} */ (this.get(MapProperty.VIEW))\n    );\n  }\n\n  /**\n   * Get the element that serves as the map viewport.\n   * @return {HTMLElement} Viewport.\n   * @api\n   */\n  getViewport() {\n    return this.viewport_;\n  }\n\n  /**\n   * Get the element that serves as the container for overlays.  Elements added to\n   * this container will let mousedown and touchstart events through to the map,\n   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}\n   * events.\n   * @return {!HTMLElement} The map's overlay container.\n   */\n  getOverlayContainer() {\n    return this.overlayContainer_;\n  }\n\n  /**\n   * Get the element that serves as a container for overlays that don't allow\n   * event propagation. Elements added to this container won't let mousedown and\n   * touchstart events through to the map, so clicks and gestures on an overlay\n   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.\n   * @return {!HTMLElement} The map's overlay container that stops events.\n   */\n  getOverlayContainerStopEvent() {\n    return this.overlayContainerStopEvent_;\n  }\n\n  /**\n   * @param {import(\"./Tile.js\").default} tile Tile.\n   * @param {string} tileSourceKey Tile source key.\n   * @param {import(\"./coordinate.js\").Coordinate} tileCenter Tile center.\n   * @param {number} tileResolution Tile resolution.\n   * @return {number} Tile priority.\n   */\n  getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {\n    // Filter out tiles at higher zoom levels than the current zoom level, or that\n    // are outside the visible extent.\n    const frameState = this.frameState_;\n    if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {\n      return DROP;\n    }\n    if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {\n      return DROP;\n    }\n    // Prioritize the highest zoom level tiles closest to the focus.\n    // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).\n    // Within a zoom level, tiles are prioritized by the distance in pixels\n    // between the center of the tile and the focus.  The factor of 65536 means\n    // that the prioritization should behave as desired for tiles up to\n    // 65536 * Math.log(2) = 45426 pixels from the focus.\n    const deltaX = tileCenter[0] - frameState.focus[0];\n    const deltaY = tileCenter[1] - frameState.focus[1];\n    return 65536 * Math.log(tileResolution) +\n        Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;\n  }\n\n  /**\n   * @param {Event} browserEvent Browser event.\n   * @param {string=} opt_type Type.\n   */\n  handleBrowserEvent(browserEvent, opt_type) {\n    const type = opt_type || browserEvent.type;\n    const mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);\n    this.handleMapBrowserEvent(mapBrowserEvent);\n  }\n\n  /**\n   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.\n   */\n  handleMapBrowserEvent(mapBrowserEvent) {\n    if (!this.frameState_) {\n      // With no view defined, we cannot translate pixels into geographical\n      // coordinates so interactions cannot be used.\n      return;\n    }\n    this.focus_ = mapBrowserEvent.coordinate;\n    mapBrowserEvent.frameState = this.frameState_;\n    const interactionsArray = this.getInteractions().getArray();\n    if (this.dispatchEvent(mapBrowserEvent) !== false) {\n      for (let i = interactionsArray.length - 1; i >= 0; i--) {\n        const interaction = interactionsArray[i];\n        if (!interaction.getActive()) {\n          continue;\n        }\n        const cont = interaction.handleEvent(mapBrowserEvent);\n        if (!cont) {\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * @protected\n   */\n  handlePostRender() {\n\n    const frameState = this.frameState_;\n\n    // Manage the tile queue\n    // Image loads are expensive and a limited resource, so try to use them\n    // efficiently:\n    // * When the view is static we allow a large number of parallel tile loads\n    //   to complete the frame as quickly as possible.\n    // * When animating or interacting, image loads can cause janks, so we reduce\n    //   the maximum number of loads per frame and limit the number of parallel\n    //   tile loads to remain reactive to view changes and to reduce the chance of\n    //   loading tiles that will quickly disappear from view.\n    const tileQueue = this.tileQueue_;\n    if (!tileQueue.isEmpty()) {\n      let maxTotalLoading = this.maxTilesLoading_;\n      let maxNewLoads = maxTotalLoading;\n      if (frameState) {\n        const hints = frameState.viewHints;\n        if (hints[ViewHint.ANIMATING]) {\n          maxTotalLoading = this.loadTilesWhileAnimating_ ? 8 : 0;\n          maxNewLoads = 2;\n        }\n        if (hints[ViewHint.INTERACTING]) {\n          maxTotalLoading = this.loadTilesWhileInteracting_ ? 8 : 0;\n          maxNewLoads = 2;\n        }\n      }\n      if (tileQueue.getTilesLoading() < maxTotalLoading) {\n        tileQueue.reprioritize(); // FIXME only call if view has changed\n        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);\n      }\n    }\n    if (frameState && this.hasListener(RenderEventType.RENDERCOMPLETE) && !frameState.animate &&\n        !this.tileQueue_.getTilesLoading() && !getLoading(this.getLayers().getArray())) {\n      this.renderer_.dispatchRenderEvent(RenderEventType.RENDERCOMPLETE, frameState);\n    }\n\n    const postRenderFunctions = this.postRenderFunctions_;\n    for (let i = 0, ii = postRenderFunctions.length; i < ii; ++i) {\n      postRenderFunctions[i](this, frameState);\n    }\n    postRenderFunctions.length = 0;\n  }\n\n  /**\n   * @private\n   */\n  handleSizeChanged_() {\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  handleTargetChanged_() {\n    // target may be undefined, null, a string or an Element.\n    // If it's a string we convert it to an Element before proceeding.\n    // If it's not now an Element we remove the viewport from the DOM.\n    // If it's an Element we append the viewport element to it.\n\n    let targetElement;\n    if (this.getTarget()) {\n      targetElement = this.getTargetElement();\n    }\n\n    if (this.keyHandlerKeys_) {\n      for (let i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {\n        unlistenByKey(this.keyHandlerKeys_[i]);\n      }\n      this.keyHandlerKeys_ = null;\n    }\n\n    if (!targetElement) {\n      this.renderer_.removeLayerRenderers();\n      removeNode(this.viewport_);\n      if (this.handleResize_ !== undefined) {\n        removeEventListener(EventType.RESIZE, this.handleResize_, false);\n        this.handleResize_ = undefined;\n      }\n    } else {\n      targetElement.appendChild(this.viewport_);\n\n      const keyboardEventTarget = !this.keyboardEventTarget_ ?\n        targetElement : this.keyboardEventTarget_;\n      this.keyHandlerKeys_ = [\n        listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this),\n        listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this)\n      ];\n\n      if (!this.handleResize_) {\n        this.handleResize_ = this.updateSize.bind(this);\n        addEventListener(EventType.RESIZE, this.handleResize_, false);\n      }\n    }\n\n    this.updateSize();\n    // updateSize calls setSize, so no need to call this.render\n    // ourselves here.\n  }\n\n  /**\n   * @private\n   */\n  handleTileChange_() {\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  handleViewPropertyChanged_() {\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  handleViewChanged_() {\n    if (this.viewPropertyListenerKey_) {\n      unlistenByKey(this.viewPropertyListenerKey_);\n      this.viewPropertyListenerKey_ = null;\n    }\n    if (this.viewChangeListenerKey_) {\n      unlistenByKey(this.viewChangeListenerKey_);\n      this.viewChangeListenerKey_ = null;\n    }\n    const view = this.getView();\n    if (view) {\n      this.viewport_.setAttribute('data-view', getUid(view));\n      this.viewPropertyListenerKey_ = listen(\n        view, ObjectEventType.PROPERTYCHANGE,\n        this.handleViewPropertyChanged_, this);\n      this.viewChangeListenerKey_ = listen(\n        view, EventType.CHANGE,\n        this.handleViewPropertyChanged_, this);\n    }\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  handleLayerGroupChanged_() {\n    if (this.layerGroupPropertyListenerKeys_) {\n      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);\n      this.layerGroupPropertyListenerKeys_ = null;\n    }\n    const layerGroup = this.getLayerGroup();\n    if (layerGroup) {\n      this.layerGroupPropertyListenerKeys_ = [\n        listen(\n          layerGroup, ObjectEventType.PROPERTYCHANGE,\n          this.render, this),\n        listen(\n          layerGroup, EventType.CHANGE,\n          this.render, this)\n      ];\n    }\n    this.render();\n  }\n\n  /**\n   * @return {boolean} Is rendered.\n   */\n  isRendered() {\n    return !!this.frameState_;\n  }\n\n  /**\n   * Requests an immediate render in a synchronous manner.\n   * @api\n   */\n  renderSync() {\n    if (this.animationDelayKey_) {\n      cancelAnimationFrame(this.animationDelayKey_);\n    }\n    this.animationDelay_();\n  }\n\n  /**\n   * Request a map rendering (at the next animation frame).\n   * @api\n   */\n  render() {\n    if (this.animationDelayKey_ === undefined) {\n      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);\n    }\n  }\n\n  /**\n   * Remove the given control from the map.\n   * @param {import(\"./control/Control.js\").default} control Control.\n   * @return {import(\"./control/Control.js\").default|undefined} The removed control (or undefined\n   *     if the control was not found).\n   * @api\n   */\n  removeControl(control) {\n    return this.getControls().remove(control);\n  }\n\n  /**\n   * Remove the given interaction from the map.\n   * @param {import(\"./interaction/Interaction.js\").default} interaction Interaction to remove.\n   * @return {import(\"./interaction/Interaction.js\").default|undefined} The removed interaction (or\n   *     undefined if the interaction was not found).\n   * @api\n   */\n  removeInteraction(interaction) {\n    return this.getInteractions().remove(interaction);\n  }\n\n  /**\n   * Removes the given layer from the map.\n   * @param {import(\"./layer/Base.js\").default} layer Layer.\n   * @return {import(\"./layer/Base.js\").default|undefined} The removed layer (or undefined if the\n   *     layer was not found).\n   * @api\n   */\n  removeLayer(layer) {\n    const layers = this.getLayerGroup().getLayers();\n    return layers.remove(layer);\n  }\n\n  /**\n   * Remove the given overlay from the map.\n   * @param {import(\"./Overlay.js\").default} overlay Overlay.\n   * @return {import(\"./Overlay.js\").default|undefined} The removed overlay (or undefined\n   *     if the overlay was not found).\n   * @api\n   */\n  removeOverlay(overlay) {\n    return this.getOverlays().remove(overlay);\n  }\n\n  /**\n   * @param {number} time Time.\n   * @private\n   */\n  renderFrame_(time) {\n    let viewState;\n\n    const size = this.getSize();\n    const view = this.getView();\n    const extent = createEmpty();\n    const previousFrameState = this.frameState_;\n    /** @type {?FrameState} */\n    let frameState = null;\n    if (size !== undefined && hasArea(size) && view && view.isDef()) {\n      const viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);\n      const layerStatesArray = this.getLayerGroup().getLayerStatesArray();\n      const layerStates = {};\n      for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n        layerStates[getUid(layerStatesArray[i].layer)] = layerStatesArray[i];\n      }\n      viewState = view.getState(this.pixelRatio_);\n      frameState = /** @type {FrameState} */ ({\n        animate: false,\n        coordinateToPixelTransform: this.coordinateToPixelTransform_,\n        extent: extent,\n        focus: this.focus_ ? this.focus_ : viewState.center,\n        index: this.frameIndex_++,\n        layerStates: layerStates,\n        layerStatesArray: layerStatesArray,\n        pixelRatio: this.pixelRatio_,\n        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,\n        postRenderFunctions: [],\n        size: size,\n        skippedFeatureUids: this.skippedFeatureUids_,\n        tileQueue: this.tileQueue_,\n        time: time,\n        usedTiles: {},\n        viewState: viewState,\n        viewHints: viewHints,\n        wantedTiles: {}\n      });\n    }\n\n    if (frameState) {\n      frameState.extent = getForViewAndSize(viewState.center,\n        viewState.resolution, viewState.rotation, frameState.size, extent);\n    }\n\n    this.frameState_ = frameState;\n    this.renderer_.renderFrame(frameState);\n\n    if (frameState) {\n      if (frameState.animate) {\n        this.render();\n      }\n      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);\n\n      if (previousFrameState) {\n        const moveStart = !this.previousExtent_ ||\n                    (!isEmpty(this.previousExtent_) &&\n                    !equals(frameState.extent, this.previousExtent_));\n        if (moveStart) {\n          this.dispatchEvent(\n            new MapEvent(MapEventType.MOVESTART, this, previousFrameState));\n          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);\n        }\n      }\n\n      const idle = this.previousExtent_ &&\n          !frameState.viewHints[ViewHint.ANIMATING] &&\n          !frameState.viewHints[ViewHint.INTERACTING] &&\n          !equals(frameState.extent, this.previousExtent_);\n\n      if (idle) {\n        this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));\n        clone(frameState.extent, this.previousExtent_);\n      }\n    }\n\n    this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));\n\n    setTimeout(this.handlePostRender.bind(this), 0);\n\n  }\n\n  /**\n   * Sets the layergroup of this map.\n   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.\n   * @observable\n   * @api\n   */\n  setLayerGroup(layerGroup) {\n    this.set(MapProperty.LAYERGROUP, layerGroup);\n  }\n\n  /**\n   * Set the size of this map.\n   * @param {import(\"./size.js\").Size|undefined} size The size in pixels of the map in the DOM.\n   * @observable\n   * @api\n   */\n  setSize(size) {\n    this.set(MapProperty.SIZE, size);\n  }\n\n  /**\n   * Set the target element to render this map into.\n   * @param {HTMLElement|string|undefined} target The Element or id of the Element\n   *     that the map is rendered in.\n   * @observable\n   * @api\n   */\n  setTarget(target) {\n    this.set(MapProperty.TARGET, target);\n  }\n\n  /**\n   * Set the view for this map.\n   * @param {View} view The view that controls this map.\n   * @observable\n   * @api\n   */\n  setView(view) {\n    this.set(MapProperty.VIEW, view);\n  }\n\n  /**\n   * @param {import(\"./Feature.js\").default} feature Feature.\n   */\n  skipFeature(feature) {\n    this.skippedFeatureUids_[getUid(feature)] = true;\n    this.render();\n  }\n\n  /**\n   * Force a recalculation of the map viewport size.  This should be called when\n   * third-party code changes the size of the map viewport.\n   * @api\n   */\n  updateSize() {\n    const targetElement = this.getTargetElement();\n\n    if (!targetElement) {\n      this.setSize(undefined);\n    } else {\n      const computedStyle = getComputedStyle(targetElement);\n      this.setSize([\n        targetElement.offsetWidth -\n            parseFloat(computedStyle['borderLeftWidth']) -\n            parseFloat(computedStyle['paddingLeft']) -\n            parseFloat(computedStyle['paddingRight']) -\n            parseFloat(computedStyle['borderRightWidth']),\n        targetElement.offsetHeight -\n            parseFloat(computedStyle['borderTopWidth']) -\n            parseFloat(computedStyle['paddingTop']) -\n            parseFloat(computedStyle['paddingBottom']) -\n            parseFloat(computedStyle['borderBottomWidth'])\n      ]);\n    }\n  }\n\n  /**\n   * @param {import(\"./Feature.js\").default} feature Feature.\n   */\n  unskipFeature(feature) {\n    delete this.skippedFeatureUids_[getUid(feature)];\n    this.render();\n  }\n}\n\n\n/**\n * @param {MapOptions} options Map options.\n * @return {MapOptionsInternal} Internal map options.\n */\nfunction createOptionsInternal(options) {\n\n  /**\n   * @type {HTMLElement|Document}\n   */\n  let keyboardEventTarget = null;\n  if (options.keyboardEventTarget !== undefined) {\n    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ?\n      document.getElementById(options.keyboardEventTarget) :\n      options.keyboardEventTarget;\n  }\n\n  /**\n   * @type {Object<string, *>}\n   */\n  const values = {};\n\n  const layerGroup = options.layers && typeof /** @type {?} */ (options.layers).getLayers === 'function' ?\n    /** @type {LayerGroup} */ (options.layers) : new LayerGroup({layers: /** @type {Collection} */ (options.layers)});\n  values[MapProperty.LAYERGROUP] = layerGroup;\n\n  values[MapProperty.TARGET] = options.target;\n\n  values[MapProperty.VIEW] = options.view !== undefined ?\n    options.view : new View();\n\n  let controls;\n  if (options.controls !== undefined) {\n    if (Array.isArray(options.controls)) {\n      controls = new Collection(options.controls.slice());\n    } else {\n      assert(typeof /** @type {?} */ (options.controls).getArray === 'function',\n        47); // Expected `controls` to be an array or an `import(\"./Collection.js\").Collection`\n      controls = /** @type {Collection} */ (options.controls);\n    }\n  }\n\n  let interactions;\n  if (options.interactions !== undefined) {\n    if (Array.isArray(options.interactions)) {\n      interactions = new Collection(options.interactions.slice());\n    } else {\n      assert(typeof /** @type {?} */ (options.interactions).getArray === 'function',\n        48); // Expected `interactions` to be an array or an `import(\"./Collection.js\").Collection`\n      interactions = /** @type {Collection} */ (options.interactions);\n    }\n  }\n\n  let overlays;\n  if (options.overlays !== undefined) {\n    if (Array.isArray(options.overlays)) {\n      overlays = new Collection(options.overlays.slice());\n    } else {\n      assert(typeof /** @type {?} */ (options.overlays).getArray === 'function',\n        49); // Expected `overlays` to be an array or an `import(\"./Collection.js\").Collection`\n      overlays = options.overlays;\n    }\n  } else {\n    overlays = new Collection();\n  }\n\n  return {\n    controls: controls,\n    interactions: interactions,\n    keyboardEventTarget: keyboardEventTarget,\n    overlays: overlays,\n    values: values\n  };\n\n}\nexport default PluggableMap;\n\n/**\n * @param  {Array<import(\"./layer/Base.js\").default>} layers Layers.\n * @return {boolean} Layers have sources that are still loading.\n */\nfunction getLoading(layers) {\n  for (let i = 0, ii = layers.length; i < ii; ++i) {\n    const layer = layers[i];\n    if (typeof /** @type {?} */ (layer).getLayers === 'function') {\n      return getLoading(/** @type {LayerGroup} */ (layer).getLayers().getArray());\n    } else {\n      const source = /** @type {import(\"./layer/Layer.js\").default} */ (\n        layer).getSource();\n      if (source && source.loading) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}