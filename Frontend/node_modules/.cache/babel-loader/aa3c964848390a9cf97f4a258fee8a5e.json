{"ast":null,"code":"import _ol_ from './index.js';\nimport _ol_Sphere_ from './sphere.js';\nimport _ol_extent_ from './extent.js';\nimport _ol_math_ from './math.js';\nimport _ol_proj_EPSG3857_ from './proj/epsg3857.js';\nimport _ol_proj_EPSG4326_ from './proj/epsg4326.js';\nimport _ol_proj_Projection_ from './proj/projection.js';\nimport _ol_proj_Units_ from './proj/units.js';\nimport _ol_proj_proj4_ from './proj/proj4.js';\nimport _ol_proj_projections_ from './proj/projections.js';\nimport _ol_proj_transforms_ from './proj/transforms.js';\nvar _ol_proj_ = {};\n\n/**\n * Meters per unit lookup table.\n * @const\n * @type {Object.<ol.proj.Units, number>}\n * @api\n */\n_ol_proj_.METERS_PER_UNIT = _ol_proj_Units_.METERS_PER_UNIT;\n\n/**\n * A place to store the mean radius of the Earth.\n * @private\n * @type {ol.Sphere}\n */\n_ol_proj_.SPHERE_ = new _ol_Sphere_(_ol_Sphere_.DEFAULT_RADIUS);\nif (_ol_.ENABLE_PROJ4JS) {\n  /**\n   * Register proj4. If not explicitly registered, it will be assumed that\n   * proj4js will be loaded in the global namespace. For example in a\n   * browserify ES6 environment you could use:\n   *\n   *     import ol from 'openlayers';\n   *     import proj4 from 'proj4';\n   *     ol.proj.setProj4(proj4);\n   *\n   * @param {Proj4} proj4 Proj4.\n   * @api\n   */\n  _ol_proj_.setProj4 = function (proj4) {\n    _ol_proj_proj4_.set(proj4);\n  };\n}\n\n/**\n * Get the resolution of the point in degrees or distance units.\n * For projections with degrees as the unit this will simply return the\n * provided resolution. For other projections the point resolution is\n * by default estimated by transforming the 'point' pixel to EPSG:4326,\n * measuring its width and height on the normal sphere,\n * and taking the average of the width and height.\n * A custom function can be provided for a specific projection, either\n * by setting the `getPointResolution` option in the\n * {@link ol.proj.Projection} constructor or by using\n * {@link ol.proj.Projection#setGetPointResolution} to change an existing\n * projection object.\n * @param {ol.ProjectionLike} projection The projection.\n * @param {number} resolution Nominal resolution in projection units.\n * @param {ol.Coordinate} point Point to find adjusted resolution at.\n * @param {ol.proj.Units=} opt_units Units to get the point resolution in.\n * Default is the projection's units.\n * @return {number} Point resolution.\n * @api\n */\n_ol_proj_.getPointResolution = function (projection, resolution, point, opt_units) {\n  projection = _ol_proj_.get(projection);\n  var pointResolution;\n  var getter = projection.getPointResolutionFunc();\n  if (getter) {\n    pointResolution = getter(resolution, point);\n  } else {\n    var units = projection.getUnits();\n    if (units == _ol_proj_Units_.DEGREES && !opt_units || opt_units == _ol_proj_Units_.DEGREES) {\n      pointResolution = resolution;\n    } else {\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\n      // measuring its width and height on the normal sphere, and taking the\n      // average of the width and height.\n      var toEPSG4326 = _ol_proj_.getTransformFromProjections(projection, _ol_proj_.get('EPSG:4326'));\n      var vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];\n      vertices = toEPSG4326(vertices, vertices, 2);\n      var width = _ol_proj_.SPHERE_.haversineDistance(vertices.slice(0, 2), vertices.slice(2, 4));\n      var height = _ol_proj_.SPHERE_.haversineDistance(vertices.slice(4, 6), vertices.slice(6, 8));\n      pointResolution = (width + height) / 2;\n      var metersPerUnit = opt_units ? _ol_proj_Units_.METERS_PER_UNIT[opt_units] : projection.getMetersPerUnit();\n      if (metersPerUnit !== undefined) {\n        pointResolution /= metersPerUnit;\n      }\n    }\n  }\n  return pointResolution;\n};\n\n/**\n * Registers transformation functions that don't alter coordinates. Those allow\n * to transform between projections with equal meaning.\n *\n * @param {Array.<ol.proj.Projection>} projections Projections.\n * @api\n */\n_ol_proj_.addEquivalentProjections = function (projections) {\n  _ol_proj_.addProjections(projections);\n  projections.forEach(function (source) {\n    projections.forEach(function (destination) {\n      if (source !== destination) {\n        _ol_proj_transforms_.add(source, destination, _ol_proj_.cloneTransform);\n      }\n    });\n  });\n};\n\n/**\n * Registers transformation functions to convert coordinates in any projection\n * in projection1 to any projection in projection2.\n *\n * @param {Array.<ol.proj.Projection>} projections1 Projections with equal\n *     meaning.\n * @param {Array.<ol.proj.Projection>} projections2 Projections with equal\n *     meaning.\n * @param {ol.TransformFunction} forwardTransform Transformation from any\n *   projection in projection1 to any projection in projection2.\n * @param {ol.TransformFunction} inverseTransform Transform from any projection\n *   in projection2 to any projection in projection1..\n */\n_ol_proj_.addEquivalentTransforms = function (projections1, projections2, forwardTransform, inverseTransform) {\n  projections1.forEach(function (projection1) {\n    projections2.forEach(function (projection2) {\n      _ol_proj_transforms_.add(projection1, projection2, forwardTransform);\n      _ol_proj_transforms_.add(projection2, projection1, inverseTransform);\n    });\n  });\n};\n\n/**\n * Add a Projection object to the list of supported projections that can be\n * looked up by their code.\n *\n * @param {ol.proj.Projection} projection Projection instance.\n * @api\n */\n_ol_proj_.addProjection = function (projection) {\n  _ol_proj_projections_.add(projection.getCode(), projection);\n  _ol_proj_transforms_.add(projection, projection, _ol_proj_.cloneTransform);\n};\n\n/**\n * @param {Array.<ol.proj.Projection>} projections Projections.\n */\n_ol_proj_.addProjections = function (projections) {\n  projections.forEach(_ol_proj_.addProjection);\n};\n\n/**\n * Clear all cached projections and transforms.\n */\n_ol_proj_.clearAllProjections = function () {\n  _ol_proj_projections_.clear();\n  _ol_proj_transforms_.clear();\n};\n\n/**\n * @param {ol.proj.Projection|string|undefined} projection Projection.\n * @param {string} defaultCode Default code.\n * @return {ol.proj.Projection} Projection.\n */\n_ol_proj_.createProjection = function (projection, defaultCode) {\n  if (!projection) {\n    return _ol_proj_.get(defaultCode);\n  } else if (typeof projection === 'string') {\n    return _ol_proj_.get(projection);\n  } else {\n    return (/** @type {ol.proj.Projection} */projection\n    );\n  }\n};\n\n/**\n * Registers coordinate transform functions to convert coordinates between the\n * source projection and the destination projection.\n * The forward and inverse functions convert coordinate pairs; this function\n * converts these into the functions used internally which also handle\n * extents and coordinate arrays.\n *\n * @param {ol.ProjectionLike} source Source projection.\n * @param {ol.ProjectionLike} destination Destination projection.\n * @param {function(ol.Coordinate): ol.Coordinate} forward The forward transform\n *     function (that is, from the source projection to the destination\n *     projection) that takes a {@link ol.Coordinate} as argument and returns\n *     the transformed {@link ol.Coordinate}.\n * @param {function(ol.Coordinate): ol.Coordinate} inverse The inverse transform\n *     function (that is, from the destination projection to the source\n *     projection) that takes a {@link ol.Coordinate} as argument and returns\n *     the transformed {@link ol.Coordinate}.\n * @api\n */\n_ol_proj_.addCoordinateTransforms = function (source, destination, forward, inverse) {\n  var sourceProj = _ol_proj_.get(source);\n  var destProj = _ol_proj_.get(destination);\n  _ol_proj_transforms_.add(sourceProj, destProj, _ol_proj_.createTransformFromCoordinateTransform(forward));\n  _ol_proj_transforms_.add(destProj, sourceProj, _ol_proj_.createTransformFromCoordinateTransform(inverse));\n};\n\n/**\n * Creates a {@link ol.TransformFunction} from a simple 2D coordinate transform\n * function.\n * @param {function(ol.Coordinate): ol.Coordinate} transform Coordinate\n *     transform.\n * @return {ol.TransformFunction} Transform function.\n */\n_ol_proj_.createTransformFromCoordinateTransform = function (transform) {\n  return (\n    /**\n     * @param {Array.<number>} input Input.\n     * @param {Array.<number>=} opt_output Output.\n     * @param {number=} opt_dimension Dimension.\n     * @return {Array.<number>} Output.\n     */\n    function (input, opt_output, opt_dimension) {\n      var length = input.length;\n      var dimension = opt_dimension !== undefined ? opt_dimension : 2;\n      var output = opt_output !== undefined ? opt_output : new Array(length);\n      var point, i, j;\n      for (i = 0; i < length; i += dimension) {\n        point = transform([input[i], input[i + 1]]);\n        output[i] = point[0];\n        output[i + 1] = point[1];\n        for (j = dimension - 1; j >= 2; --j) {\n          output[i + j] = input[i + j];\n        }\n      }\n      return output;\n    }\n  );\n};\n\n/**\n * Transforms a coordinate from longitude/latitude to a different projection.\n * @param {ol.Coordinate} coordinate Coordinate as longitude and latitude, i.e.\n *     an array with longitude as 1st and latitude as 2nd element.\n * @param {ol.ProjectionLike=} opt_projection Target projection. The\n *     default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {ol.Coordinate} Coordinate projected to the target projection.\n * @api\n */\n_ol_proj_.fromLonLat = function (coordinate, opt_projection) {\n  return _ol_proj_.transform(coordinate, 'EPSG:4326', opt_projection !== undefined ? opt_projection : 'EPSG:3857');\n};\n\n/**\n * Transforms a coordinate to longitude/latitude.\n * @param {ol.Coordinate} coordinate Projected coordinate.\n * @param {ol.ProjectionLike=} opt_projection Projection of the coordinate.\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {ol.Coordinate} Coordinate as longitude and latitude, i.e. an array\n *     with longitude as 1st and latitude as 2nd element.\n * @api\n */\n_ol_proj_.toLonLat = function (coordinate, opt_projection) {\n  var lonLat = _ol_proj_.transform(coordinate, opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');\n  var lon = lonLat[0];\n  if (lon < -180 || lon > 180) {\n    lonLat[0] = _ol_math_.modulo(lon + 180, 360) - 180;\n  }\n  return lonLat;\n};\n\n/**\n * Fetches a Projection object for the code specified.\n *\n * @param {ol.ProjectionLike} projectionLike Either a code string which is\n *     a combination of authority and identifier such as \"EPSG:4326\", or an\n *     existing projection object, or undefined.\n * @return {ol.proj.Projection} Projection object, or null if not in list.\n * @api\n */\n_ol_proj_.get = function (projectionLike) {\n  var projection = null;\n  if (projectionLike instanceof _ol_proj_Projection_) {\n    projection = projectionLike;\n  } else if (typeof projectionLike === 'string') {\n    var code = projectionLike;\n    projection = _ol_proj_projections_.get(code);\n    if (_ol_.ENABLE_PROJ4JS && !projection) {\n      var proj4js = _ol_proj_proj4_.get();\n      if (typeof proj4js == 'function' && proj4js.defs(code) !== undefined) {\n        projection = new _ol_proj_Projection_({\n          code: code\n        });\n        _ol_proj_.addProjection(projection);\n      }\n    }\n  }\n  return projection;\n};\n\n/**\n * Checks if two projections are the same, that is every coordinate in one\n * projection does represent the same geographic point as the same coordinate in\n * the other projection.\n *\n * @param {ol.proj.Projection} projection1 Projection 1.\n * @param {ol.proj.Projection} projection2 Projection 2.\n * @return {boolean} Equivalent.\n * @api\n */\n_ol_proj_.equivalent = function (projection1, projection2) {\n  if (projection1 === projection2) {\n    return true;\n  }\n  var equalUnits = projection1.getUnits() === projection2.getUnits();\n  if (projection1.getCode() === projection2.getCode()) {\n    return equalUnits;\n  } else {\n    var transformFn = _ol_proj_.getTransformFromProjections(projection1, projection2);\n    return transformFn === _ol_proj_.cloneTransform && equalUnits;\n  }\n};\n\n/**\n * Given the projection-like objects, searches for a transformation\n * function to convert a coordinates array from the source projection to the\n * destination projection.\n *\n * @param {ol.ProjectionLike} source Source.\n * @param {ol.ProjectionLike} destination Destination.\n * @return {ol.TransformFunction} Transform function.\n * @api\n */\n_ol_proj_.getTransform = function (source, destination) {\n  var sourceProjection = _ol_proj_.get(source);\n  var destinationProjection = _ol_proj_.get(destination);\n  return _ol_proj_.getTransformFromProjections(sourceProjection, destinationProjection);\n};\n\n/**\n * Searches in the list of transform functions for the function for converting\n * coordinates from the source projection to the destination projection.\n *\n * @param {ol.proj.Projection} sourceProjection Source Projection object.\n * @param {ol.proj.Projection} destinationProjection Destination Projection\n *     object.\n * @return {ol.TransformFunction} Transform function.\n */\n_ol_proj_.getTransformFromProjections = function (sourceProjection, destinationProjection) {\n  var sourceCode = sourceProjection.getCode();\n  var destinationCode = destinationProjection.getCode();\n  var transform = _ol_proj_transforms_.get(sourceCode, destinationCode);\n  if (_ol_.ENABLE_PROJ4JS && !transform) {\n    var proj4js = _ol_proj_proj4_.get();\n    if (typeof proj4js == 'function') {\n      var sourceDef = proj4js.defs(sourceCode);\n      var destinationDef = proj4js.defs(destinationCode);\n      if (sourceDef !== undefined && destinationDef !== undefined) {\n        if (sourceDef === destinationDef) {\n          _ol_proj_.addEquivalentProjections([destinationProjection, sourceProjection]);\n        } else {\n          var proj4Transform = proj4js(destinationCode, sourceCode);\n          _ol_proj_.addCoordinateTransforms(destinationProjection, sourceProjection, proj4Transform.forward, proj4Transform.inverse);\n        }\n        transform = _ol_proj_transforms_.get(sourceCode, destinationCode);\n      }\n    }\n  }\n  if (!transform) {\n    transform = _ol_proj_.identityTransform;\n  }\n  return transform;\n};\n\n/**\n * @param {Array.<number>} input Input coordinate array.\n * @param {Array.<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension.\n * @return {Array.<number>} Input coordinate array (same array as input).\n */\n_ol_proj_.identityTransform = function (input, opt_output, opt_dimension) {\n  if (opt_output !== undefined && input !== opt_output) {\n    for (var i = 0, ii = input.length; i < ii; ++i) {\n      opt_output[i] = input[i];\n    }\n    input = opt_output;\n  }\n  return input;\n};\n\n/**\n * @param {Array.<number>} input Input coordinate array.\n * @param {Array.<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension.\n * @return {Array.<number>} Output coordinate array (new array, same coordinate\n *     values).\n */\n_ol_proj_.cloneTransform = function (input, opt_output, opt_dimension) {\n  var output;\n  if (opt_output !== undefined) {\n    for (var i = 0, ii = input.length; i < ii; ++i) {\n      opt_output[i] = input[i];\n    }\n    output = opt_output;\n  } else {\n    output = input.slice();\n  }\n  return output;\n};\n\n/**\n * Transforms a coordinate from source projection to destination projection.\n * This returns a new coordinate (and does not modify the original).\n *\n * See {@link ol.proj.transformExtent} for extent transformation.\n * See the transform method of {@link ol.geom.Geometry} and its subclasses for\n * geometry transforms.\n *\n * @param {ol.Coordinate} coordinate Coordinate.\n * @param {ol.ProjectionLike} source Source projection-like.\n * @param {ol.ProjectionLike} destination Destination projection-like.\n * @return {ol.Coordinate} Coordinate.\n * @api\n */\n_ol_proj_.transform = function (coordinate, source, destination) {\n  var transformFn = _ol_proj_.getTransform(source, destination);\n  return transformFn(coordinate, undefined, coordinate.length);\n};\n\n/**\n * Transforms an extent from source projection to destination projection.  This\n * returns a new extent (and does not modify the original).\n *\n * @param {ol.Extent} extent The extent to transform.\n * @param {ol.ProjectionLike} source Source projection-like.\n * @param {ol.ProjectionLike} destination Destination projection-like.\n * @return {ol.Extent} The transformed extent.\n * @api\n */\n_ol_proj_.transformExtent = function (extent, source, destination) {\n  var transformFn = _ol_proj_.getTransform(source, destination);\n  return _ol_extent_.applyTransform(extent, transformFn);\n};\n\n/**\n * Transforms the given point to the destination projection.\n *\n * @param {ol.Coordinate} point Point.\n * @param {ol.proj.Projection} sourceProjection Source projection.\n * @param {ol.proj.Projection} destinationProjection Destination projection.\n * @return {ol.Coordinate} Point.\n */\n_ol_proj_.transformWithProjections = function (point, sourceProjection, destinationProjection) {\n  var transformFn = _ol_proj_.getTransformFromProjections(sourceProjection, destinationProjection);\n  return transformFn(point);\n};\n\n/**\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n * by when this module is executed and should only need to be called again after\n * `ol.proj.clearAllProjections()` is called (e.g. in tests).\n */\n_ol_proj_.addCommon = function () {\n  // Add transformations that don't alter coordinates to convert within set of\n  // projections with equal meaning.\n  _ol_proj_.addEquivalentProjections(_ol_proj_EPSG3857_.PROJECTIONS);\n  _ol_proj_.addEquivalentProjections(_ol_proj_EPSG4326_.PROJECTIONS);\n  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n  // coordinates and back.\n  _ol_proj_.addEquivalentTransforms(_ol_proj_EPSG4326_.PROJECTIONS, _ol_proj_EPSG3857_.PROJECTIONS, _ol_proj_EPSG3857_.fromEPSG4326, _ol_proj_EPSG3857_.toEPSG4326);\n};\n_ol_proj_.addCommon();\nexport default _ol_proj_;","map":{"version":3,"names":["_ol_","_ol_Sphere_","_ol_extent_","_ol_math_","_ol_proj_EPSG3857_","_ol_proj_EPSG4326_","_ol_proj_Projection_","_ol_proj_Units_","_ol_proj_proj4_","_ol_proj_projections_","_ol_proj_transforms_","_ol_proj_","METERS_PER_UNIT","SPHERE_","DEFAULT_RADIUS","ENABLE_PROJ4JS","setProj4","proj4","set","getPointResolution","projection","resolution","point","opt_units","get","pointResolution","getter","getPointResolutionFunc","units","getUnits","DEGREES","toEPSG4326","getTransformFromProjections","vertices","width","haversineDistance","slice","height","metersPerUnit","getMetersPerUnit","undefined","addEquivalentProjections","projections","addProjections","forEach","source","destination","add","cloneTransform","addEquivalentTransforms","projections1","projections2","forwardTransform","inverseTransform","projection1","projection2","addProjection","getCode","clearAllProjections","clear","createProjection","defaultCode","addCoordinateTransforms","forward","inverse","sourceProj","destProj","createTransformFromCoordinateTransform","transform","input","opt_output","opt_dimension","length","dimension","output","Array","i","j","fromLonLat","coordinate","opt_projection","toLonLat","lonLat","lon","modulo","projectionLike","code","proj4js","defs","equivalent","equalUnits","transformFn","getTransform","sourceProjection","destinationProjection","sourceCode","destinationCode","sourceDef","destinationDef","proj4Transform","identityTransform","ii","transformExtent","extent","applyTransform","transformWithProjections","addCommon","PROJECTIONS","fromEPSG4326"],"sources":["D:/demo_one/react-website-v1/node_modules/ol/proj.js"],"sourcesContent":["import _ol_ from './index.js';\nimport _ol_Sphere_ from './sphere.js';\nimport _ol_extent_ from './extent.js';\nimport _ol_math_ from './math.js';\nimport _ol_proj_EPSG3857_ from './proj/epsg3857.js';\nimport _ol_proj_EPSG4326_ from './proj/epsg4326.js';\nimport _ol_proj_Projection_ from './proj/projection.js';\nimport _ol_proj_Units_ from './proj/units.js';\nimport _ol_proj_proj4_ from './proj/proj4.js';\nimport _ol_proj_projections_ from './proj/projections.js';\nimport _ol_proj_transforms_ from './proj/transforms.js';\nvar _ol_proj_ = {};\n\n\n/**\n * Meters per unit lookup table.\n * @const\n * @type {Object.<ol.proj.Units, number>}\n * @api\n */\n_ol_proj_.METERS_PER_UNIT = _ol_proj_Units_.METERS_PER_UNIT;\n\n\n/**\n * A place to store the mean radius of the Earth.\n * @private\n * @type {ol.Sphere}\n */\n_ol_proj_.SPHERE_ = new _ol_Sphere_(_ol_Sphere_.DEFAULT_RADIUS);\n\n\nif (_ol_.ENABLE_PROJ4JS) {\n  /**\n   * Register proj4. If not explicitly registered, it will be assumed that\n   * proj4js will be loaded in the global namespace. For example in a\n   * browserify ES6 environment you could use:\n   *\n   *     import ol from 'openlayers';\n   *     import proj4 from 'proj4';\n   *     ol.proj.setProj4(proj4);\n   *\n   * @param {Proj4} proj4 Proj4.\n   * @api\n   */\n  _ol_proj_.setProj4 = function(proj4) {\n    _ol_proj_proj4_.set(proj4);\n  };\n}\n\n\n/**\n * Get the resolution of the point in degrees or distance units.\n * For projections with degrees as the unit this will simply return the\n * provided resolution. For other projections the point resolution is\n * by default estimated by transforming the 'point' pixel to EPSG:4326,\n * measuring its width and height on the normal sphere,\n * and taking the average of the width and height.\n * A custom function can be provided for a specific projection, either\n * by setting the `getPointResolution` option in the\n * {@link ol.proj.Projection} constructor or by using\n * {@link ol.proj.Projection#setGetPointResolution} to change an existing\n * projection object.\n * @param {ol.ProjectionLike} projection The projection.\n * @param {number} resolution Nominal resolution in projection units.\n * @param {ol.Coordinate} point Point to find adjusted resolution at.\n * @param {ol.proj.Units=} opt_units Units to get the point resolution in.\n * Default is the projection's units.\n * @return {number} Point resolution.\n * @api\n */\n_ol_proj_.getPointResolution = function(projection, resolution, point, opt_units) {\n  projection = _ol_proj_.get(projection);\n  var pointResolution;\n  var getter = projection.getPointResolutionFunc();\n  if (getter) {\n    pointResolution = getter(resolution, point);\n  } else {\n    var units = projection.getUnits();\n    if (units == _ol_proj_Units_.DEGREES && !opt_units || opt_units == _ol_proj_Units_.DEGREES) {\n      pointResolution = resolution;\n    } else {\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\n      // measuring its width and height on the normal sphere, and taking the\n      // average of the width and height.\n      var toEPSG4326 = _ol_proj_.getTransformFromProjections(projection, _ol_proj_.get('EPSG:4326'));\n      var vertices = [\n        point[0] - resolution / 2, point[1],\n        point[0] + resolution / 2, point[1],\n        point[0], point[1] - resolution / 2,\n        point[0], point[1] + resolution / 2\n      ];\n      vertices = toEPSG4326(vertices, vertices, 2);\n      var width = _ol_proj_.SPHERE_.haversineDistance(\n          vertices.slice(0, 2), vertices.slice(2, 4));\n      var height = _ol_proj_.SPHERE_.haversineDistance(\n          vertices.slice(4, 6), vertices.slice(6, 8));\n      pointResolution = (width + height) / 2;\n      var metersPerUnit = opt_units ?\n        _ol_proj_Units_.METERS_PER_UNIT[opt_units] :\n        projection.getMetersPerUnit();\n      if (metersPerUnit !== undefined) {\n        pointResolution /= metersPerUnit;\n      }\n    }\n  }\n  return pointResolution;\n};\n\n\n/**\n * Registers transformation functions that don't alter coordinates. Those allow\n * to transform between projections with equal meaning.\n *\n * @param {Array.<ol.proj.Projection>} projections Projections.\n * @api\n */\n_ol_proj_.addEquivalentProjections = function(projections) {\n  _ol_proj_.addProjections(projections);\n  projections.forEach(function(source) {\n    projections.forEach(function(destination) {\n      if (source !== destination) {\n        _ol_proj_transforms_.add(source, destination, _ol_proj_.cloneTransform);\n      }\n    });\n  });\n};\n\n\n/**\n * Registers transformation functions to convert coordinates in any projection\n * in projection1 to any projection in projection2.\n *\n * @param {Array.<ol.proj.Projection>} projections1 Projections with equal\n *     meaning.\n * @param {Array.<ol.proj.Projection>} projections2 Projections with equal\n *     meaning.\n * @param {ol.TransformFunction} forwardTransform Transformation from any\n *   projection in projection1 to any projection in projection2.\n * @param {ol.TransformFunction} inverseTransform Transform from any projection\n *   in projection2 to any projection in projection1..\n */\n_ol_proj_.addEquivalentTransforms = function(projections1, projections2, forwardTransform, inverseTransform) {\n  projections1.forEach(function(projection1) {\n    projections2.forEach(function(projection2) {\n      _ol_proj_transforms_.add(projection1, projection2, forwardTransform);\n      _ol_proj_transforms_.add(projection2, projection1, inverseTransform);\n    });\n  });\n};\n\n\n/**\n * Add a Projection object to the list of supported projections that can be\n * looked up by their code.\n *\n * @param {ol.proj.Projection} projection Projection instance.\n * @api\n */\n_ol_proj_.addProjection = function(projection) {\n  _ol_proj_projections_.add(projection.getCode(), projection);\n  _ol_proj_transforms_.add(projection, projection, _ol_proj_.cloneTransform);\n};\n\n\n/**\n * @param {Array.<ol.proj.Projection>} projections Projections.\n */\n_ol_proj_.addProjections = function(projections) {\n  projections.forEach(_ol_proj_.addProjection);\n};\n\n\n/**\n * Clear all cached projections and transforms.\n */\n_ol_proj_.clearAllProjections = function() {\n  _ol_proj_projections_.clear();\n  _ol_proj_transforms_.clear();\n};\n\n\n/**\n * @param {ol.proj.Projection|string|undefined} projection Projection.\n * @param {string} defaultCode Default code.\n * @return {ol.proj.Projection} Projection.\n */\n_ol_proj_.createProjection = function(projection, defaultCode) {\n  if (!projection) {\n    return _ol_proj_.get(defaultCode);\n  } else if (typeof projection === 'string') {\n    return _ol_proj_.get(projection);\n  } else {\n    return /** @type {ol.proj.Projection} */ (projection);\n  }\n};\n\n\n/**\n * Registers coordinate transform functions to convert coordinates between the\n * source projection and the destination projection.\n * The forward and inverse functions convert coordinate pairs; this function\n * converts these into the functions used internally which also handle\n * extents and coordinate arrays.\n *\n * @param {ol.ProjectionLike} source Source projection.\n * @param {ol.ProjectionLike} destination Destination projection.\n * @param {function(ol.Coordinate): ol.Coordinate} forward The forward transform\n *     function (that is, from the source projection to the destination\n *     projection) that takes a {@link ol.Coordinate} as argument and returns\n *     the transformed {@link ol.Coordinate}.\n * @param {function(ol.Coordinate): ol.Coordinate} inverse The inverse transform\n *     function (that is, from the destination projection to the source\n *     projection) that takes a {@link ol.Coordinate} as argument and returns\n *     the transformed {@link ol.Coordinate}.\n * @api\n */\n_ol_proj_.addCoordinateTransforms = function(source, destination, forward, inverse) {\n  var sourceProj = _ol_proj_.get(source);\n  var destProj = _ol_proj_.get(destination);\n  _ol_proj_transforms_.add(sourceProj, destProj,\n      _ol_proj_.createTransformFromCoordinateTransform(forward));\n  _ol_proj_transforms_.add(destProj, sourceProj,\n      _ol_proj_.createTransformFromCoordinateTransform(inverse));\n};\n\n\n/**\n * Creates a {@link ol.TransformFunction} from a simple 2D coordinate transform\n * function.\n * @param {function(ol.Coordinate): ol.Coordinate} transform Coordinate\n *     transform.\n * @return {ol.TransformFunction} Transform function.\n */\n_ol_proj_.createTransformFromCoordinateTransform = function(transform) {\n  return (\n    /**\n     * @param {Array.<number>} input Input.\n     * @param {Array.<number>=} opt_output Output.\n     * @param {number=} opt_dimension Dimension.\n     * @return {Array.<number>} Output.\n     */\n    function(input, opt_output, opt_dimension) {\n      var length = input.length;\n      var dimension = opt_dimension !== undefined ? opt_dimension : 2;\n      var output = opt_output !== undefined ? opt_output : new Array(length);\n      var point, i, j;\n      for (i = 0; i < length; i += dimension) {\n        point = transform([input[i], input[i + 1]]);\n        output[i] = point[0];\n        output[i + 1] = point[1];\n        for (j = dimension - 1; j >= 2; --j) {\n          output[i + j] = input[i + j];\n        }\n      }\n      return output;\n    });\n};\n\n\n/**\n * Transforms a coordinate from longitude/latitude to a different projection.\n * @param {ol.Coordinate} coordinate Coordinate as longitude and latitude, i.e.\n *     an array with longitude as 1st and latitude as 2nd element.\n * @param {ol.ProjectionLike=} opt_projection Target projection. The\n *     default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {ol.Coordinate} Coordinate projected to the target projection.\n * @api\n */\n_ol_proj_.fromLonLat = function(coordinate, opt_projection) {\n  return _ol_proj_.transform(coordinate, 'EPSG:4326',\n      opt_projection !== undefined ? opt_projection : 'EPSG:3857');\n};\n\n\n/**\n * Transforms a coordinate to longitude/latitude.\n * @param {ol.Coordinate} coordinate Projected coordinate.\n * @param {ol.ProjectionLike=} opt_projection Projection of the coordinate.\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {ol.Coordinate} Coordinate as longitude and latitude, i.e. an array\n *     with longitude as 1st and latitude as 2nd element.\n * @api\n */\n_ol_proj_.toLonLat = function(coordinate, opt_projection) {\n  var lonLat = _ol_proj_.transform(coordinate,\n      opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');\n  var lon = lonLat[0];\n  if (lon < -180 || lon > 180) {\n    lonLat[0] = _ol_math_.modulo(lon + 180, 360) - 180;\n  }\n  return lonLat;\n};\n\n\n/**\n * Fetches a Projection object for the code specified.\n *\n * @param {ol.ProjectionLike} projectionLike Either a code string which is\n *     a combination of authority and identifier such as \"EPSG:4326\", or an\n *     existing projection object, or undefined.\n * @return {ol.proj.Projection} Projection object, or null if not in list.\n * @api\n */\n_ol_proj_.get = function(projectionLike) {\n  var projection = null;\n  if (projectionLike instanceof _ol_proj_Projection_) {\n    projection = projectionLike;\n  } else if (typeof projectionLike === 'string') {\n    var code = projectionLike;\n    projection = _ol_proj_projections_.get(code);\n    if (_ol_.ENABLE_PROJ4JS && !projection) {\n      var proj4js = _ol_proj_proj4_.get();\n      if (typeof proj4js == 'function' &&\n          proj4js.defs(code) !== undefined) {\n        projection = new _ol_proj_Projection_({code: code});\n        _ol_proj_.addProjection(projection);\n      }\n    }\n  }\n  return projection;\n};\n\n\n/**\n * Checks if two projections are the same, that is every coordinate in one\n * projection does represent the same geographic point as the same coordinate in\n * the other projection.\n *\n * @param {ol.proj.Projection} projection1 Projection 1.\n * @param {ol.proj.Projection} projection2 Projection 2.\n * @return {boolean} Equivalent.\n * @api\n */\n_ol_proj_.equivalent = function(projection1, projection2) {\n  if (projection1 === projection2) {\n    return true;\n  }\n  var equalUnits = projection1.getUnits() === projection2.getUnits();\n  if (projection1.getCode() === projection2.getCode()) {\n    return equalUnits;\n  } else {\n    var transformFn = _ol_proj_.getTransformFromProjections(\n        projection1, projection2);\n    return transformFn === _ol_proj_.cloneTransform && equalUnits;\n  }\n};\n\n\n/**\n * Given the projection-like objects, searches for a transformation\n * function to convert a coordinates array from the source projection to the\n * destination projection.\n *\n * @param {ol.ProjectionLike} source Source.\n * @param {ol.ProjectionLike} destination Destination.\n * @return {ol.TransformFunction} Transform function.\n * @api\n */\n_ol_proj_.getTransform = function(source, destination) {\n  var sourceProjection = _ol_proj_.get(source);\n  var destinationProjection = _ol_proj_.get(destination);\n  return _ol_proj_.getTransformFromProjections(\n      sourceProjection, destinationProjection);\n};\n\n\n/**\n * Searches in the list of transform functions for the function for converting\n * coordinates from the source projection to the destination projection.\n *\n * @param {ol.proj.Projection} sourceProjection Source Projection object.\n * @param {ol.proj.Projection} destinationProjection Destination Projection\n *     object.\n * @return {ol.TransformFunction} Transform function.\n */\n_ol_proj_.getTransformFromProjections = function(sourceProjection, destinationProjection) {\n  var sourceCode = sourceProjection.getCode();\n  var destinationCode = destinationProjection.getCode();\n  var transform = _ol_proj_transforms_.get(sourceCode, destinationCode);\n  if (_ol_.ENABLE_PROJ4JS && !transform) {\n    var proj4js = _ol_proj_proj4_.get();\n    if (typeof proj4js == 'function') {\n      var sourceDef = proj4js.defs(sourceCode);\n      var destinationDef = proj4js.defs(destinationCode);\n\n      if (sourceDef !== undefined && destinationDef !== undefined) {\n        if (sourceDef === destinationDef) {\n          _ol_proj_.addEquivalentProjections([destinationProjection, sourceProjection]);\n        } else {\n          var proj4Transform = proj4js(destinationCode, sourceCode);\n          _ol_proj_.addCoordinateTransforms(destinationProjection, sourceProjection,\n              proj4Transform.forward, proj4Transform.inverse);\n        }\n        transform = _ol_proj_transforms_.get(sourceCode, destinationCode);\n      }\n    }\n  }\n  if (!transform) {\n    transform = _ol_proj_.identityTransform;\n  }\n  return transform;\n};\n\n\n/**\n * @param {Array.<number>} input Input coordinate array.\n * @param {Array.<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension.\n * @return {Array.<number>} Input coordinate array (same array as input).\n */\n_ol_proj_.identityTransform = function(input, opt_output, opt_dimension) {\n  if (opt_output !== undefined && input !== opt_output) {\n    for (var i = 0, ii = input.length; i < ii; ++i) {\n      opt_output[i] = input[i];\n    }\n    input = opt_output;\n  }\n  return input;\n};\n\n\n/**\n * @param {Array.<number>} input Input coordinate array.\n * @param {Array.<number>=} opt_output Output array of coordinate values.\n * @param {number=} opt_dimension Dimension.\n * @return {Array.<number>} Output coordinate array (new array, same coordinate\n *     values).\n */\n_ol_proj_.cloneTransform = function(input, opt_output, opt_dimension) {\n  var output;\n  if (opt_output !== undefined) {\n    for (var i = 0, ii = input.length; i < ii; ++i) {\n      opt_output[i] = input[i];\n    }\n    output = opt_output;\n  } else {\n    output = input.slice();\n  }\n  return output;\n};\n\n\n/**\n * Transforms a coordinate from source projection to destination projection.\n * This returns a new coordinate (and does not modify the original).\n *\n * See {@link ol.proj.transformExtent} for extent transformation.\n * See the transform method of {@link ol.geom.Geometry} and its subclasses for\n * geometry transforms.\n *\n * @param {ol.Coordinate} coordinate Coordinate.\n * @param {ol.ProjectionLike} source Source projection-like.\n * @param {ol.ProjectionLike} destination Destination projection-like.\n * @return {ol.Coordinate} Coordinate.\n * @api\n */\n_ol_proj_.transform = function(coordinate, source, destination) {\n  var transformFn = _ol_proj_.getTransform(source, destination);\n  return transformFn(coordinate, undefined, coordinate.length);\n};\n\n\n/**\n * Transforms an extent from source projection to destination projection.  This\n * returns a new extent (and does not modify the original).\n *\n * @param {ol.Extent} extent The extent to transform.\n * @param {ol.ProjectionLike} source Source projection-like.\n * @param {ol.ProjectionLike} destination Destination projection-like.\n * @return {ol.Extent} The transformed extent.\n * @api\n */\n_ol_proj_.transformExtent = function(extent, source, destination) {\n  var transformFn = _ol_proj_.getTransform(source, destination);\n  return _ol_extent_.applyTransform(extent, transformFn);\n};\n\n\n/**\n * Transforms the given point to the destination projection.\n *\n * @param {ol.Coordinate} point Point.\n * @param {ol.proj.Projection} sourceProjection Source projection.\n * @param {ol.proj.Projection} destinationProjection Destination projection.\n * @return {ol.Coordinate} Point.\n */\n_ol_proj_.transformWithProjections = function(point, sourceProjection, destinationProjection) {\n  var transformFn = _ol_proj_.getTransformFromProjections(\n      sourceProjection, destinationProjection);\n  return transformFn(point);\n};\n\n/**\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n * by when this module is executed and should only need to be called again after\n * `ol.proj.clearAllProjections()` is called (e.g. in tests).\n */\n_ol_proj_.addCommon = function() {\n  // Add transformations that don't alter coordinates to convert within set of\n  // projections with equal meaning.\n  _ol_proj_.addEquivalentProjections(_ol_proj_EPSG3857_.PROJECTIONS);\n  _ol_proj_.addEquivalentProjections(_ol_proj_EPSG4326_.PROJECTIONS);\n  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n  // coordinates and back.\n  _ol_proj_.addEquivalentTransforms(\n      _ol_proj_EPSG4326_.PROJECTIONS,\n      _ol_proj_EPSG3857_.PROJECTIONS,\n      _ol_proj_EPSG3857_.fromEPSG4326,\n      _ol_proj_EPSG3857_.toEPSG4326);\n};\n\n_ol_proj_.addCommon();\nexport default _ol_proj_;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}