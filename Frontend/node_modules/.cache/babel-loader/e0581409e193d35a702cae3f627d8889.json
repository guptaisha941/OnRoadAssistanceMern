{"ast":null,"code":"/**\n * @module ol/geom/MultiPolygon\n */\nimport { extend } from '../array.js';\nimport { closestSquaredDistanceXY } from '../extent.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport { linearRingss as linearRingssArea } from './flat/area.js';\nimport { linearRingss as linearRingssCenter } from './flat/center.js';\nimport { assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta } from './flat/closest.js';\nimport { linearRingssContainsXY } from './flat/contains.js';\nimport { deflateMultiCoordinatesArray } from './flat/deflate.js';\nimport { inflateMultiCoordinatesArray } from './flat/inflate.js';\nimport { getInteriorPointsOfMultiArray } from './flat/interiorpoint.js';\nimport { intersectsLinearRingMultiArray } from './flat/intersectsextent.js';\nimport { linearRingsAreOriented, orientLinearRingsArray } from './flat/orient.js';\nimport { quantizeMultiArray } from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nvar MultiPolygon = /*@__PURE__*/function (SimpleGeometry) {\n  function MultiPolygon(coordinates, opt_layout, opt_endss) {\n    SimpleGeometry.call(this);\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.endss_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointsRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.orientedFlatCoordinates_ = null;\n    if (!opt_endss && !Array.isArray(coordinates[0])) {\n      var layout = this.getLayout();\n      var polygons = /** @type {Array<Polygon>} */coordinates;\n      var flatCoordinates = [];\n      var endss = [];\n      for (var i = 0, ii = polygons.length; i < ii; ++i) {\n        var polygon = polygons[i];\n        if (i === 0) {\n          layout = polygon.getLayout();\n        }\n        var offset = flatCoordinates.length;\n        var ends = polygon.getEnds();\n        for (var j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        endss.push(ends);\n      }\n      opt_layout = layout;\n      coordinates = flatCoordinates;\n      opt_endss = endss;\n    }\n    if (opt_layout !== undefined && opt_endss) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */coordinates);\n      this.endss_ = opt_endss;\n    } else {\n      this.setCoordinates( /** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */coordinates, opt_layout);\n    }\n  }\n  if (SimpleGeometry) MultiPolygon.__proto__ = SimpleGeometry;\n  MultiPolygon.prototype = Object.create(SimpleGeometry && SimpleGeometry.prototype);\n  MultiPolygon.prototype.constructor = MultiPolygon;\n\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n  MultiPolygon.prototype.appendPolygon = function appendPolygon(polygon) {\n    /** @type {Array<number>} */\n    var ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      var offset = this.flatCoordinates.length;\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPolygon} Clone.\n   * @override\n   * @api\n   */\n  MultiPolygon.prototype.clone = function clone() {\n    var len = this.endss_.length;\n    var newEndss = new Array(len);\n    for (var i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n    return new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPolygon.prototype.closestPointXY = function closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPolygon.prototype.containsXY = function containsXY(x, y) {\n    return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n  };\n\n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  MultiPolygon.prototype.getArea = function getArea() {\n    return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n  };\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean=} opt_right Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n   * @override\n   * @api\n   */\n  MultiPolygon.prototype.getCoordinates = function getCoordinates(opt_right) {\n    var flatCoordinates;\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n    return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);\n  };\n\n  /**\n   * @return {Array<Array<number>>} Endss.\n   */\n  MultiPolygon.prototype.getEndss = function getEndss() {\n    return this.endss_;\n  };\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  MultiPolygon.prototype.getFlatInteriorPoints = function getFlatInteriorPoints() {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      var flatCenters = linearRingssCenter(this.flatCoordinates, 0, this.endss_, this.stride);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoints_;\n  };\n\n  /**\n   * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  MultiPolygon.prototype.getInteriorPoints = function getInteriorPoints() {\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);\n  };\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  MultiPolygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      var flatCoordinates = this.flatCoordinates;\n      if (linearRingsAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPolygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal(squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);\n    return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);\n  };\n\n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {Polygon} Polygon.\n   * @api\n   */\n  MultiPolygon.prototype.getPolygon = function getPolygon(index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n    var offset;\n    if (index === 0) {\n      offset = 0;\n    } else {\n      var prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n    var ends = this.endss_[index].slice();\n    var end = ends[ends.length - 1];\n    if (offset !== 0) {\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n    return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);\n  };\n\n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array<Polygon>} Polygons.\n   * @api\n   */\n  MultiPolygon.prototype.getPolygons = function getPolygons() {\n    var layout = this.layout;\n    var flatCoordinates = this.flatCoordinates;\n    var endss = this.endss_;\n    var polygons = [];\n    var offset = 0;\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i].slice();\n      var end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (var j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n      var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);\n      polygons.push(polygon);\n      offset = end;\n    }\n    return polygons;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiPolygon.prototype.getType = function getType() {\n    return GeometryType.MULTI_POLYGON;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiPolygon.prototype.intersectsExtent = function intersectsExtent(extent) {\n    return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n  };\n\n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  MultiPolygon.prototype.setCoordinates = function setCoordinates(coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      var lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  };\n  return MultiPolygon;\n}(SimpleGeometry);\nexport default MultiPolygon;","map":{"version":3,"names":["extend","closestSquaredDistanceXY","GeometryLayout","GeometryType","MultiPoint","Polygon","SimpleGeometry","linearRingss","linearRingssArea","linearRingssCenter","assignClosestMultiArrayPoint","multiArrayMaxSquaredDelta","linearRingssContainsXY","deflateMultiCoordinatesArray","inflateMultiCoordinatesArray","getInteriorPointsOfMultiArray","intersectsLinearRingMultiArray","linearRingsAreOriented","orientLinearRingsArray","quantizeMultiArray","MultiPolygon","coordinates","opt_layout","opt_endss","call","endss_","flatInteriorPointsRevision_","flatInteriorPoints_","maxDelta_","maxDeltaRevision_","orientedRevision_","orientedFlatCoordinates_","Array","isArray","layout","getLayout","polygons","flatCoordinates","endss","i","ii","length","polygon","offset","ends","getEnds","j","jj","getFlatCoordinates","push","undefined","setFlatCoordinates","setCoordinates","appendPolygon","slice","changed","clone","len","newEndss","closestPointXY","x","y","closestPoint","minSquaredDistance","getExtent","getRevision","Math","sqrt","stride","getOrientedFlatCoordinates","containsXY","getArea","getCoordinates","opt_right","getEndss","getFlatInteriorPoints","flatCenters","getInteriorPoints","XYM","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","simplifiedEndss","XY","getPolygon","index","prevEnds","end","getPolygons","getType","MULTI_POLYGON","intersectsExtent","extent","setLayout","lastEnds"],"sources":["../../../src/ol/geom/MultiPolygon.js"],"sourcesContent":["/**\n * @module ol/geom/MultiPolygon\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {linearRingss as linearRingssArea} from './flat/area.js';\nimport {linearRingss as linearRingssCenter} from './flat/center.js';\nimport {assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta} from './flat/closest.js';\nimport {linearRingssContainsXY} from './flat/contains.js';\nimport {deflateMultiCoordinatesArray} from './flat/deflate.js';\nimport {inflateMultiCoordinatesArray} from './flat/inflate.js';\nimport {getInteriorPointsOfMultiArray} from './flat/interiorpoint.js';\nimport {intersectsLinearRingMultiArray} from './flat/intersectsextent.js';\nimport {linearRingsAreOriented, orientLinearRingsArray} from './flat/orient.js';\nimport {quantizeMultiArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nclass MultiPolygon extends SimpleGeometry {\n\n  /**\n   * @param {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `opt_layout` and `opt_endss` are also accepted.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @param {Array<Array<number>>=} opt_endss Array of ends for internal use with flat coordinates.\n   */\n  constructor(coordinates, opt_layout, opt_endss) {\n\n    super();\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.endss_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointsRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (!opt_endss && !Array.isArray(coordinates[0])) {\n      let layout = this.getLayout();\n      const polygons = /** @type {Array<Polygon>} */ (coordinates);\n      const flatCoordinates = [];\n      const endss = [];\n      for (let i = 0, ii = polygons.length; i < ii; ++i) {\n        const polygon = polygons[i];\n        if (i === 0) {\n          layout = polygon.getLayout();\n        }\n        const offset = flatCoordinates.length;\n        const ends = polygon.getEnds();\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        endss.push(ends);\n      }\n      opt_layout = layout;\n      coordinates = flatCoordinates;\n      opt_endss = endss;\n    }\n    if (opt_layout !== undefined && opt_endss) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n      this.endss_ = opt_endss;\n    } else {\n      this.setCoordinates(/** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (coordinates),\n        opt_layout);\n    }\n\n  }\n\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n  appendPolygon(polygon) {\n    /** @type {Array<number>} */\n    let ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      const offset = this.flatCoordinates.length;\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPolygon} Clone.\n   * @override\n   * @api\n   */\n  clone() {\n    const len = this.endss_.length;\n    const newEndss = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n\n    return new MultiPolygon(\n      this.flatCoordinates.slice(), this.layout, newEndss);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(\n        this.flatCoordinates, 0, this.endss_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestMultiArrayPoint(\n      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,\n      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  containsXY(x, y) {\n    return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n  }\n\n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n  }\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean=} opt_right Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n   * @override\n   * @api\n   */\n  getCoordinates(opt_right) {\n    let flatCoordinates;\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(\n        flatCoordinates, 0, this.endss_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateMultiCoordinatesArray(\n      flatCoordinates, 0, this.endss_, this.stride);\n  }\n\n  /**\n   * @return {Array<Array<number>>} Endss.\n   */\n  getEndss() {\n    return this.endss_;\n  }\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  getFlatInteriorPoints() {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      const flatCenters = linearRingssCenter(\n        this.flatCoordinates, 0, this.endss_, this.stride);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\n        this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,\n        flatCenters);\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoints_;\n  }\n\n  /**\n   * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  getInteriorPoints() {\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);\n  }\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      const flatCoordinates = this.flatCoordinates;\n      if (linearRingsAreOriented(\n        flatCoordinates, 0, this.endss_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length =\n            orientLinearRingsArray(\n              this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    const simplifiedFlatCoordinates = [];\n    const simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(\n      this.flatCoordinates, 0, this.endss_, this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates, 0, simplifiedEndss);\n    return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);\n  }\n\n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {Polygon} Polygon.\n   * @api\n   */\n  getPolygon(index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n    let offset;\n    if (index === 0) {\n      offset = 0;\n    } else {\n      const prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n    const ends = this.endss_[index].slice();\n    const end = ends[ends.length - 1];\n    if (offset !== 0) {\n      for (let i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n    return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);\n  }\n\n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array<Polygon>} Polygons.\n   * @api\n   */\n  getPolygons() {\n    const layout = this.layout;\n    const flatCoordinates = this.flatCoordinates;\n    const endss = this.endss_;\n    const polygons = [];\n    let offset = 0;\n    for (let i = 0, ii = endss.length; i < ii; ++i) {\n      const ends = endss[i].slice();\n      const end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (let j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n      const polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);\n      polygons.push(polygon);\n      offset = end;\n    }\n    return polygons;\n  }\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  getType() {\n    return GeometryType.MULTI_POLYGON;\n  }\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  intersectsExtent(extent) {\n    return intersectsLinearRingMultiArray(\n      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n  }\n\n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  setCoordinates(coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const endss = deflateMultiCoordinatesArray(\n      this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      const lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length = lastEnds.length === 0 ?\n        0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  }\n}\n\n\nexport default MultiPolygon;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}