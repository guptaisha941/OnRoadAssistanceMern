{"ast":null,"code":"/**\n * @module ol/renderer/canvas/VectorLayer\n */\nimport { getUid } from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport ViewHint from '../../ViewHint.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { listen, unlisten } from '../../events.js';\nimport EventType from '../../events/EventType.js';\nimport rbush from 'rbush';\nimport { buffer, createEmpty, containsExtent, getWidth } from '../../extent.js';\nimport RenderEventType from '../../render/EventType.js';\nimport { labelCache, rotateAtOffset } from '../../render/canvas.js';\nimport CanvasReplayGroup from '../../render/canvas/ReplayGroup.js';\nimport CanvasLayerRenderer from './Layer.js';\nimport { defaultOrder as defaultRenderOrder, getTolerance as getRenderTolerance, getSquaredTolerance as getSquaredRenderTolerance, renderFeature } from '../vector.js';\n\n/**\n * @classdesc\n * Canvas renderer for vector layers.\n * @api\n */\nvar CanvasVectorLayerRenderer = /*@__PURE__*/function (CanvasLayerRenderer) {\n  function CanvasVectorLayerRenderer(vectorLayer) {\n    CanvasLayerRenderer.call(this, vectorLayer);\n\n    /**\n     * Declutter tree.\n     * @private\n     */\n    this.declutterTree_ = vectorLayer.getDeclutter() ? rbush(9, undefined) : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.dirty_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedResolution_ = NaN;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {function(import(\"../../Feature.js\").default, import(\"../../Feature.js\").default): number|null}\n     */\n    this.renderedRenderOrder_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../render/canvas/ReplayGroup.js\").default}\n     */\n    this.replayGroup_ = null;\n\n    /**\n     * A new replay group had to be created by `prepareFrame()`\n     * @type {boolean}\n     */\n    this.replayGroupChanged = true;\n\n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = createCanvasContext2D();\n    listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n  }\n  if (CanvasLayerRenderer) CanvasVectorLayerRenderer.__proto__ = CanvasLayerRenderer;\n  CanvasVectorLayerRenderer.prototype = Object.create(CanvasLayerRenderer && CanvasLayerRenderer.prototype);\n  CanvasVectorLayerRenderer.prototype.constructor = CanvasVectorLayerRenderer;\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorLayerRenderer.prototype.disposeInternal = function disposeInternal() {\n    unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n    CanvasLayerRenderer.prototype.disposeInternal.call(this);\n  };\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   */\n  CanvasVectorLayerRenderer.prototype.compose = function compose(context, frameState, layerState) {\n    var extent = frameState.extent;\n    var pixelRatio = frameState.pixelRatio;\n    var skippedFeatureUids = layerState.managed ? frameState.skippedFeatureUids : {};\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var rotation = viewState.rotation;\n    var projectionExtent = projection.getExtent();\n    var vectorSource = /** @type {import(\"../../source/Vector.js\").default} */this.getLayer().getSource();\n    var transform = this.getTransform(frameState, 0);\n\n    // clipped rendering if layer extent is set\n    var clipExtent = layerState.extent;\n    var clipped = clipExtent !== undefined;\n    if (clipped) {\n      this.clip(context, frameState, /** @type {import(\"../../extent.js\").Extent} */clipExtent);\n    }\n    var replayGroup = this.replayGroup_;\n    if (replayGroup && !replayGroup.isEmpty()) {\n      if (this.declutterTree_) {\n        this.declutterTree_.clear();\n      }\n      var layer = /** @type {import(\"../../layer/Vector.js\").default} */this.getLayer();\n      var drawOffsetX = 0;\n      var drawOffsetY = 0;\n      var replayContext;\n      var transparentLayer = layerState.opacity !== 1;\n      var hasRenderListeners = layer.hasListener(RenderEventType.RENDER);\n      if (transparentLayer || hasRenderListeners) {\n        var drawWidth = context.canvas.width;\n        var drawHeight = context.canvas.height;\n        if (rotation) {\n          var drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));\n          drawOffsetX = (drawSize - drawWidth) / 2;\n          drawOffsetY = (drawSize - drawHeight) / 2;\n          drawWidth = drawHeight = drawSize;\n        }\n        // resize and clear\n        this.context.canvas.width = drawWidth;\n        this.context.canvas.height = drawHeight;\n        replayContext = this.context;\n      } else {\n        replayContext = context;\n      }\n      var alpha = replayContext.globalAlpha;\n      if (!transparentLayer) {\n        // for performance reasons, context.save / context.restore is not used\n        // to save and restore the transformation matrix and the opacity.\n        // see http://jsperf.com/context-save-restore-versus-variable\n        replayContext.globalAlpha = layerState.opacity;\n      }\n      if (replayContext != context) {\n        replayContext.translate(drawOffsetX, drawOffsetY);\n      }\n      var viewHints = frameState.viewHints;\n      var snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n      var width = frameState.size[0] * pixelRatio;\n      var height = frameState.size[1] * pixelRatio;\n      rotateAtOffset(replayContext, -rotation, width / 2, height / 2);\n      replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);\n      if (vectorSource.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent)) {\n        var startX = extent[0];\n        var worldWidth = getWidth(projectionExtent);\n        var world = 0;\n        var offsetX;\n        while (startX < projectionExtent[0]) {\n          --world;\n          offsetX = worldWidth * world;\n          transform = this.getTransform(frameState, offsetX);\n          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);\n          startX += worldWidth;\n        }\n        world = 0;\n        startX = extent[2];\n        while (startX > projectionExtent[2]) {\n          ++world;\n          offsetX = worldWidth * world;\n          transform = this.getTransform(frameState, offsetX);\n          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);\n          startX -= worldWidth;\n        }\n      }\n      rotateAtOffset(replayContext, rotation, width / 2, height / 2);\n      if (hasRenderListeners) {\n        this.dispatchRenderEvent(replayContext, frameState, transform);\n      }\n      if (replayContext != context) {\n        if (transparentLayer) {\n          var mainContextAlpha = context.globalAlpha;\n          context.globalAlpha = layerState.opacity;\n          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\n          context.globalAlpha = mainContextAlpha;\n        } else {\n          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\n        }\n        replayContext.translate(-drawOffsetX, -drawOffsetY);\n      }\n      if (!transparentLayer) {\n        replayContext.globalAlpha = alpha;\n      }\n    }\n    if (clipped) {\n      context.restore();\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorLayerRenderer.prototype.composeFrame = function composeFrame(frameState, layerState, context) {\n    var transform = this.getTransform(frameState, 0);\n    this.preCompose(context, frameState, transform);\n    this.compose(context, frameState, layerState);\n    this.postCompose(context, frameState, layerState, transform);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    if (!this.replayGroup_) {\n      return undefined;\n    } else {\n      var resolution = frameState.viewState.resolution;\n      var rotation = frameState.viewState.rotation;\n      var layer = /** @type {import(\"../../layer/Vector.js\").default} */this.getLayer();\n      /** @type {!Object<string, boolean>} */\n      var features = {};\n      var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @return {?} Callback result.\n       */\n      function (feature) {\n        var key = getUid(feature);\n        if (!(key in features)) {\n          features[key] = true;\n          return callback.call(thisArg, feature, layer);\n        }\n      }, null);\n      return result;\n    }\n  };\n\n  /**\n   * @param {import(\"../../events/Event.js\").default} event Event.\n   */\n  CanvasVectorLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_(event) {\n    var layer = this.getLayer();\n    if (layer.getVisible() && this.replayGroup_) {\n      layer.changed();\n    }\n  };\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasVectorLayerRenderer.prototype.prepareFrame = function prepareFrame(frameState, layerState) {\n    var vectorLayer = /** @type {import(\"../../layer/Vector.js\").default} */this.getLayer();\n    var vectorSource = /** @type {import(\"../../source/Vector.js\").default} */vectorLayer.getSource();\n    var animating = frameState.viewHints[ViewHint.ANIMATING];\n    var interacting = frameState.viewHints[ViewHint.INTERACTING];\n    var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n    var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n    if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {\n      return true;\n    }\n    var frameStateExtent = frameState.extent;\n    var viewState = frameState.viewState;\n    var projection = viewState.projection;\n    var resolution = viewState.resolution;\n    var pixelRatio = frameState.pixelRatio;\n    var vectorLayerRevision = vectorLayer.getRevision();\n    var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n    var vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n    if (vectorLayerRenderOrder === undefined) {\n      vectorLayerRenderOrder = defaultRenderOrder;\n    }\n    var extent = buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);\n    var projectionExtent = viewState.projection.getExtent();\n    if (vectorSource.getWrapX() && viewState.projection.canWrapX() && !containsExtent(projectionExtent, frameState.extent)) {\n      // For the replay group, we need an extent that intersects the real world\n      // (-180° to +180°). To support geometries in a coordinate range from -540°\n      // to +540°, we add at least 1 world width on each side of the projection\n      // extent. If the viewport is wider than the world, we need to add half of\n      // the viewport width to make sure we cover the whole viewport.\n      var worldWidth = getWidth(projectionExtent);\n      var gutter = Math.max(getWidth(extent) / 2, worldWidth);\n      extent[0] = projectionExtent[0] - gutter;\n      extent[2] = projectionExtent[2] + gutter;\n    }\n    if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && containsExtent(this.renderedExtent_, extent)) {\n      this.replayGroupChanged = false;\n      return true;\n    }\n    this.replayGroup_ = null;\n    this.dirty_ = false;\n    var replayGroup = new CanvasReplayGroup(getRenderTolerance(resolution, pixelRatio), extent, resolution, pixelRatio, vectorSource.getOverlaps(), this.declutterTree_, vectorLayer.getRenderBuffer());\n    vectorSource.loadFeatures(extent, resolution, projection);\n    /**\n     * @param {import(\"../../Feature.js\").default} feature Feature.\n     * @this {CanvasVectorLayerRenderer}\n     */\n    var render = function (feature) {\n      var styles;\n      var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();\n      if (styleFunction) {\n        styles = styleFunction(feature, resolution);\n      }\n      if (styles) {\n        var dirty = this.renderFeature(feature, resolution, pixelRatio, styles, replayGroup);\n        this.dirty_ = this.dirty_ || dirty;\n      }\n    }.bind(this);\n    if (vectorLayerRenderOrder) {\n      /** @type {Array<import(\"../../Feature.js\").default>} */\n      var features = [];\n      vectorSource.forEachFeatureInExtent(extent,\n      /**\n       * @param {import(\"../../Feature.js\").default} feature Feature.\n       */\n      function (feature) {\n        features.push(feature);\n      });\n      features.sort(vectorLayerRenderOrder);\n      for (var i = 0, ii = features.length; i < ii; ++i) {\n        render(features[i]);\n      }\n    } else {\n      vectorSource.forEachFeatureInExtent(extent, render);\n    }\n    replayGroup.finish();\n    this.renderedResolution_ = resolution;\n    this.renderedRevision_ = vectorLayerRevision;\n    this.renderedRenderOrder_ = vectorLayerRenderOrder;\n    this.renderedExtent_ = extent;\n    this.replayGroup_ = replayGroup;\n    this.replayGroupChanged = true;\n    return true;\n  };\n\n  /**\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/ReplayGroup.js\").default} replayGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n  CanvasVectorLayerRenderer.prototype.renderFeature = function renderFeature$1(feature, resolution, pixelRatio, styles, replayGroup) {\n    if (!styles) {\n      return false;\n    }\n    var loading = false;\n    if (Array.isArray(styles)) {\n      for (var i = 0, ii = styles.length; i < ii; ++i) {\n        loading = renderFeature(replayGroup, feature, styles[i], getSquaredRenderTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;\n      }\n    } else {\n      loading = renderFeature(replayGroup, feature, styles, getSquaredRenderTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this);\n    }\n    return loading;\n  };\n  return CanvasVectorLayerRenderer;\n}(CanvasLayerRenderer);\n\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\nCanvasVectorLayerRenderer['handles'] = function (layer) {\n  return layer.getType() === LayerType.VECTOR;\n};\n\n/**\n * Create a layer renderer.\n * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n * @return {CanvasVectorLayerRenderer} The layer renderer.\n */\nCanvasVectorLayerRenderer['create'] = function (mapRenderer, layer) {\n  return new CanvasVectorLayerRenderer( /** @type {import(\"../../layer/Vector.js\").default} */layer);\n};\nexport default CanvasVectorLayerRenderer;","map":{"version":3,"names":["getUid","LayerType","ViewHint","createCanvasContext2D","listen","unlisten","EventType","rbush","buffer","createEmpty","containsExtent","getWidth","RenderEventType","labelCache","rotateAtOffset","CanvasReplayGroup","CanvasLayerRenderer","defaultOrder","defaultRenderOrder","getTolerance","getRenderTolerance","getSquaredTolerance","getSquaredRenderTolerance","renderFeature","CanvasVectorLayerRenderer","vectorLayer","call","declutterTree_","getDeclutter","undefined","dirty_","renderedRevision_","renderedResolution_","NaN","renderedExtent_","renderedRenderOrder_","replayGroup_","replayGroupChanged","context","CLEAR","handleFontsChanged_","disposeInternal","prototype","compose","frameState","layerState","extent","pixelRatio","skippedFeatureUids","managed","viewState","projection","rotation","projectionExtent","getExtent","vectorSource","getLayer","getSource","transform","getTransform","clipExtent","clipped","clip","replayGroup","isEmpty","clear","layer","drawOffsetX","drawOffsetY","replayContext","transparentLayer","opacity","hasRenderListeners","hasListener","RENDER","drawWidth","canvas","width","drawHeight","height","drawSize","Math","round","sqrt","alpha","globalAlpha","translate","viewHints","snapToPixel","ANIMATING","INTERACTING","size","replay","getWrapX","canWrapX","startX","worldWidth","world","offsetX","dispatchRenderEvent","mainContextAlpha","drawImage","restore","composeFrame","preCompose","postCompose","forEachFeatureAtCoordinate","coordinate","hitTolerance","callback","thisArg","resolution","features","result","feature","key","event","getVisible","changed","handleStyleImageChange_","renderIfReadyAndVisible","prepareFrame","animating","interacting","updateWhileAnimating","getUpdateWhileAnimating","updateWhileInteracting","getUpdateWhileInteracting","frameStateExtent","vectorLayerRevision","getRevision","vectorLayerRenderBuffer","getRenderBuffer","vectorLayerRenderOrder","getRenderOrder","gutter","max","getOverlaps","loadFeatures","render","styles","styleFunction","getStyleFunction","dirty","bind","forEachFeatureInExtent","push","sort","i","ii","length","finish","renderFeature$1","loading","Array","isArray","getType","VECTOR","mapRenderer"],"sources":["../../../../src/ol/renderer/canvas/VectorLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/VectorLayer\n */\nimport {getUid} from '../../util.js';\nimport LayerType from '../../LayerType.js';\nimport ViewHint from '../../ViewHint.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {listen, unlisten} from '../../events.js';\nimport EventType from '../../events/EventType.js';\nimport rbush from 'rbush';\nimport {buffer, createEmpty, containsExtent, getWidth} from '../../extent.js';\nimport RenderEventType from '../../render/EventType.js';\nimport {labelCache, rotateAtOffset} from '../../render/canvas.js';\nimport CanvasReplayGroup from '../../render/canvas/ReplayGroup.js';\nimport CanvasLayerRenderer from './Layer.js';\nimport {defaultOrder as defaultRenderOrder, getTolerance as getRenderTolerance, getSquaredTolerance as getSquaredRenderTolerance, renderFeature} from '../vector.js';\n\n/**\n * @classdesc\n * Canvas renderer for vector layers.\n * @api\n */\nclass CanvasVectorLayerRenderer extends CanvasLayerRenderer {\n\n  /**\n   * @param {import(\"../../layer/Vector.js\").default} vectorLayer Vector layer.\n   */\n  constructor(vectorLayer) {\n\n    super(vectorLayer);\n\n    /**\n     * Declutter tree.\n     * @private\n     */\n    this.declutterTree_ = vectorLayer.getDeclutter() ? rbush(9, undefined) : null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.dirty_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedResolution_ = NaN;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {function(import(\"../../Feature.js\").default, import(\"../../Feature.js\").default): number|null}\n     */\n    this.renderedRenderOrder_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../render/canvas/ReplayGroup.js\").default}\n     */\n    this.replayGroup_ = null;\n\n    /**\n     * A new replay group had to be created by `prepareFrame()`\n     * @type {boolean}\n     */\n    this.replayGroupChanged = true;\n\n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = createCanvasContext2D();\n\n    listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n\n  }\n\n  /**\n   * @inheritDoc\n   */\n  disposeInternal() {\n    unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);\n    super.disposeInternal();\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   */\n  compose(context, frameState, layerState) {\n    const extent = frameState.extent;\n    const pixelRatio = frameState.pixelRatio;\n    const skippedFeatureUids = layerState.managed ?\n      frameState.skippedFeatureUids : {};\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const rotation = viewState.rotation;\n    const projectionExtent = projection.getExtent();\n    const vectorSource = /** @type {import(\"../../source/Vector.js\").default} */ (this.getLayer().getSource());\n\n    let transform = this.getTransform(frameState, 0);\n\n    // clipped rendering if layer extent is set\n    const clipExtent = layerState.extent;\n    const clipped = clipExtent !== undefined;\n    if (clipped) {\n      this.clip(context, frameState, /** @type {import(\"../../extent.js\").Extent} */ (clipExtent));\n    }\n    const replayGroup = this.replayGroup_;\n    if (replayGroup && !replayGroup.isEmpty()) {\n      if (this.declutterTree_) {\n        this.declutterTree_.clear();\n      }\n      const layer = /** @type {import(\"../../layer/Vector.js\").default} */ (this.getLayer());\n      let drawOffsetX = 0;\n      let drawOffsetY = 0;\n      let replayContext;\n      const transparentLayer = layerState.opacity !== 1;\n      const hasRenderListeners = layer.hasListener(RenderEventType.RENDER);\n      if (transparentLayer || hasRenderListeners) {\n        let drawWidth = context.canvas.width;\n        let drawHeight = context.canvas.height;\n        if (rotation) {\n          const drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));\n          drawOffsetX = (drawSize - drawWidth) / 2;\n          drawOffsetY = (drawSize - drawHeight) / 2;\n          drawWidth = drawHeight = drawSize;\n        }\n        // resize and clear\n        this.context.canvas.width = drawWidth;\n        this.context.canvas.height = drawHeight;\n        replayContext = this.context;\n      } else {\n        replayContext = context;\n      }\n\n      const alpha = replayContext.globalAlpha;\n      if (!transparentLayer) {\n        // for performance reasons, context.save / context.restore is not used\n        // to save and restore the transformation matrix and the opacity.\n        // see http://jsperf.com/context-save-restore-versus-variable\n        replayContext.globalAlpha = layerState.opacity;\n      }\n\n      if (replayContext != context) {\n        replayContext.translate(drawOffsetX, drawOffsetY);\n      }\n\n      const viewHints = frameState.viewHints;\n      const snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n      const width = frameState.size[0] * pixelRatio;\n      const height = frameState.size[1] * pixelRatio;\n      rotateAtOffset(replayContext, -rotation,\n        width / 2, height / 2);\n      replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);\n      if (vectorSource.getWrapX() && projection.canWrapX() &&\n          !containsExtent(projectionExtent, extent)) {\n        let startX = extent[0];\n        const worldWidth = getWidth(projectionExtent);\n        let world = 0;\n        let offsetX;\n        while (startX < projectionExtent[0]) {\n          --world;\n          offsetX = worldWidth * world;\n          transform = this.getTransform(frameState, offsetX);\n          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);\n          startX += worldWidth;\n        }\n        world = 0;\n        startX = extent[2];\n        while (startX > projectionExtent[2]) {\n          ++world;\n          offsetX = worldWidth * world;\n          transform = this.getTransform(frameState, offsetX);\n          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids, snapToPixel);\n          startX -= worldWidth;\n        }\n      }\n      rotateAtOffset(replayContext, rotation,\n        width / 2, height / 2);\n\n      if (hasRenderListeners) {\n        this.dispatchRenderEvent(replayContext, frameState, transform);\n      }\n      if (replayContext != context) {\n        if (transparentLayer) {\n          const mainContextAlpha = context.globalAlpha;\n          context.globalAlpha = layerState.opacity;\n          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\n          context.globalAlpha = mainContextAlpha;\n        } else {\n          context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);\n        }\n        replayContext.translate(-drawOffsetX, -drawOffsetY);\n      }\n\n      if (!transparentLayer) {\n        replayContext.globalAlpha = alpha;\n      }\n    }\n\n    if (clipped) {\n      context.restore();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  composeFrame(frameState, layerState, context) {\n    const transform = this.getTransform(frameState, 0);\n    this.preCompose(context, frameState, transform);\n    this.compose(context, frameState, layerState);\n    this.postCompose(context, frameState, layerState, transform);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg) {\n    if (!this.replayGroup_) {\n      return undefined;\n    } else {\n      const resolution = frameState.viewState.resolution;\n      const rotation = frameState.viewState.rotation;\n      const layer = /** @type {import(\"../../layer/Vector.js\").default} */ (this.getLayer());\n      /** @type {!Object<string, boolean>} */\n      const features = {};\n      const result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},\n        /**\n         * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n         * @return {?} Callback result.\n         */\n        function(feature) {\n          const key = getUid(feature);\n          if (!(key in features)) {\n            features[key] = true;\n            return callback.call(thisArg, feature, layer);\n          }\n        }, null);\n      return result;\n    }\n  }\n\n  /**\n   * @param {import(\"../../events/Event.js\").default} event Event.\n   */\n  handleFontsChanged_(event) {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.replayGroup_) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  prepareFrame(frameState, layerState) {\n    const vectorLayer = /** @type {import(\"../../layer/Vector.js\").default} */ (this.getLayer());\n    const vectorSource = /** @type {import(\"../../source/Vector.js\").default} */ (vectorLayer.getSource());\n\n    const animating = frameState.viewHints[ViewHint.ANIMATING];\n    const interacting = frameState.viewHints[ViewHint.INTERACTING];\n    const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n    const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n\n    if (!this.dirty_ && (!updateWhileAnimating && animating) ||\n        (!updateWhileInteracting && interacting)) {\n      return true;\n    }\n\n    const frameStateExtent = frameState.extent;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const resolution = viewState.resolution;\n    const pixelRatio = frameState.pixelRatio;\n    const vectorLayerRevision = vectorLayer.getRevision();\n    const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n    let vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n\n    if (vectorLayerRenderOrder === undefined) {\n      vectorLayerRenderOrder = defaultRenderOrder;\n    }\n\n    const extent = buffer(frameStateExtent,\n      vectorLayerRenderBuffer * resolution);\n    const projectionExtent = viewState.projection.getExtent();\n\n    if (vectorSource.getWrapX() && viewState.projection.canWrapX() &&\n        !containsExtent(projectionExtent, frameState.extent)) {\n      // For the replay group, we need an extent that intersects the real world\n      // (-180° to +180°). To support geometries in a coordinate range from -540°\n      // to +540°, we add at least 1 world width on each side of the projection\n      // extent. If the viewport is wider than the world, we need to add half of\n      // the viewport width to make sure we cover the whole viewport.\n      const worldWidth = getWidth(projectionExtent);\n      const gutter = Math.max(getWidth(extent) / 2, worldWidth);\n      extent[0] = projectionExtent[0] - gutter;\n      extent[2] = projectionExtent[2] + gutter;\n    }\n\n    if (!this.dirty_ &&\n        this.renderedResolution_ == resolution &&\n        this.renderedRevision_ == vectorLayerRevision &&\n        this.renderedRenderOrder_ == vectorLayerRenderOrder &&\n        containsExtent(this.renderedExtent_, extent)) {\n      this.replayGroupChanged = false;\n      return true;\n    }\n\n    this.replayGroup_ = null;\n\n    this.dirty_ = false;\n\n    const replayGroup = new CanvasReplayGroup(\n      getRenderTolerance(resolution, pixelRatio), extent, resolution,\n      pixelRatio, vectorSource.getOverlaps(), this.declutterTree_, vectorLayer.getRenderBuffer());\n    vectorSource.loadFeatures(extent, resolution, projection);\n    /**\n     * @param {import(\"../../Feature.js\").default} feature Feature.\n     * @this {CanvasVectorLayerRenderer}\n     */\n    const render = function(feature) {\n      let styles;\n      const styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();\n      if (styleFunction) {\n        styles = styleFunction(feature, resolution);\n      }\n      if (styles) {\n        const dirty = this.renderFeature(\n          feature, resolution, pixelRatio, styles, replayGroup);\n        this.dirty_ = this.dirty_ || dirty;\n      }\n    }.bind(this);\n    if (vectorLayerRenderOrder) {\n      /** @type {Array<import(\"../../Feature.js\").default>} */\n      const features = [];\n      vectorSource.forEachFeatureInExtent(extent,\n        /**\n         * @param {import(\"../../Feature.js\").default} feature Feature.\n         */\n        function(feature) {\n          features.push(feature);\n        });\n      features.sort(vectorLayerRenderOrder);\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        render(features[i]);\n      }\n    } else {\n      vectorSource.forEachFeatureInExtent(extent, render);\n    }\n    replayGroup.finish();\n\n    this.renderedResolution_ = resolution;\n    this.renderedRevision_ = vectorLayerRevision;\n    this.renderedRenderOrder_ = vectorLayerRenderOrder;\n    this.renderedExtent_ = extent;\n    this.replayGroup_ = replayGroup;\n\n    this.replayGroupChanged = true;\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/ReplayGroup.js\").default} replayGroup Replay group.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(feature, resolution, pixelRatio, styles, replayGroup) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading = renderFeature(\n          replayGroup, feature, styles[i],\n          getSquaredRenderTolerance(resolution, pixelRatio),\n          this.handleStyleImageChange_, this) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        replayGroup, feature, styles,\n        getSquaredRenderTolerance(resolution, pixelRatio),\n        this.handleStyleImageChange_, this);\n    }\n    return loading;\n  }\n}\n\n\n/**\n * Determine if this renderer handles the provided layer.\n * @param {import(\"../../layer/Layer.js\").default} layer The candidate layer.\n * @return {boolean} The renderer can render the layer.\n */\nCanvasVectorLayerRenderer['handles'] = function(layer) {\n  return layer.getType() === LayerType.VECTOR;\n};\n\n\n/**\n * Create a layer renderer.\n * @param {import(\"../Map.js\").default} mapRenderer The map renderer.\n * @param {import(\"../../layer/Layer.js\").default} layer The layer to be rendererd.\n * @return {CanvasVectorLayerRenderer} The layer renderer.\n */\nCanvasVectorLayerRenderer['create'] = function(mapRenderer, layer) {\n  return new CanvasVectorLayerRenderer(/** @type {import(\"../../layer/Vector.js\").default} */ (layer));\n};\n\n\nexport default CanvasVectorLayerRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}