{"ast":null,"code":"/**\n * @module ol/MapBrowserEventHandler\n */\nimport { DEVICE_PIXEL_RATIO } from './has.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport MapBrowserPointerEvent from './MapBrowserPointerEvent.js';\nimport { listen, unlistenByKey } from './events.js';\nimport EventTarget from './events/Target.js';\nimport PointerEventType from './pointer/EventType.js';\nimport PointerEventHandler from './pointer/PointerEventHandler.js';\nvar MapBrowserEventHandler = /*@__PURE__*/function (EventTarget) {\n  function MapBrowserEventHandler(map, moveTolerance) {\n    EventTarget.call(this);\n\n    /**\n     * This is the element that we will listen to the real events on.\n     * @type {import(\"./PluggableMap.js\").default}\n     * @private\n     */\n    this.map_ = map;\n\n    /**\n     * @type {any}\n     * @private\n     */\n    this.clickTimeoutId_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.dragging_ = false;\n\n    /**\n     * @type {!Array<import(\"./events.js\").EventsKey>}\n     * @private\n     */\n    this.dragListenerKeys_ = [];\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.moveTolerance_ = moveTolerance ? moveTolerance * DEVICE_PIXEL_RATIO : DEVICE_PIXEL_RATIO;\n\n    /**\n     * The most recent \"down\" type event (or null if none have occurred).\n     * Set on pointerdown.\n     * @type {import(\"./pointer/PointerEvent.js\").default}\n     * @private\n     */\n    this.down_ = null;\n    var element = this.map_.getViewport();\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.activePointers_ = 0;\n\n    /**\n     * @type {!Object<number, boolean>}\n     * @private\n     */\n    this.trackedTouches_ = {};\n\n    /**\n     * Event handler which generates pointer events for\n     * the viewport element.\n     *\n     * @type {PointerEventHandler}\n     * @private\n     */\n    this.pointerEventHandler_ = new PointerEventHandler(element);\n\n    /**\n     * Event handler which generates pointer events for\n     * the document (used when dragging).\n     *\n     * @type {PointerEventHandler}\n     * @private\n     */\n    this.documentPointerEventHandler_ = null;\n\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    this.pointerdownListenerKey_ = listen(this.pointerEventHandler_, PointerEventType.POINTERDOWN, this.handlePointerDown_, this);\n\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    this.relayedListenerKey_ = listen(this.pointerEventHandler_, PointerEventType.POINTERMOVE, this.relayEvent_, this);\n  }\n  if (EventTarget) MapBrowserEventHandler.__proto__ = EventTarget;\n  MapBrowserEventHandler.prototype = Object.create(EventTarget && EventTarget.prototype);\n  MapBrowserEventHandler.prototype.constructor = MapBrowserEventHandler;\n\n  /**\n   * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.emulateClick_ = function emulateClick_(pointerEvent) {\n    var newEvent = new MapBrowserPointerEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    if (this.clickTimeoutId_ !== undefined) {\n      // double-click\n      clearTimeout(this.clickTimeoutId_);\n      this.clickTimeoutId_ = undefined;\n      newEvent = new MapBrowserPointerEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);\n      this.dispatchEvent(newEvent);\n    } else {\n      // click\n      this.clickTimeoutId_ = setTimeout(function () {\n        this.clickTimeoutId_ = undefined;\n        var newEvent = new MapBrowserPointerEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n      }.bind(this), 250);\n    }\n  };\n\n  /**\n   * Keeps track on how many pointers are currently active.\n   *\n   * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.updateActivePointers_ = function updateActivePointers_(pointerEvent) {\n    var event = pointerEvent;\n    if (event.type == MapBrowserEventType.POINTERUP || event.type == MapBrowserEventType.POINTERCANCEL) {\n      delete this.trackedTouches_[event.pointerId];\n    } else if (event.type == MapBrowserEventType.POINTERDOWN) {\n      this.trackedTouches_[event.pointerId] = true;\n    }\n    this.activePointers_ = Object.keys(this.trackedTouches_).length;\n  };\n\n  /**\n   * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.handlePointerUp_ = function handlePointerUp_(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new MapBrowserPointerEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n\n    // We emulate click events on left mouse button click, touch contact, and pen\n    // contact. isMouseActionButton returns true in these cases (evt.button is set\n    // to 0).\n    // See http://www.w3.org/TR/pointerevents/#button-states\n    // We only fire click, singleclick, and doubleclick if nobody has called\n    // event.stopPropagation() or event.preventDefault().\n    if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n      this.emulateClick_(this.down_);\n    }\n    if (this.activePointers_ === 0) {\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.dragging_ = false;\n      this.down_ = null;\n      this.documentPointerEventHandler_.dispose();\n      this.documentPointerEventHandler_ = null;\n    }\n  };\n\n  /**\n   * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n   * event.\n   * @return {boolean} If the left mouse button was pressed.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.isMouseActionButton_ = function isMouseActionButton_(pointerEvent) {\n    return pointerEvent.button === 0;\n  };\n\n  /**\n   * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.handlePointerDown_ = function handlePointerDown_(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    var newEvent = new MapBrowserPointerEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    this.down_ = pointerEvent;\n    if (this.dragListenerKeys_.length === 0) {\n      /* Set up a pointer event handler on the `document`,\n       * which is required when the pointer is moved outside\n       * the viewport when dragging.\n       */\n      this.documentPointerEventHandler_ = new PointerEventHandler(document);\n      this.dragListenerKeys_.push(listen(this.documentPointerEventHandler_, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(this.documentPointerEventHandler_, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this),\n      /* Note that the listener for `pointercancel is set up on\n       * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n       * the `pointerup` and `pointermove` listeners.\n       *\n       * The reason for this is the following: `TouchSource.vacuumTouches_()`\n       * issues `pointercancel` events, when there was no `touchend` for a\n       * `touchstart`. Now, let's say a first `touchstart` is registered on\n       * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n       * But `documentPointerEventHandler_` doesn't know about the first\n       * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n       * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n       * only registered there.\n       */\n      listen(this.pointerEventHandler_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));\n    }\n  };\n\n  /**\n   * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.handlePointerMove_ = function handlePointerMove_(pointerEvent) {\n    // Between pointerdown and pointerup, pointermove events are triggered.\n    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n    // moved a significant distance.\n    if (this.isMoving_(pointerEvent)) {\n      this.dragging_ = true;\n      var newEvent = new MapBrowserPointerEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_);\n      this.dispatchEvent(newEvent);\n    }\n\n    // Some native android browser triggers mousemove events during small period\n    // of time. See: https://code.google.com/p/android/issues/detail?id=5491 or\n    // https://code.google.com/p/android/issues/detail?id=19827\n    // ex: Galaxy Tab P3110 + Android 4.1.1\n    pointerEvent.preventDefault();\n  };\n\n  /**\n   * Wrap and relay a pointer event.  Note that this requires that the type\n   * string for the MapBrowserPointerEvent matches the PointerEvent type.\n   * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.relayEvent_ = function relayEvent_(pointerEvent) {\n    var dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n    this.dispatchEvent(new MapBrowserPointerEvent(pointerEvent.type, this.map_, pointerEvent, dragging));\n  };\n\n  /**\n   * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n   * event.\n   * @return {boolean} Is moving.\n   * @private\n   */\n  MapBrowserEventHandler.prototype.isMoving_ = function isMoving_(pointerEvent) {\n    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MapBrowserEventHandler.prototype.disposeInternal = function disposeInternal() {\n    if (this.relayedListenerKey_) {\n      unlistenByKey(this.relayedListenerKey_);\n      this.relayedListenerKey_ = null;\n    }\n    if (this.pointerdownListenerKey_) {\n      unlistenByKey(this.pointerdownListenerKey_);\n      this.pointerdownListenerKey_ = null;\n    }\n    this.dragListenerKeys_.forEach(unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n    if (this.documentPointerEventHandler_) {\n      this.documentPointerEventHandler_.dispose();\n      this.documentPointerEventHandler_ = null;\n    }\n    if (this.pointerEventHandler_) {\n      this.pointerEventHandler_.dispose();\n      this.pointerEventHandler_ = null;\n    }\n    EventTarget.prototype.disposeInternal.call(this);\n  };\n  return MapBrowserEventHandler;\n}(EventTarget);\nexport default MapBrowserEventHandler;","map":{"version":3,"names":["DEVICE_PIXEL_RATIO","MapBrowserEventType","MapBrowserPointerEvent","listen","unlistenByKey","EventTarget","PointerEventType","PointerEventHandler","MapBrowserEventHandler","map","moveTolerance","call","map_","clickTimeoutId_","dragging_","dragListenerKeys_","moveTolerance_","down_","element","getViewport","activePointers_","trackedTouches_","pointerEventHandler_","documentPointerEventHandler_","pointerdownListenerKey_","POINTERDOWN","handlePointerDown_","relayedListenerKey_","POINTERMOVE","relayEvent_","emulateClick_","pointerEvent","newEvent","CLICK","dispatchEvent","undefined","clearTimeout","DBLCLICK","setTimeout","SINGLECLICK","bind","updateActivePointers_","event","type","POINTERUP","POINTERCANCEL","pointerId","Object","keys","length","handlePointerUp_","propagationStopped","isMouseActionButton_","forEach","dispose","button","document","push","handlePointerMove_","isMoving_","POINTERDRAG","preventDefault","dragging","Math","abs","clientX","clientY","disposeInternal","prototype"],"sources":["../../src/ol/MapBrowserEventHandler.js"],"sourcesContent":["/**\n * @module ol/MapBrowserEventHandler\n */\nimport {DEVICE_PIXEL_RATIO} from './has.js';\nimport MapBrowserEventType from './MapBrowserEventType.js';\nimport MapBrowserPointerEvent from './MapBrowserPointerEvent.js';\nimport {listen, unlistenByKey} from './events.js';\nimport EventTarget from './events/Target.js';\nimport PointerEventType from './pointer/EventType.js';\nimport PointerEventHandler from './pointer/PointerEventHandler.js';\n\nclass MapBrowserEventHandler extends EventTarget {\n\n  /**\n   * @param {import(\"./PluggableMap.js\").default} map The map with the viewport to listen to events on.\n   * @param {number=} moveTolerance The minimal distance the pointer must travel to trigger a move.\n   */\n  constructor(map, moveTolerance) {\n\n    super();\n\n    /**\n     * This is the element that we will listen to the real events on.\n     * @type {import(\"./PluggableMap.js\").default}\n     * @private\n     */\n    this.map_ = map;\n\n    /**\n     * @type {any}\n     * @private\n     */\n    this.clickTimeoutId_;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.dragging_ = false;\n\n    /**\n     * @type {!Array<import(\"./events.js\").EventsKey>}\n     * @private\n     */\n    this.dragListenerKeys_ = [];\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.moveTolerance_ = moveTolerance ?\n      moveTolerance * DEVICE_PIXEL_RATIO : DEVICE_PIXEL_RATIO;\n\n    /**\n     * The most recent \"down\" type event (or null if none have occurred).\n     * Set on pointerdown.\n     * @type {import(\"./pointer/PointerEvent.js\").default}\n     * @private\n     */\n    this.down_ = null;\n\n    const element = this.map_.getViewport();\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.activePointers_ = 0;\n\n    /**\n     * @type {!Object<number, boolean>}\n     * @private\n     */\n    this.trackedTouches_ = {};\n\n    /**\n     * Event handler which generates pointer events for\n     * the viewport element.\n     *\n     * @type {PointerEventHandler}\n     * @private\n     */\n    this.pointerEventHandler_ = new PointerEventHandler(element);\n\n    /**\n     * Event handler which generates pointer events for\n     * the document (used when dragging).\n     *\n     * @type {PointerEventHandler}\n     * @private\n     */\n    this.documentPointerEventHandler_ = null;\n\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    this.pointerdownListenerKey_ = listen(this.pointerEventHandler_,\n      PointerEventType.POINTERDOWN,\n      this.handlePointerDown_, this);\n\n    /**\n     * @type {?import(\"./events.js\").EventsKey}\n     * @private\n     */\n    this.relayedListenerKey_ = listen(this.pointerEventHandler_,\n      PointerEventType.POINTERMOVE,\n      this.relayEvent_, this);\n\n  }\n\n  /**\n   * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  emulateClick_(pointerEvent) {\n    let newEvent = new MapBrowserPointerEvent(\n      MapBrowserEventType.CLICK, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n    if (this.clickTimeoutId_ !== undefined) {\n      // double-click\n      clearTimeout(this.clickTimeoutId_);\n      this.clickTimeoutId_ = undefined;\n      newEvent = new MapBrowserPointerEvent(\n        MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);\n      this.dispatchEvent(newEvent);\n    } else {\n      // click\n      this.clickTimeoutId_ = setTimeout(function() {\n        this.clickTimeoutId_ = undefined;\n        const newEvent = new MapBrowserPointerEvent(\n          MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);\n        this.dispatchEvent(newEvent);\n      }.bind(this), 250);\n    }\n  }\n\n  /**\n   * Keeps track on how many pointers are currently active.\n   *\n   * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  updateActivePointers_(pointerEvent) {\n    const event = pointerEvent;\n\n    if (event.type == MapBrowserEventType.POINTERUP ||\n        event.type == MapBrowserEventType.POINTERCANCEL) {\n      delete this.trackedTouches_[event.pointerId];\n    } else if (event.type == MapBrowserEventType.POINTERDOWN) {\n      this.trackedTouches_[event.pointerId] = true;\n    }\n    this.activePointers_ = Object.keys(this.trackedTouches_).length;\n  }\n\n  /**\n   * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  handlePointerUp_(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    const newEvent = new MapBrowserPointerEvent(\n      MapBrowserEventType.POINTERUP, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n\n    // We emulate click events on left mouse button click, touch contact, and pen\n    // contact. isMouseActionButton returns true in these cases (evt.button is set\n    // to 0).\n    // See http://www.w3.org/TR/pointerevents/#button-states\n    // We only fire click, singleclick, and doubleclick if nobody has called\n    // event.stopPropagation() or event.preventDefault().\n    if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {\n      this.emulateClick_(this.down_);\n    }\n\n    if (this.activePointers_ === 0) {\n      this.dragListenerKeys_.forEach(unlistenByKey);\n      this.dragListenerKeys_.length = 0;\n      this.dragging_ = false;\n      this.down_ = null;\n      this.documentPointerEventHandler_.dispose();\n      this.documentPointerEventHandler_ = null;\n    }\n  }\n\n  /**\n   * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n   * event.\n   * @return {boolean} If the left mouse button was pressed.\n   * @private\n   */\n  isMouseActionButton_(pointerEvent) {\n    return pointerEvent.button === 0;\n  }\n\n  /**\n   * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  handlePointerDown_(pointerEvent) {\n    this.updateActivePointers_(pointerEvent);\n    const newEvent = new MapBrowserPointerEvent(\n      MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent);\n    this.dispatchEvent(newEvent);\n\n    this.down_ = pointerEvent;\n\n    if (this.dragListenerKeys_.length === 0) {\n      /* Set up a pointer event handler on the `document`,\n       * which is required when the pointer is moved outside\n       * the viewport when dragging.\n       */\n      this.documentPointerEventHandler_ =\n          new PointerEventHandler(document);\n\n      this.dragListenerKeys_.push(\n        listen(this.documentPointerEventHandler_,\n          MapBrowserEventType.POINTERMOVE,\n          this.handlePointerMove_, this),\n        listen(this.documentPointerEventHandler_,\n          MapBrowserEventType.POINTERUP,\n          this.handlePointerUp_, this),\n        /* Note that the listener for `pointercancel is set up on\n         * `pointerEventHandler_` and not `documentPointerEventHandler_` like\n         * the `pointerup` and `pointermove` listeners.\n         *\n         * The reason for this is the following: `TouchSource.vacuumTouches_()`\n         * issues `pointercancel` events, when there was no `touchend` for a\n         * `touchstart`. Now, let's say a first `touchstart` is registered on\n         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.\n         * But `documentPointerEventHandler_` doesn't know about the first\n         * `touchstart`. If there is no `touchend` for the `touchstart`, we can\n         * only receive a `touchcancel` from `pointerEventHandler_`, because it is\n         * only registered there.\n         */\n        listen(this.pointerEventHandler_,\n          MapBrowserEventType.POINTERCANCEL,\n          this.handlePointerUp_, this)\n      );\n    }\n  }\n\n  /**\n   * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  handlePointerMove_(pointerEvent) {\n    // Between pointerdown and pointerup, pointermove events are triggered.\n    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer\n    // moved a significant distance.\n    if (this.isMoving_(pointerEvent)) {\n      this.dragging_ = true;\n      const newEvent = new MapBrowserPointerEvent(\n        MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent,\n        this.dragging_);\n      this.dispatchEvent(newEvent);\n    }\n\n    // Some native android browser triggers mousemove events during small period\n    // of time. See: https://code.google.com/p/android/issues/detail?id=5491 or\n    // https://code.google.com/p/android/issues/detail?id=19827\n    // ex: Galaxy Tab P3110 + Android 4.1.1\n    pointerEvent.preventDefault();\n  }\n\n  /**\n   * Wrap and relay a pointer event.  Note that this requires that the type\n   * string for the MapBrowserPointerEvent matches the PointerEvent type.\n   * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n   * event.\n   * @private\n   */\n  relayEvent_(pointerEvent) {\n    const dragging = !!(this.down_ && this.isMoving_(pointerEvent));\n    this.dispatchEvent(new MapBrowserPointerEvent(\n      pointerEvent.type, this.map_, pointerEvent, dragging));\n  }\n\n  /**\n   * @param {import(\"./pointer/PointerEvent.js\").default} pointerEvent Pointer\n   * event.\n   * @return {boolean} Is moving.\n   * @private\n   */\n  isMoving_(pointerEvent) {\n    return this.dragging_ ||\n        Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ ||\n        Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  disposeInternal() {\n    if (this.relayedListenerKey_) {\n      unlistenByKey(this.relayedListenerKey_);\n      this.relayedListenerKey_ = null;\n    }\n    if (this.pointerdownListenerKey_) {\n      unlistenByKey(this.pointerdownListenerKey_);\n      this.pointerdownListenerKey_ = null;\n    }\n\n    this.dragListenerKeys_.forEach(unlistenByKey);\n    this.dragListenerKeys_.length = 0;\n\n    if (this.documentPointerEventHandler_) {\n      this.documentPointerEventHandler_.dispose();\n      this.documentPointerEventHandler_ = null;\n    }\n    if (this.pointerEventHandler_) {\n      this.pointerEventHandler_.dispose();\n      this.pointerEventHandler_ = null;\n    }\n    super.disposeInternal();\n  }\n}\n\n\nexport default MapBrowserEventHandler;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}