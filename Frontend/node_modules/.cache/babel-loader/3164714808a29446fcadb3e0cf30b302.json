{"ast":null,"code":"/**\n * @module ol/render/canvas/ReplayGroup\n */\n\nimport { numberSafeCompareFunction } from '../../array.js';\nimport { createCanvasContext2D } from '../../dom.js';\nimport { buffer, createEmpty, extendCoordinate } from '../../extent.js';\nimport { transform2D } from '../../geom/flat/transform.js';\nimport { isEmpty } from '../../obj.js';\nimport ReplayGroup from '../ReplayGroup.js';\nimport ReplayType from '../ReplayType.js';\nimport CanvasReplay from './Replay.js';\nimport CanvasImageReplay from './ImageReplay.js';\nimport CanvasLineStringReplay from './LineStringReplay.js';\nimport CanvasPolygonReplay from './PolygonReplay.js';\nimport CanvasTextReplay from './TextReplay.js';\nimport { ORDER } from '../replay.js';\nimport { create as createTransform, compose as composeTransform } from '../../transform.js';\n\n/**\n * @type {Object<ReplayType, typeof CanvasReplay>}\n */\nvar BATCH_CONSTRUCTORS = {\n  'Circle': CanvasPolygonReplay,\n  'Default': CanvasReplay,\n  'Image': CanvasImageReplay,\n  'LineString': CanvasLineStringReplay,\n  'Polygon': CanvasPolygonReplay,\n  'Text': CanvasTextReplay\n};\nvar CanvasReplayGroup = /*@__PURE__*/function (ReplayGroup) {\n  function CanvasReplayGroup(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree, opt_renderBuffer) {\n    ReplayGroup.call(this);\n\n    /**\n     * Declutter tree.\n     * @private\n     */\n    this.declutterTree_ = declutterTree;\n\n    /**\n     * @type {import(\"../canvas.js\").DeclutterGroup}\n     * @private\n     */\n    this.declutterGroup_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tolerance_ = tolerance;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent_ = maxExtent;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = overlaps;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.resolution_ = resolution;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.renderBuffer_ = opt_renderBuffer;\n\n    /**\n     * @private\n     * @type {!Object<string, !Object<ReplayType, CanvasReplay>>}\n     */\n    this.replaysByZIndex_ = {};\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitDetectionContext_ = createCanvasContext2D(1, 1);\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.hitDetectionTransform_ = createTransform();\n  }\n  if (ReplayGroup) CanvasReplayGroup.__proto__ = ReplayGroup;\n  CanvasReplayGroup.prototype = Object.create(ReplayGroup && ReplayGroup.prototype);\n  CanvasReplayGroup.prototype.constructor = CanvasReplayGroup;\n\n  /**\n   * @inheritDoc\n   */\n  CanvasReplayGroup.prototype.addDeclutter = function addDeclutter(group) {\n    var declutter = null;\n    if (this.declutterTree_) {\n      if (group) {\n        declutter = this.declutterGroup_;\n        /** @type {number} */\n        declutter[4]++;\n      } else {\n        declutter = this.declutterGroup_ = createEmpty();\n        declutter.push(1);\n      }\n    }\n    return declutter;\n  };\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   */\n  CanvasReplayGroup.prototype.clip = function clip(context, transform) {\n    var flatClipCoords = this.getClipCoords(transform);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  };\n\n  /**\n   * @param {Array<ReplayType>} replays Replays.\n   * @return {boolean} Has replays of the provided types.\n   */\n  CanvasReplayGroup.prototype.hasReplays = function hasReplays(replays) {\n    for (var zIndex in this.replaysByZIndex_) {\n      var candidates = this.replaysByZIndex_[zIndex];\n      for (var i = 0, ii = replays.length; i < ii; ++i) {\n        if (replays[i] in candidates) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  CanvasReplayGroup.prototype.finish = function finish() {\n    for (var zKey in this.replaysByZIndex_) {\n      var replays = this.replaysByZIndex_[zKey];\n      for (var replayKey in replays) {\n        replays[replayKey].finish();\n      }\n    }\n  };\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n   * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T} callback Feature callback.\n   * @param {Object<string, import(\"../canvas.js\").DeclutterGroup>} declutterReplays Declutter replays.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  CanvasReplayGroup.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, skippedFeaturesHash, callback, declutterReplays) {\n    hitTolerance = Math.round(hitTolerance);\n    var contextSize = hitTolerance * 2 + 1;\n    var transform = composeTransform(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);\n    var context = this.hitDetectionContext_;\n    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    var hitExtent;\n    if (this.renderBuffer_ !== undefined) {\n      hitExtent = createEmpty();\n      extendCoordinate(hitExtent, coordinate);\n      buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n    }\n    var mask = getCircleArray(hitTolerance);\n    var declutteredFeatures;\n    if (this.declutterTree_) {\n      declutteredFeatures = this.declutterTree_.all().map(function (entry) {\n        return entry.value;\n      });\n    }\n    var replayType;\n\n    /**\n     * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n     * @return {?} Callback result.\n     */\n    function featureCallback(feature) {\n      var imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n      for (var i = 0; i < contextSize; i++) {\n        for (var j = 0; j < contextSize; j++) {\n          if (mask[i][j]) {\n            if (imageData[(j * contextSize + i) * 4 + 3] > 0) {\n              var result = void 0;\n              if (!(declutteredFeatures && (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) || declutteredFeatures.indexOf(feature) !== -1) {\n                result = callback(feature);\n              }\n              if (result) {\n                return result;\n              } else {\n                context.clearRect(0, 0, contextSize, contextSize);\n                return undefined;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /** @type {Array<number>} */\n    var zs = Object.keys(this.replaysByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n    var i, j, replays, replay, result;\n    for (i = zs.length - 1; i >= 0; --i) {\n      var zIndexKey = zs[i].toString();\n      replays = this.replaysByZIndex_[zIndexKey];\n      for (j = ORDER.length - 1; j >= 0; --j) {\n        replayType = ORDER[j];\n        replay = replays[replayType];\n        if (replay !== undefined) {\n          if (declutterReplays && (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) {\n            var declutter = declutterReplays[zIndexKey];\n            if (!declutter) {\n              declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            result = replay.replayHitDetection(context, transform, rotation, skippedFeaturesHash, featureCallback, hitExtent);\n            if (result) {\n              return result;\n            }\n          }\n        }\n      }\n    }\n    return undefined;\n  };\n\n  /**\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @return {Array<number>} Clip coordinates.\n   */\n  CanvasReplayGroup.prototype.getClipCoords = function getClipCoords(transform) {\n    var maxExtent = this.maxExtent_;\n    var minX = maxExtent[0];\n    var minY = maxExtent[1];\n    var maxX = maxExtent[2];\n    var maxY = maxExtent[3];\n    var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n    return flatClipCoords;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasReplayGroup.prototype.getReplay = function getReplay(zIndex, replayType) {\n    var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';\n    var replays = this.replaysByZIndex_[zIndexKey];\n    if (replays === undefined) {\n      replays = {};\n      this.replaysByZIndex_[zIndexKey] = replays;\n    }\n    var replay = replays[replayType];\n    if (replay === undefined) {\n      var Constructor = BATCH_CONSTRUCTORS[replayType];\n      replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);\n      replays[replayType] = replay;\n    }\n    return replay;\n  };\n\n  /**\n   * @return {Object<string, Object<ReplayType, CanvasReplay>>} Replays.\n   */\n  CanvasReplayGroup.prototype.getReplays = function getReplays() {\n    return this.replaysByZIndex_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  CanvasReplayGroup.prototype.isEmpty = function isEmpty$1() {\n    return isEmpty(this.replaysByZIndex_);\n  };\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n   * @param {Array<ReplayType>=} opt_replayTypes Ordered replay types to replay.\n   *     Default is {@link module:ol/render/replay~ORDER}\n   * @param {Object<string, import(\"../canvas.js\").DeclutterGroup>=} opt_declutterReplays Declutter replays.\n   */\n  CanvasReplayGroup.prototype.replay = function replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel, opt_replayTypes, opt_declutterReplays) {\n    /** @type {Array<number>} */\n    var zs = Object.keys(this.replaysByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n\n    // setup clipping so that the parts of over-simplified geometries are not\n    // visible outside the current extent when panning\n    context.save();\n    this.clip(context, transform);\n    var replayTypes = opt_replayTypes ? opt_replayTypes : ORDER;\n    var i, ii, j, jj, replays, replay;\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      var zIndexKey = zs[i].toString();\n      replays = this.replaysByZIndex_[zIndexKey];\n      for (j = 0, jj = replayTypes.length; j < jj; ++j) {\n        var replayType = replayTypes[j];\n        replay = replays[replayType];\n        if (replay !== undefined) {\n          if (opt_declutterReplays && (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) {\n            var declutter = opt_declutterReplays[zIndexKey];\n            if (!declutter) {\n              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            replay.replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel);\n          }\n        }\n      }\n    }\n    context.restore();\n  };\n  return CanvasReplayGroup;\n}(ReplayGroup);\n\n/**\n * This cache is used for storing calculated pixel circles for increasing performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<Array<(boolean|undefined)>>>}\n */\nvar circleArrayCache = {\n  0: [[true]]\n};\n\n/**\n * This method fills a row in the array from the given coordinate to the\n * middle with `true`.\n * @param {Array<Array<(boolean|undefined)>>} array The array that will be altered.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n */\nfunction fillCircleArrayRowToMiddle(array, x, y) {\n  var i;\n  var radius = Math.floor(array.length / 2);\n  if (x >= radius) {\n    for (i = radius; i < x; i++) {\n      array[i][y] = true;\n    }\n  } else if (x < radius) {\n    for (i = x + 1; i < radius; i++) {\n      array[i][y] = true;\n    }\n  }\n}\n\n/**\n * This methods creates a circle inside a fitting array. Points inside the\n * circle are marked by true, points on the outside are undefined.\n * It uses the midpoint circle algorithm.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @returns {Array<Array<(boolean|undefined)>>} An array with marked circle points.\n */\nexport function getCircleArray(radius) {\n  if (circleArrayCache[radius] !== undefined) {\n    return circleArrayCache[radius];\n  }\n  var arraySize = radius * 2 + 1;\n  var arr = new Array(arraySize);\n  for (var i = 0; i < arraySize; i++) {\n    arr[i] = new Array(arraySize);\n  }\n  var x = radius;\n  var y = 0;\n  var error = 0;\n  while (x >= y) {\n    fillCircleArrayRowToMiddle(arr, radius + x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius - y);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + x, radius - y);\n    y++;\n    error += 1 + 2 * y;\n    if (2 * (error - x) + 1 > 0) {\n      x -= 1;\n      error += 1 - 2 * x;\n    }\n  }\n  circleArrayCache[radius] = arr;\n  return arr;\n}\n\n/**\n * @param {!Object<string, Array<*>>} declutterReplays Declutter replays.\n * @param {CanvasRenderingContext2D} context Context.\n * @param {number} rotation Rotation.\n * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n */\nexport function replayDeclutter(declutterReplays, context, rotation, snapToPixel) {\n  var zs = Object.keys(declutterReplays).map(Number).sort(numberSafeCompareFunction);\n  var skippedFeatureUids = {};\n  for (var z = 0, zz = zs.length; z < zz; ++z) {\n    var replayData = declutterReplays[zs[z].toString()];\n    for (var i = 0, ii = replayData.length; i < ii;) {\n      var replay = replayData[i++];\n      var transform = replayData[i++];\n      replay.replay(context, transform, rotation, skippedFeatureUids, snapToPixel);\n    }\n  }\n}\nexport default CanvasReplayGroup;","map":{"version":3,"names":["numberSafeCompareFunction","createCanvasContext2D","buffer","createEmpty","extendCoordinate","transform2D","isEmpty","ReplayGroup","ReplayType","CanvasReplay","CanvasImageReplay","CanvasLineStringReplay","CanvasPolygonReplay","CanvasTextReplay","ORDER","create","createTransform","compose","composeTransform","BATCH_CONSTRUCTORS","CanvasReplayGroup","tolerance","maxExtent","resolution","pixelRatio","overlaps","declutterTree","opt_renderBuffer","call","declutterTree_","declutterGroup_","tolerance_","maxExtent_","overlaps_","pixelRatio_","resolution_","renderBuffer_","replaysByZIndex_","hitDetectionContext_","hitDetectionTransform_","addDeclutter","group","declutter","push","clip","context","transform","flatClipCoords","getClipCoords","beginPath","moveTo","lineTo","hasReplays","replays","zIndex","candidates","i","ii","length","finish","zKey","replayKey","forEachFeatureAtCoordinate","coordinate","rotation","hitTolerance","skippedFeaturesHash","callback","declutterReplays","Math","round","contextSize","canvas","width","height","clearRect","hitExtent","undefined","mask","getCircleArray","declutteredFeatures","all","map","entry","value","replayType","featureCallback","feature","imageData","getImageData","data","j","result","IMAGE","TEXT","indexOf","zs","Object","keys","Number","sort","replay","zIndexKey","toString","slice","replayHitDetection","minX","minY","maxX","maxY","getReplay","Constructor","getReplays","isEmpty$1","viewRotation","snapToPixel","opt_replayTypes","opt_declutterReplays","save","replayTypes","jj","restore","circleArrayCache","fillCircleArrayRowToMiddle","array","x","y","radius","floor","arraySize","arr","Array","error","replayDeclutter","skippedFeatureUids","z","zz","replayData"],"sources":["../../../../src/ol/render/canvas/ReplayGroup.js"],"sourcesContent":["/**\n * @module ol/render/canvas/ReplayGroup\n */\n\nimport {numberSafeCompareFunction} from '../../array.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {buffer, createEmpty, extendCoordinate} from '../../extent.js';\nimport {transform2D} from '../../geom/flat/transform.js';\nimport {isEmpty} from '../../obj.js';\nimport ReplayGroup from '../ReplayGroup.js';\nimport ReplayType from '../ReplayType.js';\nimport CanvasReplay from './Replay.js';\nimport CanvasImageReplay from './ImageReplay.js';\nimport CanvasLineStringReplay from './LineStringReplay.js';\nimport CanvasPolygonReplay from './PolygonReplay.js';\nimport CanvasTextReplay from './TextReplay.js';\nimport {ORDER} from '../replay.js';\nimport {create as createTransform, compose as composeTransform} from '../../transform.js';\n\n\n/**\n * @type {Object<ReplayType, typeof CanvasReplay>}\n */\nconst BATCH_CONSTRUCTORS = {\n  'Circle': CanvasPolygonReplay,\n  'Default': CanvasReplay,\n  'Image': CanvasImageReplay,\n  'LineString': CanvasLineStringReplay,\n  'Polygon': CanvasPolygonReplay,\n  'Text': CanvasTextReplay\n};\n\n\nclass CanvasReplayGroup extends ReplayGroup {\n  /**\n   * @param {number} tolerance Tolerance.\n   * @param {import(\"../../extent.js\").Extent} maxExtent Max extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {boolean} overlaps The replay group can have overlapping geometries.\n   * @param {?} declutterTree Declutter tree for declutter processing in postrender.\n   * @param {number=} opt_renderBuffer Optional rendering buffer.\n   */\n  constructor(\n    tolerance,\n    maxExtent,\n    resolution,\n    pixelRatio,\n    overlaps,\n    declutterTree,\n    opt_renderBuffer\n  ) {\n    super();\n\n    /**\n     * Declutter tree.\n     * @private\n     */\n    this.declutterTree_ = declutterTree;\n\n    /**\n     * @type {import(\"../canvas.js\").DeclutterGroup}\n     * @private\n     */\n    this.declutterGroup_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.tolerance_ = tolerance;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.maxExtent_ = maxExtent;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.overlaps_ = overlaps;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.resolution_ = resolution;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.renderBuffer_ = opt_renderBuffer;\n\n    /**\n     * @private\n     * @type {!Object<string, !Object<ReplayType, CanvasReplay>>}\n     */\n    this.replaysByZIndex_ = {};\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.hitDetectionContext_ = createCanvasContext2D(1, 1);\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.hitDetectionTransform_ = createTransform();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  addDeclutter(group) {\n    let declutter = null;\n    if (this.declutterTree_) {\n      if (group) {\n        declutter = this.declutterGroup_;\n        /** @type {number} */ (declutter[4])++;\n      } else {\n        declutter = this.declutterGroup_ = createEmpty();\n        declutter.push(1);\n      }\n    }\n    return declutter;\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   */\n  clip(context, transform) {\n    const flatClipCoords = this.getClipCoords(transform);\n    context.beginPath();\n    context.moveTo(flatClipCoords[0], flatClipCoords[1]);\n    context.lineTo(flatClipCoords[2], flatClipCoords[3]);\n    context.lineTo(flatClipCoords[4], flatClipCoords[5]);\n    context.lineTo(flatClipCoords[6], flatClipCoords[7]);\n    context.clip();\n  }\n\n  /**\n   * @param {Array<ReplayType>} replays Replays.\n   * @return {boolean} Has replays of the provided types.\n   */\n  hasReplays(replays) {\n    for (const zIndex in this.replaysByZIndex_) {\n      const candidates = this.replaysByZIndex_[zIndex];\n      for (let i = 0, ii = replays.length; i < ii; ++i) {\n        if (replays[i] in candidates) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  finish() {\n    for (const zKey in this.replaysByZIndex_) {\n      const replays = this.replaysByZIndex_[zKey];\n      for (const replayKey in replays) {\n        replays[replayKey].finish();\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n   * @param {function((import(\"../../Feature.js\").default|import(\"../Feature.js\").default)): T} callback Feature callback.\n   * @param {Object<string, import(\"../canvas.js\").DeclutterGroup>} declutterReplays Declutter replays.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    resolution,\n    rotation,\n    hitTolerance,\n    skippedFeaturesHash,\n    callback,\n    declutterReplays\n  ) {\n\n    hitTolerance = Math.round(hitTolerance);\n    const contextSize = hitTolerance * 2 + 1;\n    const transform = composeTransform(this.hitDetectionTransform_,\n      hitTolerance + 0.5, hitTolerance + 0.5,\n      1 / resolution, -1 / resolution,\n      -rotation,\n      -coordinate[0], -coordinate[1]);\n    const context = this.hitDetectionContext_;\n\n    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {\n      context.canvas.width = contextSize;\n      context.canvas.height = contextSize;\n    } else {\n      context.clearRect(0, 0, contextSize, contextSize);\n    }\n\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    let hitExtent;\n    if (this.renderBuffer_ !== undefined) {\n      hitExtent = createEmpty();\n      extendCoordinate(hitExtent, coordinate);\n      buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);\n    }\n\n    const mask = getCircleArray(hitTolerance);\n    let declutteredFeatures;\n    if (this.declutterTree_) {\n      declutteredFeatures = this.declutterTree_.all().map(function(entry) {\n        return entry.value;\n      });\n    }\n\n    let replayType;\n\n    /**\n     * @param {import(\"../../Feature.js\").default|import(\"../Feature.js\").default} feature Feature.\n     * @return {?} Callback result.\n     */\n    function featureCallback(feature) {\n      const imageData = context.getImageData(0, 0, contextSize, contextSize).data;\n      for (let i = 0; i < contextSize; i++) {\n        for (let j = 0; j < contextSize; j++) {\n          if (mask[i][j]) {\n            if (imageData[(j * contextSize + i) * 4 + 3] > 0) {\n              let result;\n              if (!(declutteredFeatures && (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) ||\n                  declutteredFeatures.indexOf(feature) !== -1) {\n                result = callback(feature);\n              }\n              if (result) {\n                return result;\n              } else {\n                context.clearRect(0, 0, contextSize, contextSize);\n                return undefined;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(this.replaysByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n\n    let i, j, replays, replay, result;\n    for (i = zs.length - 1; i >= 0; --i) {\n      const zIndexKey = zs[i].toString();\n      replays = this.replaysByZIndex_[zIndexKey];\n      for (j = ORDER.length - 1; j >= 0; --j) {\n        replayType = ORDER[j];\n        replay = replays[replayType];\n        if (replay !== undefined) {\n          if (declutterReplays &&\n              (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) {\n            const declutter = declutterReplays[zIndexKey];\n            if (!declutter) {\n              declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            result = replay.replayHitDetection(context, transform, rotation,\n              skippedFeaturesHash, featureCallback, hitExtent);\n            if (result) {\n              return result;\n            }\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @return {Array<number>} Clip coordinates.\n   */\n  getClipCoords(transform) {\n    const maxExtent = this.maxExtent_;\n    const minX = maxExtent[0];\n    const minY = maxExtent[1];\n    const maxX = maxExtent[2];\n    const maxY = maxExtent[3];\n    const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];\n    transform2D(\n      flatClipCoords, 0, 8, 2, transform, flatClipCoords);\n    return flatClipCoords;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getReplay(zIndex, replayType) {\n    const zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';\n    let replays = this.replaysByZIndex_[zIndexKey];\n    if (replays === undefined) {\n      replays = {};\n      this.replaysByZIndex_[zIndexKey] = replays;\n    }\n    let replay = replays[replayType];\n    if (replay === undefined) {\n      const Constructor = BATCH_CONSTRUCTORS[replayType];\n      replay = new Constructor(this.tolerance_, this.maxExtent_,\n        this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);\n      replays[replayType] = replay;\n    }\n    return replay;\n  }\n\n  /**\n   * @return {Object<string, Object<ReplayType, CanvasReplay>>} Replays.\n   */\n  getReplays() {\n    return this.replaysByZIndex_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  isEmpty() {\n    return isEmpty(this.replaysByZIndex_);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../transform.js\").Transform} transform Transform.\n   * @param {number} viewRotation View rotation.\n   * @param {Object<string, boolean>} skippedFeaturesHash Ids of features to skip.\n   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.\n   * @param {Array<ReplayType>=} opt_replayTypes Ordered replay types to replay.\n   *     Default is {@link module:ol/render/replay~ORDER}\n   * @param {Object<string, import(\"../canvas.js\").DeclutterGroup>=} opt_declutterReplays Declutter replays.\n   */\n  replay(\n    context,\n    transform,\n    viewRotation,\n    skippedFeaturesHash,\n    snapToPixel,\n    opt_replayTypes,\n    opt_declutterReplays\n  ) {\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(this.replaysByZIndex_).map(Number);\n    zs.sort(numberSafeCompareFunction);\n\n    // setup clipping so that the parts of over-simplified geometries are not\n    // visible outside the current extent when panning\n    context.save();\n    this.clip(context, transform);\n\n    const replayTypes = opt_replayTypes ? opt_replayTypes : ORDER;\n    let i, ii, j, jj, replays, replay;\n    for (i = 0, ii = zs.length; i < ii; ++i) {\n      const zIndexKey = zs[i].toString();\n      replays = this.replaysByZIndex_[zIndexKey];\n      for (j = 0, jj = replayTypes.length; j < jj; ++j) {\n        const replayType = replayTypes[j];\n        replay = replays[replayType];\n        if (replay !== undefined) {\n          if (opt_declutterReplays &&\n              (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) {\n            const declutter = opt_declutterReplays[zIndexKey];\n            if (!declutter) {\n              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];\n            } else {\n              declutter.push(replay, transform.slice(0));\n            }\n          } else {\n            replay.replay(context, transform, viewRotation, skippedFeaturesHash, snapToPixel);\n          }\n        }\n      }\n    }\n\n    context.restore();\n  }\n}\n\n\n/**\n * This cache is used for storing calculated pixel circles for increasing performance.\n * It is a static property to allow each Replaygroup to access it.\n * @type {Object<number, Array<Array<(boolean|undefined)>>>}\n */\nconst circleArrayCache = {\n  0: [[true]]\n};\n\n\n/**\n * This method fills a row in the array from the given coordinate to the\n * middle with `true`.\n * @param {Array<Array<(boolean|undefined)>>} array The array that will be altered.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n */\nfunction fillCircleArrayRowToMiddle(array, x, y) {\n  let i;\n  const radius = Math.floor(array.length / 2);\n  if (x >= radius) {\n    for (i = radius; i < x; i++) {\n      array[i][y] = true;\n    }\n  } else if (x < radius) {\n    for (i = x + 1; i < radius; i++) {\n      array[i][y] = true;\n    }\n  }\n}\n\n\n/**\n * This methods creates a circle inside a fitting array. Points inside the\n * circle are marked by true, points on the outside are undefined.\n * It uses the midpoint circle algorithm.\n * A cache is used to increase performance.\n * @param {number} radius Radius.\n * @returns {Array<Array<(boolean|undefined)>>} An array with marked circle points.\n */\nexport function getCircleArray(radius) {\n  if (circleArrayCache[radius] !== undefined) {\n    return circleArrayCache[radius];\n  }\n\n  const arraySize = radius * 2 + 1;\n  const arr = new Array(arraySize);\n  for (let i = 0; i < arraySize; i++) {\n    arr[i] = new Array(arraySize);\n  }\n\n  let x = radius;\n  let y = 0;\n  let error = 0;\n\n  while (x >= y) {\n    fillCircleArrayRowToMiddle(arr, radius + x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius + x);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius + y);\n    fillCircleArrayRowToMiddle(arr, radius - x, radius - y);\n    fillCircleArrayRowToMiddle(arr, radius - y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + y, radius - x);\n    fillCircleArrayRowToMiddle(arr, radius + x, radius - y);\n\n    y++;\n    error += 1 + 2 * y;\n    if (2 * (error - x) + 1 > 0) {\n      x -= 1;\n      error += 1 - 2 * x;\n    }\n  }\n\n  circleArrayCache[radius] = arr;\n  return arr;\n}\n\n\n/**\n * @param {!Object<string, Array<*>>} declutterReplays Declutter replays.\n * @param {CanvasRenderingContext2D} context Context.\n * @param {number} rotation Rotation.\n * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.\n */\nexport function replayDeclutter(declutterReplays, context, rotation, snapToPixel) {\n  const zs = Object.keys(declutterReplays).map(Number).sort(numberSafeCompareFunction);\n  const skippedFeatureUids = {};\n  for (let z = 0, zz = zs.length; z < zz; ++z) {\n    const replayData = declutterReplays[zs[z].toString()];\n    for (let i = 0, ii = replayData.length; i < ii;) {\n      const replay = replayData[i++];\n      const transform = replayData[i++];\n      replay.replay(context, transform, rotation, skippedFeatureUids, snapToPixel);\n    }\n  }\n}\n\n\nexport default CanvasReplayGroup;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}