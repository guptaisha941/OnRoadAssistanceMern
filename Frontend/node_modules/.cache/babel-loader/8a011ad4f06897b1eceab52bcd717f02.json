{"ast":null,"code":"/**\n * @module ol/style/RegularShape\n */\n\nimport { asString } from '../color.js';\nimport { asColorLike } from '../colorlike.js';\nimport { createCanvasContext2D } from '../dom.js';\nimport { CANVAS_LINE_DASH } from '../has.js';\nimport ImageState from '../ImageState.js';\nimport { defaultStrokeStyle, defaultFillStyle, defaultLineCap, defaultLineWidth, defaultLineJoin, defaultMiterLimit } from '../render/canvas.js';\nimport ImageStyle from './Image.js';\n\n/**\n * Specify radius for regular polygons, or radius1 and radius2 for stars.\n * @typedef {Object} Options\n * @property {import(\"./Fill.js\").default} [fill] Fill style.\n * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points\n * is the number of sides.\n * @property {number} [radius] Radius of a regular polygon.\n * @property {number} [radius1] Outer radius of a star.\n * @property {number} [radius2] Inner radius of a star.\n * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.\n * @property {import(\"./Stroke.js\").default} [stroke] Stroke style.\n * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).\n * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.\n * @property {import(\"./AtlasManager.js\").default} [atlasManager] The atlas manager to use for this symbol. When\n * using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given, the\n * symbol is added to an atlas. By default no atlas manager is used.\n */\n\n/**\n * @typedef {Object} RenderOptions\n * @property {import(\"../colorlike.js\").ColorLike} [strokeStyle]\n * @property {number} strokeWidth\n * @property {number} size\n * @property {string} lineCap\n * @property {Array<number>} lineDash\n * @property {number} lineDashOffset\n * @property {string} lineJoin\n * @property {number} miterLimit\n */\n\n/**\n * @classdesc\n * Set regular shape style for vector features. The resulting shape will be\n * a regular polygon when `radius` is provided, or a star when `radius1` and\n * `radius2` are provided.\n * @api\n */\nvar RegularShape = /*@__PURE__*/function (ImageStyle) {\n  function RegularShape(options) {\n    /**\n     * @type {boolean}\n     */\n    var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;\n    ImageStyle.call(this, {\n      opacity: 1,\n      rotateWithView: rotateWithView,\n      rotation: options.rotation !== undefined ? options.rotation : 0,\n      scale: 1\n    });\n\n    /**\n     * @private\n     * @type {Array<string|number>}\n     */\n    this.checksums_ = null;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.hitDetectionCanvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Fill.js\").default}\n     */\n    this.fill_ = options.fill !== undefined ? options.fill : null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.origin_ = [0, 0];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.points_ = options.points;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.radius_ = /** @type {number} */options.radius !== undefined ? options.radius : options.radius1;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.radius2_ = options.radius2;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.angle_ = options.angle !== undefined ? options.angle : 0;\n\n    /**\n     * @private\n     * @type {import(\"./Stroke.js\").default}\n     */\n    this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.anchor_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.size_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.imageSize_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.hitDetectionImageSize_ = null;\n\n    /**\n     * @protected\n     * @type {import(\"./AtlasManager.js\").default|undefined}\n     */\n    this.atlasManager_ = options.atlasManager;\n    this.render_(this.atlasManager_);\n  }\n  if (ImageStyle) RegularShape.__proto__ = ImageStyle;\n  RegularShape.prototype = Object.create(ImageStyle && ImageStyle.prototype);\n  RegularShape.prototype.constructor = RegularShape;\n\n  /**\n   * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.\n   * @return {RegularShape} The cloned style.\n   * @api\n   */\n  RegularShape.prototype.clone = function clone() {\n    var style = new RegularShape({\n      fill: this.getFill() ? this.getFill().clone() : undefined,\n      points: this.getPoints(),\n      radius: this.getRadius(),\n      radius2: this.getRadius2(),\n      angle: this.getAngle(),\n      stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView(),\n      atlasManager: this.atlasManager_\n    });\n    style.setOpacity(this.getOpacity());\n    style.setScale(this.getScale());\n    return style;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  RegularShape.prototype.getAnchor = function getAnchor() {\n    return this.anchor_;\n  };\n\n  /**\n   * Get the angle used in generating the shape.\n   * @return {number} Shape's rotation in radians.\n   * @api\n   */\n  RegularShape.prototype.getAngle = function getAngle() {\n    return this.angle_;\n  };\n\n  /**\n   * Get the fill style for the shape.\n   * @return {import(\"./Fill.js\").default} Fill style.\n   * @api\n   */\n  RegularShape.prototype.getFill = function getFill() {\n    return this.fill_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  RegularShape.prototype.getHitDetectionImage = function getHitDetectionImage(pixelRatio) {\n    return this.hitDetectionCanvas_;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  RegularShape.prototype.getImage = function getImage(pixelRatio) {\n    return this.canvas_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  RegularShape.prototype.getImageSize = function getImageSize() {\n    return this.imageSize_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  RegularShape.prototype.getHitDetectionImageSize = function getHitDetectionImageSize() {\n    return this.hitDetectionImageSize_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  RegularShape.prototype.getImageState = function getImageState() {\n    return ImageState.LOADED;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  RegularShape.prototype.getOrigin = function getOrigin() {\n    return this.origin_;\n  };\n\n  /**\n   * Get the number of points for generating the shape.\n   * @return {number} Number of points for stars and regular polygons.\n   * @api\n   */\n  RegularShape.prototype.getPoints = function getPoints() {\n    return this.points_;\n  };\n\n  /**\n   * Get the (primary) radius for the shape.\n   * @return {number} Radius.\n   * @api\n   */\n  RegularShape.prototype.getRadius = function getRadius() {\n    return this.radius_;\n  };\n\n  /**\n   * Get the secondary radius for the shape.\n   * @return {number|undefined} Radius2.\n   * @api\n   */\n  RegularShape.prototype.getRadius2 = function getRadius2() {\n    return this.radius2_;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  RegularShape.prototype.getSize = function getSize() {\n    return this.size_;\n  };\n\n  /**\n   * Get the stroke style for the shape.\n   * @return {import(\"./Stroke.js\").default} Stroke style.\n   * @api\n   */\n  RegularShape.prototype.getStroke = function getStroke() {\n    return this.stroke_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  RegularShape.prototype.listenImageChange = function listenImageChange(listener, thisArg) {\n    return undefined;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  RegularShape.prototype.load = function load() {};\n\n  /**\n   * @inheritDoc\n   */\n  RegularShape.prototype.unlistenImageChange = function unlistenImageChange(listener, thisArg) {};\n\n  /**\n   * @protected\n   * @param {import(\"./AtlasManager.js\").default|undefined} atlasManager An atlas manager.\n   */\n  RegularShape.prototype.render_ = function render_(atlasManager) {\n    var imageSize;\n    var lineCap = '';\n    var lineJoin = '';\n    var miterLimit = 0;\n    var lineDash = null;\n    var lineDashOffset = 0;\n    var strokeStyle;\n    var strokeWidth = 0;\n    if (this.stroke_) {\n      strokeStyle = this.stroke_.getColor();\n      if (strokeStyle === null) {\n        strokeStyle = defaultStrokeStyle;\n      }\n      strokeStyle = asColorLike(strokeStyle);\n      strokeWidth = this.stroke_.getWidth();\n      if (strokeWidth === undefined) {\n        strokeWidth = defaultLineWidth;\n      }\n      lineDash = this.stroke_.getLineDash();\n      lineDashOffset = this.stroke_.getLineDashOffset();\n      if (!CANVAS_LINE_DASH) {\n        lineDash = null;\n        lineDashOffset = 0;\n      }\n      lineJoin = this.stroke_.getLineJoin();\n      if (lineJoin === undefined) {\n        lineJoin = defaultLineJoin;\n      }\n      lineCap = this.stroke_.getLineCap();\n      if (lineCap === undefined) {\n        lineCap = defaultLineCap;\n      }\n      miterLimit = this.stroke_.getMiterLimit();\n      if (miterLimit === undefined) {\n        miterLimit = defaultMiterLimit;\n      }\n    }\n    var size = 2 * (this.radius_ + strokeWidth) + 1;\n\n    /** @type {RenderOptions} */\n    var renderOptions = {\n      strokeStyle: strokeStyle,\n      strokeWidth: strokeWidth,\n      size: size,\n      lineCap: lineCap,\n      lineDash: lineDash,\n      lineDashOffset: lineDashOffset,\n      lineJoin: lineJoin,\n      miterLimit: miterLimit\n    };\n    if (atlasManager === undefined) {\n      // no atlas manager is used, create a new canvas\n      var context = createCanvasContext2D(size, size);\n      this.canvas_ = context.canvas;\n\n      // canvas.width and height are rounded to the closest integer\n      size = this.canvas_.width;\n      imageSize = size;\n      this.draw_(renderOptions, context, 0, 0);\n      this.createHitDetectionCanvas_(renderOptions);\n    } else {\n      // an atlas manager is used, add the symbol to an atlas\n      size = Math.round(size);\n      var hasCustomHitDetectionImage = !this.fill_;\n      var renderHitDetectionCallback;\n      if (hasCustomHitDetectionImage) {\n        // render the hit-detection image into a separate atlas image\n        renderHitDetectionCallback = this.drawHitDetectionCanvas_.bind(this, renderOptions);\n      }\n      var id = this.getChecksum();\n      var info = atlasManager.add(id, size, size, this.draw_.bind(this, renderOptions), renderHitDetectionCallback);\n      this.canvas_ = info.image;\n      this.origin_ = [info.offsetX, info.offsetY];\n      imageSize = info.image.width;\n      if (hasCustomHitDetectionImage) {\n        this.hitDetectionCanvas_ = info.hitImage;\n        this.hitDetectionImageSize_ = [info.hitImage.width, info.hitImage.height];\n      } else {\n        this.hitDetectionCanvas_ = this.canvas_;\n        this.hitDetectionImageSize_ = [imageSize, imageSize];\n      }\n    }\n    this.anchor_ = [size / 2, size / 2];\n    this.size_ = [size, size];\n    this.imageSize_ = [imageSize, imageSize];\n  };\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   * @param {CanvasRenderingContext2D} context The rendering context.\n   * @param {number} x The origin for the symbol (x).\n   * @param {number} y The origin for the symbol (y).\n   */\n  RegularShape.prototype.draw_ = function draw_(renderOptions, context, x, y) {\n    var i, angle0, radiusC;\n    // reset transform\n    context.setTransform(1, 0, 0, 1, 0, 0);\n\n    // then move to (x, y)\n    context.translate(x, y);\n    context.beginPath();\n    var points = this.points_;\n    if (points === Infinity) {\n      context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);\n    } else {\n      var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;\n      if (radius2 !== this.radius_) {\n        points = 2 * points;\n      }\n      for (i = 0; i <= points; i++) {\n        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;\n        radiusC = i % 2 === 0 ? this.radius_ : radius2;\n        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));\n      }\n    }\n    if (this.fill_) {\n      var color = this.fill_.getColor();\n      if (color === null) {\n        color = defaultFillStyle;\n      }\n      context.fillStyle = asColorLike(color);\n      context.fill();\n    }\n    if (this.stroke_) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n      context.lineCap = /** @type {CanvasLineCap} */renderOptions.lineCap;\n      context.lineJoin = /** @type {CanvasLineJoin} */renderOptions.lineJoin;\n      context.miterLimit = renderOptions.miterLimit;\n      context.stroke();\n    }\n    context.closePath();\n  };\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   */\n  RegularShape.prototype.createHitDetectionCanvas_ = function createHitDetectionCanvas_(renderOptions) {\n    this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];\n    if (this.fill_) {\n      this.hitDetectionCanvas_ = this.canvas_;\n      return;\n    }\n\n    // if no fill style is set, create an extra hit-detection image with a\n    // default fill style\n    var context = createCanvasContext2D(renderOptions.size, renderOptions.size);\n    this.hitDetectionCanvas_ = context.canvas;\n    this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);\n  };\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   * @param {CanvasRenderingContext2D} context The context.\n   * @param {number} x The origin for the symbol (x).\n   * @param {number} y The origin for the symbol (y).\n   */\n  RegularShape.prototype.drawHitDetectionCanvas_ = function drawHitDetectionCanvas_(renderOptions, context, x, y) {\n    // reset transform\n    context.setTransform(1, 0, 0, 1, 0, 0);\n\n    // then move to (x, y)\n    context.translate(x, y);\n    context.beginPath();\n    var points = this.points_;\n    if (points === Infinity) {\n      context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);\n    } else {\n      var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;\n      if (radius2 !== this.radius_) {\n        points = 2 * points;\n      }\n      var i, radiusC, angle0;\n      for (i = 0; i <= points; i++) {\n        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;\n        radiusC = i % 2 === 0 ? this.radius_ : radius2;\n        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));\n      }\n    }\n    context.fillStyle = asString(defaultFillStyle);\n    context.fill();\n    if (this.stroke_) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n      context.stroke();\n    }\n    context.closePath();\n  };\n\n  /**\n   * @return {string} The checksum.\n   */\n  RegularShape.prototype.getChecksum = function getChecksum() {\n    var strokeChecksum = this.stroke_ ? this.stroke_.getChecksum() : '-';\n    var fillChecksum = this.fill_ ? this.fill_.getChecksum() : '-';\n    var recalculate = !this.checksums_ || strokeChecksum != this.checksums_[1] || fillChecksum != this.checksums_[2] || this.radius_ != this.checksums_[3] || this.radius2_ != this.checksums_[4] || this.angle_ != this.checksums_[5] || this.points_ != this.checksums_[6];\n    if (recalculate) {\n      var checksum = 'r' + strokeChecksum + fillChecksum + (this.radius_ !== undefined ? this.radius_.toString() : '-') + (this.radius2_ !== undefined ? this.radius2_.toString() : '-') + (this.angle_ !== undefined ? this.angle_.toString() : '-') + (this.points_ !== undefined ? this.points_.toString() : '-');\n      this.checksums_ = [checksum, strokeChecksum, fillChecksum, this.radius_, this.radius2_, this.angle_, this.points_];\n    }\n    return (/** @type {string} */this.checksums_[0]\n    );\n  };\n  return RegularShape;\n}(ImageStyle);\nexport default RegularShape;","map":{"version":3,"names":["asString","asColorLike","createCanvasContext2D","CANVAS_LINE_DASH","ImageState","defaultStrokeStyle","defaultFillStyle","defaultLineCap","defaultLineWidth","defaultLineJoin","defaultMiterLimit","ImageStyle","RegularShape","options","rotateWithView","undefined","call","opacity","rotation","scale","checksums_","canvas_","hitDetectionCanvas_","fill_","fill","origin_","points_","points","radius_","radius","radius1","radius2_","radius2","angle_","angle","stroke_","stroke","anchor_","size_","imageSize_","hitDetectionImageSize_","atlasManager_","atlasManager","render_","clone","style","getFill","getPoints","getRadius","getRadius2","getAngle","getStroke","getRotation","getRotateWithView","setOpacity","getOpacity","setScale","getScale","getAnchor","getHitDetectionImage","pixelRatio","getImage","getImageSize","getHitDetectionImageSize","getImageState","LOADED","getOrigin","getSize","listenImageChange","listener","thisArg","load","unlistenImageChange","imageSize","lineCap","lineJoin","miterLimit","lineDash","lineDashOffset","strokeStyle","strokeWidth","getColor","getWidth","getLineDash","getLineDashOffset","getLineJoin","getLineCap","getMiterLimit","size","renderOptions","context","canvas","width","draw_","createHitDetectionCanvas_","Math","round","hasCustomHitDetectionImage","renderHitDetectionCallback","drawHitDetectionCanvas_","bind","id","getChecksum","info","add","image","offsetX","offsetY","hitImage","height","x","y","i","angle0","radiusC","setTransform","translate","beginPath","Infinity","arc","PI","lineTo","cos","sin","color","fillStyle","lineWidth","setLineDash","closePath","strokeChecksum","fillChecksum","recalculate","checksum","toString"],"sources":["../../../src/ol/style/RegularShape.js"],"sourcesContent":["/**\n * @module ol/style/RegularShape\n */\n\nimport {asString} from '../color.js';\nimport {asColorLike} from '../colorlike.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport {CANVAS_LINE_DASH} from '../has.js';\nimport ImageState from '../ImageState.js';\nimport {defaultStrokeStyle, defaultFillStyle, defaultLineCap, defaultLineWidth, defaultLineJoin, defaultMiterLimit} from '../render/canvas.js';\nimport ImageStyle from './Image.js';\n\n\n/**\n * Specify radius for regular polygons, or radius1 and radius2 for stars.\n * @typedef {Object} Options\n * @property {import(\"./Fill.js\").default} [fill] Fill style.\n * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points\n * is the number of sides.\n * @property {number} [radius] Radius of a regular polygon.\n * @property {number} [radius1] Outer radius of a star.\n * @property {number} [radius2] Inner radius of a star.\n * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.\n * @property {import(\"./Stroke.js\").default} [stroke] Stroke style.\n * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).\n * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.\n * @property {import(\"./AtlasManager.js\").default} [atlasManager] The atlas manager to use for this symbol. When\n * using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given, the\n * symbol is added to an atlas. By default no atlas manager is used.\n */\n\n\n/**\n * @typedef {Object} RenderOptions\n * @property {import(\"../colorlike.js\").ColorLike} [strokeStyle]\n * @property {number} strokeWidth\n * @property {number} size\n * @property {string} lineCap\n * @property {Array<number>} lineDash\n * @property {number} lineDashOffset\n * @property {string} lineJoin\n * @property {number} miterLimit\n */\n\n\n/**\n * @classdesc\n * Set regular shape style for vector features. The resulting shape will be\n * a regular polygon when `radius` is provided, or a star when `radius1` and\n * `radius2` are provided.\n * @api\n */\nclass RegularShape extends ImageStyle {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    /**\n     * @type {boolean}\n     */\n    const rotateWithView = options.rotateWithView !== undefined ?\n      options.rotateWithView : false;\n\n    super({\n      opacity: 1,\n      rotateWithView: rotateWithView,\n      rotation: options.rotation !== undefined ? options.rotation : 0,\n      scale: 1\n    });\n\n    /**\n     * @private\n     * @type {Array<string|number>}\n     */\n    this.checksums_ = null;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.hitDetectionCanvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"./Fill.js\").default}\n     */\n    this.fill_ = options.fill !== undefined ? options.fill : null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.origin_ = [0, 0];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.points_ = options.points;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.radius_ = /** @type {number} */ (options.radius !== undefined ?\n      options.radius : options.radius1);\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.radius2_ = options.radius2;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.angle_ = options.angle !== undefined ? options.angle : 0;\n\n    /**\n     * @private\n     * @type {import(\"./Stroke.js\").default}\n     */\n    this.stroke_ = options.stroke !== undefined ? options.stroke : null;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.anchor_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.size_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.imageSize_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../size.js\").Size}\n     */\n    this.hitDetectionImageSize_ = null;\n\n    /**\n     * @protected\n     * @type {import(\"./AtlasManager.js\").default|undefined}\n     */\n    this.atlasManager_ = options.atlasManager;\n\n    this.render_(this.atlasManager_);\n\n  }\n\n  /**\n   * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.\n   * @return {RegularShape} The cloned style.\n   * @api\n   */\n  clone() {\n    const style = new RegularShape({\n      fill: this.getFill() ? this.getFill().clone() : undefined,\n      points: this.getPoints(),\n      radius: this.getRadius(),\n      radius2: this.getRadius2(),\n      angle: this.getAngle(),\n      stroke: this.getStroke() ? this.getStroke().clone() : undefined,\n      rotation: this.getRotation(),\n      rotateWithView: this.getRotateWithView(),\n      atlasManager: this.atlasManager_\n    });\n    style.setOpacity(this.getOpacity());\n    style.setScale(this.getScale());\n    return style;\n  }\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  getAnchor() {\n    return this.anchor_;\n  }\n\n  /**\n   * Get the angle used in generating the shape.\n   * @return {number} Shape's rotation in radians.\n   * @api\n   */\n  getAngle() {\n    return this.angle_;\n  }\n\n  /**\n   * Get the fill style for the shape.\n   * @return {import(\"./Fill.js\").default} Fill style.\n   * @api\n   */\n  getFill() {\n    return this.fill_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getHitDetectionImage(pixelRatio) {\n    return this.hitDetectionCanvas_;\n  }\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  getImage(pixelRatio) {\n    return this.canvas_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getImageSize() {\n    return this.imageSize_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getHitDetectionImageSize() {\n    return this.hitDetectionImageSize_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  getImageState() {\n    return ImageState.LOADED;\n  }\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  getOrigin() {\n    return this.origin_;\n  }\n\n  /**\n   * Get the number of points for generating the shape.\n   * @return {number} Number of points for stars and regular polygons.\n   * @api\n   */\n  getPoints() {\n    return this.points_;\n  }\n\n  /**\n   * Get the (primary) radius for the shape.\n   * @return {number} Radius.\n   * @api\n   */\n  getRadius() {\n    return this.radius_;\n  }\n\n  /**\n   * Get the secondary radius for the shape.\n   * @return {number|undefined} Radius2.\n   * @api\n   */\n  getRadius2() {\n    return this.radius2_;\n  }\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  getSize() {\n    return this.size_;\n  }\n\n  /**\n   * Get the stroke style for the shape.\n   * @return {import(\"./Stroke.js\").default} Stroke style.\n   * @api\n   */\n  getStroke() {\n    return this.stroke_;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  listenImageChange(listener, thisArg) {\n    return undefined;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  load() {}\n\n  /**\n   * @inheritDoc\n   */\n  unlistenImageChange(listener, thisArg) {}\n\n  /**\n   * @protected\n   * @param {import(\"./AtlasManager.js\").default|undefined} atlasManager An atlas manager.\n   */\n  render_(atlasManager) {\n    let imageSize;\n    let lineCap = '';\n    let lineJoin = '';\n    let miterLimit = 0;\n    let lineDash = null;\n    let lineDashOffset = 0;\n    let strokeStyle;\n    let strokeWidth = 0;\n\n    if (this.stroke_) {\n      strokeStyle = this.stroke_.getColor();\n      if (strokeStyle === null) {\n        strokeStyle = defaultStrokeStyle;\n      }\n      strokeStyle = asColorLike(strokeStyle);\n      strokeWidth = this.stroke_.getWidth();\n      if (strokeWidth === undefined) {\n        strokeWidth = defaultLineWidth;\n      }\n      lineDash = this.stroke_.getLineDash();\n      lineDashOffset = this.stroke_.getLineDashOffset();\n      if (!CANVAS_LINE_DASH) {\n        lineDash = null;\n        lineDashOffset = 0;\n      }\n      lineJoin = this.stroke_.getLineJoin();\n      if (lineJoin === undefined) {\n        lineJoin = defaultLineJoin;\n      }\n      lineCap = this.stroke_.getLineCap();\n      if (lineCap === undefined) {\n        lineCap = defaultLineCap;\n      }\n      miterLimit = this.stroke_.getMiterLimit();\n      if (miterLimit === undefined) {\n        miterLimit = defaultMiterLimit;\n      }\n    }\n\n    let size = 2 * (this.radius_ + strokeWidth) + 1;\n\n    /** @type {RenderOptions} */\n    const renderOptions = {\n      strokeStyle: strokeStyle,\n      strokeWidth: strokeWidth,\n      size: size,\n      lineCap: lineCap,\n      lineDash: lineDash,\n      lineDashOffset: lineDashOffset,\n      lineJoin: lineJoin,\n      miterLimit: miterLimit\n    };\n\n    if (atlasManager === undefined) {\n      // no atlas manager is used, create a new canvas\n      const context = createCanvasContext2D(size, size);\n      this.canvas_ = context.canvas;\n\n      // canvas.width and height are rounded to the closest integer\n      size = this.canvas_.width;\n      imageSize = size;\n\n      this.draw_(renderOptions, context, 0, 0);\n\n      this.createHitDetectionCanvas_(renderOptions);\n    } else {\n      // an atlas manager is used, add the symbol to an atlas\n      size = Math.round(size);\n\n      const hasCustomHitDetectionImage = !this.fill_;\n      let renderHitDetectionCallback;\n      if (hasCustomHitDetectionImage) {\n        // render the hit-detection image into a separate atlas image\n        renderHitDetectionCallback =\n            this.drawHitDetectionCanvas_.bind(this, renderOptions);\n      }\n\n      const id = this.getChecksum();\n      const info = atlasManager.add(\n        id, size, size, this.draw_.bind(this, renderOptions),\n        renderHitDetectionCallback);\n\n      this.canvas_ = info.image;\n      this.origin_ = [info.offsetX, info.offsetY];\n      imageSize = info.image.width;\n\n      if (hasCustomHitDetectionImage) {\n        this.hitDetectionCanvas_ = info.hitImage;\n        this.hitDetectionImageSize_ =\n            [info.hitImage.width, info.hitImage.height];\n      } else {\n        this.hitDetectionCanvas_ = this.canvas_;\n        this.hitDetectionImageSize_ = [imageSize, imageSize];\n      }\n    }\n\n    this.anchor_ = [size / 2, size / 2];\n    this.size_ = [size, size];\n    this.imageSize_ = [imageSize, imageSize];\n  }\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   * @param {CanvasRenderingContext2D} context The rendering context.\n   * @param {number} x The origin for the symbol (x).\n   * @param {number} y The origin for the symbol (y).\n   */\n  draw_(renderOptions, context, x, y) {\n    let i, angle0, radiusC;\n    // reset transform\n    context.setTransform(1, 0, 0, 1, 0, 0);\n\n    // then move to (x, y)\n    context.translate(x, y);\n\n    context.beginPath();\n\n    let points = this.points_;\n    if (points === Infinity) {\n      context.arc(\n        renderOptions.size / 2, renderOptions.size / 2,\n        this.radius_, 0, 2 * Math.PI, true);\n    } else {\n      const radius2 = (this.radius2_ !== undefined) ? this.radius2_\n        : this.radius_;\n      if (radius2 !== this.radius_) {\n        points = 2 * points;\n      }\n      for (i = 0; i <= points; i++) {\n        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;\n        radiusC = i % 2 === 0 ? this.radius_ : radius2;\n        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),\n          renderOptions.size / 2 + radiusC * Math.sin(angle0));\n      }\n    }\n\n\n    if (this.fill_) {\n      let color = this.fill_.getColor();\n      if (color === null) {\n        color = defaultFillStyle;\n      }\n      context.fillStyle = asColorLike(color);\n      context.fill();\n    }\n    if (this.stroke_) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n      context.lineCap = /** @type {CanvasLineCap} */ (renderOptions.lineCap);\n      context.lineJoin = /** @type {CanvasLineJoin} */ (renderOptions.lineJoin);\n      context.miterLimit = renderOptions.miterLimit;\n      context.stroke();\n    }\n    context.closePath();\n  }\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   */\n  createHitDetectionCanvas_(renderOptions) {\n    this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];\n    if (this.fill_) {\n      this.hitDetectionCanvas_ = this.canvas_;\n      return;\n    }\n\n    // if no fill style is set, create an extra hit-detection image with a\n    // default fill style\n    const context = createCanvasContext2D(renderOptions.size, renderOptions.size);\n    this.hitDetectionCanvas_ = context.canvas;\n\n    this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);\n  }\n\n  /**\n   * @private\n   * @param {RenderOptions} renderOptions Render options.\n   * @param {CanvasRenderingContext2D} context The context.\n   * @param {number} x The origin for the symbol (x).\n   * @param {number} y The origin for the symbol (y).\n   */\n  drawHitDetectionCanvas_(renderOptions, context, x, y) {\n    // reset transform\n    context.setTransform(1, 0, 0, 1, 0, 0);\n\n    // then move to (x, y)\n    context.translate(x, y);\n\n    context.beginPath();\n\n    let points = this.points_;\n    if (points === Infinity) {\n      context.arc(\n        renderOptions.size / 2, renderOptions.size / 2,\n        this.radius_, 0, 2 * Math.PI, true);\n    } else {\n      const radius2 = (this.radius2_ !== undefined) ? this.radius2_\n        : this.radius_;\n      if (radius2 !== this.radius_) {\n        points = 2 * points;\n      }\n      let i, radiusC, angle0;\n      for (i = 0; i <= points; i++) {\n        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;\n        radiusC = i % 2 === 0 ? this.radius_ : radius2;\n        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),\n          renderOptions.size / 2 + radiusC * Math.sin(angle0));\n      }\n    }\n\n    context.fillStyle = asString(defaultFillStyle);\n    context.fill();\n    if (this.stroke_) {\n      context.strokeStyle = renderOptions.strokeStyle;\n      context.lineWidth = renderOptions.strokeWidth;\n      if (renderOptions.lineDash) {\n        context.setLineDash(renderOptions.lineDash);\n        context.lineDashOffset = renderOptions.lineDashOffset;\n      }\n      context.stroke();\n    }\n    context.closePath();\n  }\n\n  /**\n   * @return {string} The checksum.\n   */\n  getChecksum() {\n    const strokeChecksum = this.stroke_ ?\n      this.stroke_.getChecksum() : '-';\n    const fillChecksum = this.fill_ ?\n      this.fill_.getChecksum() : '-';\n\n    const recalculate = !this.checksums_ ||\n        (strokeChecksum != this.checksums_[1] ||\n        fillChecksum != this.checksums_[2] ||\n        this.radius_ != this.checksums_[3] ||\n        this.radius2_ != this.checksums_[4] ||\n        this.angle_ != this.checksums_[5] ||\n        this.points_ != this.checksums_[6]);\n\n    if (recalculate) {\n      const checksum = 'r' + strokeChecksum + fillChecksum +\n          (this.radius_ !== undefined ? this.radius_.toString() : '-') +\n          (this.radius2_ !== undefined ? this.radius2_.toString() : '-') +\n          (this.angle_ !== undefined ? this.angle_.toString() : '-') +\n          (this.points_ !== undefined ? this.points_.toString() : '-');\n      this.checksums_ = [checksum, strokeChecksum, fillChecksum,\n        this.radius_, this.radius2_, this.angle_, this.points_];\n    }\n\n    return /** @type {string} */ (this.checksums_[0]);\n  }\n}\n\n\nexport default RegularShape;\n"],"mappings":"AAAA;;;;AAIA,SAAQA,QAAQ,QAAO,aAAa;AACpC,SAAQC,WAAW,QAAO,iBAAiB;AAC3C,SAAQC,qBAAqB,QAAO,WAAW;AAC/C,SAAQC,gBAAgB,QAAO,WAAW;AAC1C,OAAOC,UAAU,MAAM,kBAAkB;AACzC,SAAQC,kBAAkB,EAAEC,gBAAgB,EAAEC,cAAc,EAAEC,gBAAgB,EAAEC,eAAe,EAAEC,iBAAiB,QAAO,qBAAqB;AAC9I,OAAOC,UAAU,MAAM,YAAY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CnC,IAAMC,YAAY,GAAmB,uBAAAD,UAAA;EAInC,SAAAC,YAAWA,CAACC,OAAO,EAAE;;;;IAInB,IAAMC,cAAc,GAAGD,OAAO,CAACC,cAAc,KAAKC,SAAS,GACzDF,OAAO,CAACC,cAAc,GAAG,KAAK;IAEhCH,UAAA,CAAAK,IAAK,OAAC;MACJC,OAAO,EAAE,CAAC;MACVH,cAAc,EAAEA,cAAc;MAC9BI,QAAQ,EAAEL,OAAO,CAACK,QAAQ,KAAKH,SAAS,GAAGF,OAAO,CAACK,QAAQ,GAAG,CAAC;MAC/DC,KAAK,EAAE;KACR,CAAC;;;;;;IAMF,IAAI,CAACC,UAAU,GAAG,IAAI;;;;;;IAMtB,IAAI,CAACC,OAAO,GAAG,IAAI;;;;;;IAMnB,IAAI,CAACC,mBAAmB,GAAG,IAAI;;;;;;IAM/B,IAAI,CAACC,KAAK,GAAGV,OAAO,CAACW,IAAI,KAAKT,SAAS,GAAGF,OAAO,CAACW,IAAI,GAAG,IAAI;;;;;;IAM7D,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;;;;;;IAMrB,IAAI,CAACC,OAAO,GAAGb,OAAO,CAACc,MAAM;;;;;;IAM7B,IAAI,CAACC,OAAO,wBAA0Bf,OAAO,CAACgB,MAAM,KAAKd,SAAS,GAChEF,OAAO,CAACgB,MAAM,GAAGhB,OAAO,CAACiB,OAAQ;;;;;;IAMnC,IAAI,CAACC,QAAQ,GAAGlB,OAAO,CAACmB,OAAO;;;;;;IAM/B,IAAI,CAACC,MAAM,GAAGpB,OAAO,CAACqB,KAAK,KAAKnB,SAAS,GAAGF,OAAO,CAACqB,KAAK,GAAG,CAAC;;;;;;IAM7D,IAAI,CAACC,OAAO,GAAGtB,OAAO,CAACuB,MAAM,KAAKrB,SAAS,GAAGF,OAAO,CAACuB,MAAM,GAAG,IAAI;;;;;;IAMnE,IAAI,CAACC,OAAO,GAAG,IAAI;;;;;;IAMnB,IAAI,CAACC,KAAK,GAAG,IAAI;;;;;;IAMjB,IAAI,CAACC,UAAU,GAAG,IAAI;;;;;;IAMtB,IAAI,CAACC,sBAAsB,GAAG,IAAI;;;;;;IAMlC,IAAI,CAACC,aAAa,GAAG5B,OAAO,CAAC6B,YAAY;IAEzC,IAAI,CAACC,OAAO,CAAC,IAAI,CAACF,aAAa,CAAC;;;;;;;;;;;yBASlCG,KAAA,YAAAA,MAAA,EAAQ;IACN,IAAMC,KAAK,GAAG,IAAIjC,YAAY,CAAC;MAC7BY,IAAI,EAAE,IAAI,CAACsB,OAAO,EAAE,GAAG,IAAI,CAACA,OAAO,EAAE,CAACF,KAAK,EAAE,GAAG7B,SAAS;MACzDY,MAAM,EAAE,IAAI,CAACoB,SAAS,EAAE;MACxBlB,MAAM,EAAE,IAAI,CAACmB,SAAS,EAAE;MACxBhB,OAAO,EAAE,IAAI,CAACiB,UAAU,EAAE;MAC1Bf,KAAK,EAAE,IAAI,CAACgB,QAAQ,EAAE;MACtBd,MAAM,EAAE,IAAI,CAACe,SAAS,EAAE,GAAG,IAAI,CAACA,SAAS,EAAE,CAACP,KAAK,EAAE,GAAG7B,SAAS;MAC/DG,QAAQ,EAAE,IAAI,CAACkC,WAAW,EAAE;MAC5BtC,cAAc,EAAE,IAAI,CAACuC,iBAAiB,EAAE;MACxCX,YAAY,EAAE,IAAI,CAACD;KACpB,CAAC;IACFI,KAAK,CAACS,UAAU,CAAC,IAAI,CAACC,UAAU,EAAE,CAAC;IACnCV,KAAK,CAACW,QAAQ,CAAC,IAAI,CAACC,QAAQ,EAAE,CAAC;IAC/B,OAAOZ,KAAK;;;;;;;yBAOda,SAAA,YAAAA,UAAA,EAAY;IACV,OAAO,IAAI,CAACrB,OAAO;;;;;;;;yBAQrBa,QAAA,YAAAA,SAAA,EAAW;IACT,OAAO,IAAI,CAACjB,MAAM;;;;;;;;yBAQpBa,OAAA,YAAAA,QAAA,EAAU;IACR,OAAO,IAAI,CAACvB,KAAK;;;;;;yBAMnBoC,oBAAA,YAAAA,qBAAqBC,UAAU,EAAE;IAC/B,OAAO,IAAI,CAACtC,mBAAmB;;;;;;;yBAOjCuC,QAAA,YAAAA,SAASD,UAAU,EAAE;IACnB,OAAO,IAAI,CAACvC,OAAO;;;;;;yBAMrByC,YAAA,YAAAA,aAAA,EAAe;IACb,OAAO,IAAI,CAACvB,UAAU;;;;;;yBAMxBwB,wBAAA,YAAAA,yBAAA,EAA2B;IACzB,OAAO,IAAI,CAACvB,sBAAsB;;;;;;yBAMpCwB,aAAA,YAAAA,cAAA,EAAgB;IACd,OAAO5D,UAAU,CAAC6D,MAAM;;;;;;;yBAO1BC,SAAA,YAAAA,UAAA,EAAY;IACV,OAAO,IAAI,CAACzC,OAAO;;;;;;;;yBAQrBsB,SAAA,YAAAA,UAAA,EAAY;IACV,OAAO,IAAI,CAACrB,OAAO;;;;;;;;yBAQrBsB,SAAA,YAAAA,UAAA,EAAY;IACV,OAAO,IAAI,CAACpB,OAAO;;;;;;;;yBAQrBqB,UAAA,YAAAA,WAAA,EAAa;IACX,OAAO,IAAI,CAAClB,QAAQ;;;;;;;yBAOtBoC,OAAA,YAAAA,QAAA,EAAU;IACR,OAAO,IAAI,CAAC7B,KAAK;;;;;;;;yBAQnBa,SAAA,YAAAA,UAAA,EAAY;IACV,OAAO,IAAI,CAAChB,OAAO;;;;;;yBAMrBiC,iBAAA,YAAAA,kBAAkBC,QAAQ,EAAEC,OAAO,EAAE;IACnC,OAAOvD,SAAS;;;;;;yBAMlBwD,IAAA,YAAAA,KAAA,EAAO;;;;;yBAKPC,mBAAA,YAAAA,oBAAoBH,QAAQ,EAAEC,OAAO,EAAE;;;;;;yBAMvC3B,OAAA,YAAAA,QAAQD,YAAY,EAAE;IACpB,IAAI+B,SAAS;IACb,IAAIC,OAAO,GAAG,EAAE;IAChB,IAAIC,QAAQ,GAAG,EAAE;IACjB,IAAIC,UAAU,GAAG,CAAC;IAClB,IAAIC,QAAQ,GAAG,IAAI;IACnB,IAAIC,cAAc,GAAG,CAAC;IACtB,IAAIC,WAAW;IACf,IAAIC,WAAW,GAAG,CAAC;IAEnB,IAAI,IAAI,CAAC7C,OAAO,EAAE;MAChB4C,WAAW,GAAG,IAAI,CAAC5C,OAAO,CAAC8C,QAAQ,EAAE;MACrC,IAAIF,WAAW,KAAK,IAAI,EAAE;QACxBA,WAAW,GAAG1E,kBAAkB;;MAElC0E,WAAW,GAAG9E,WAAW,CAAC8E,WAAW,CAAC;MACtCC,WAAW,GAAG,IAAI,CAAC7C,OAAO,CAAC+C,QAAQ,EAAE;MACrC,IAAIF,WAAW,KAAKjE,SAAS,EAAE;QAC7BiE,WAAW,GAAGxE,gBAAgB;;MAEhCqE,QAAQ,GAAG,IAAI,CAAC1C,OAAO,CAACgD,WAAW,EAAE;MACrCL,cAAc,GAAG,IAAI,CAAC3C,OAAO,CAACiD,iBAAiB,EAAE;MACjD,IAAI,CAACjF,gBAAgB,EAAE;QACrB0E,QAAQ,GAAG,IAAI;QACfC,cAAc,GAAG,CAAC;;MAEpBH,QAAQ,GAAG,IAAI,CAACxC,OAAO,CAACkD,WAAW,EAAE;MACrC,IAAIV,QAAQ,KAAK5D,SAAS,EAAE;QAC1B4D,QAAQ,GAAGlE,eAAe;;MAE5BiE,OAAO,GAAG,IAAI,CAACvC,OAAO,CAACmD,UAAU,EAAE;MACnC,IAAIZ,OAAO,KAAK3D,SAAS,EAAE;QACzB2D,OAAO,GAAGnE,cAAc;;MAE1BqE,UAAU,GAAG,IAAI,CAACzC,OAAO,CAACoD,aAAa,EAAE;MACzC,IAAIX,UAAU,KAAK7D,SAAS,EAAE;QAC5B6D,UAAU,GAAGlE,iBAAiB;;;IAIlC,IAAI8E,IAAI,GAAG,CAAC,IAAI,IAAI,CAAC5D,OAAO,GAAGoD,WAAW,CAAC,GAAG,CAAC;;;IAG/C,IAAMS,aAAa,GAAG;MACpBV,WAAW,EAAEA,WAAW;MACxBC,WAAW,EAAEA,WAAW;MACxBQ,IAAI,EAAEA,IAAI;MACVd,OAAO,EAAEA,OAAO;MAChBG,QAAQ,EAAEA,QAAQ;MAClBC,cAAc,EAAEA,cAAc;MAC9BH,QAAQ,EAAEA,QAAQ;MAClBC,UAAU,EAAEA;KACb;IAED,IAAIlC,YAAY,KAAK3B,SAAS,EAAE;;MAE9B,IAAM2E,OAAO,GAAGxF,qBAAqB,CAACsF,IAAI,EAAEA,IAAI,CAAC;MACjD,IAAI,CAACnE,OAAO,GAAGqE,OAAO,CAACC,MAAM;;;MAG7BH,IAAI,GAAG,IAAI,CAACnE,OAAO,CAACuE,KAAK;MACzBnB,SAAS,GAAGe,IAAI;MAEhB,IAAI,CAACK,KAAK,CAACJ,aAAa,EAAEC,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC;MAExC,IAAI,CAACI,yBAAyB,CAACL,aAAa,CAAC;KAC9C,MAAM;;MAELD,IAAI,GAAGO,IAAI,CAACC,KAAK,CAACR,IAAI,CAAC;MAEvB,IAAMS,0BAA0B,GAAG,CAAC,IAAI,CAAC1E,KAAK;MAC9C,IAAI2E,0BAA0B;MAC9B,IAAID,0BAA0B,EAAE;;QAE9BC,0BAA0B,GACtB,IAAI,CAACC,uBAAuB,CAACC,IAAI,CAAC,IAAI,EAAEX,aAAa,CAAC;;MAG5D,IAAMY,EAAE,GAAG,IAAI,CAACC,WAAW,EAAE;MAC7B,IAAMC,IAAI,GAAG7D,YAAY,CAAC8D,GAAG,CAC3BH,EAAE,EAAEb,IAAI,EAAEA,IAAI,EAAE,IAAI,CAACK,KAAK,CAACO,IAAI,CAAC,IAAI,EAAEX,aAAa,CAAC,EACpDS,0BAA0B,CAAC;MAE7B,IAAI,CAAC7E,OAAO,GAAGkF,IAAI,CAACE,KAAK;MACzB,IAAI,CAAChF,OAAO,GAAG,CAAC8E,IAAI,CAACG,OAAO,EAAEH,IAAI,CAACI,OAAO,CAAC;MAC3ClC,SAAS,GAAG8B,IAAI,CAACE,KAAK,CAACb,KAAK;MAE5B,IAAIK,0BAA0B,EAAE;QAC9B,IAAI,CAAC3E,mBAAmB,GAAGiF,IAAI,CAACK,QAAQ;QACxC,IAAI,CAACpE,sBAAsB,GACvB,CAAC+D,IAAI,CAACK,QAAQ,CAAChB,KAAK,EAAEW,IAAI,CAACK,QAAQ,CAACC,MAAM,CAAC;OAChD,MAAM;QACL,IAAI,CAACvF,mBAAmB,GAAG,IAAI,CAACD,OAAO;QACvC,IAAI,CAACmB,sBAAsB,GAAG,CAACiC,SAAS,EAAEA,SAAS,CAAC;;;IAIxD,IAAI,CAACpC,OAAO,GAAG,CAACmD,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAG,CAAC,CAAC;IACnC,IAAI,CAAClD,KAAK,GAAG,CAACkD,IAAI,EAAEA,IAAI,CAAC;IACzB,IAAI,CAACjD,UAAU,GAAG,CAACkC,SAAS,EAAEA,SAAS,CAAC;;;;;;;;;;yBAU1CoB,KAAA,YAAAA,MAAMJ,aAAa,EAAEC,OAAO,EAAEoB,CAAC,EAAEC,CAAC,EAAE;IAClC,IAAIC,CAAC,EAAEC,MAAM,EAAEC,OAAO;;IAEtBxB,OAAO,CAACyB,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;;IAGtCzB,OAAO,CAAC0B,SAAS,CAACN,CAAC,EAAEC,CAAC,CAAC;IAEvBrB,OAAO,CAAC2B,SAAS,EAAE;IAEnB,IAAI1F,MAAM,GAAG,IAAI,CAACD,OAAO;IACzB,IAAIC,MAAM,KAAK2F,QAAQ,EAAE;MACvB5B,OAAO,CAAC6B,GAAG,CACT9B,aAAa,CAACD,IAAI,GAAG,CAAC,EAAEC,aAAa,CAACD,IAAI,GAAG,CAAC,EAC9C,IAAI,CAAC5D,OAAO,EAAE,CAAC,EAAE,CAAC,GAAGmE,IAAI,CAACyB,EAAE,EAAE,IAAI,CAAC;KACtC,MAAM;MACL,IAAMxF,OAAO,GAAI,IAAI,CAACD,QAAQ,KAAKhB,SAAS,GAAI,IAAI,CAACgB,QAAQ,GACzD,IAAI,CAACH,OAAO;MAChB,IAAII,OAAO,KAAK,IAAI,CAACJ,OAAO,EAAE;QAC5BD,MAAM,GAAG,CAAC,GAAGA,MAAM;;MAErB,KAAKqF,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIrF,MAAM,EAAEqF,CAAC,EAAE,EAAE;QAC5BC,MAAM,GAAGD,CAAC,GAAG,CAAC,GAAGjB,IAAI,CAACyB,EAAE,GAAG7F,MAAM,GAAGoE,IAAI,CAACyB,EAAE,GAAG,CAAC,GAAG,IAAI,CAACvF,MAAM;QAC7DiF,OAAO,GAAGF,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,IAAI,CAACpF,OAAO,GAAGI,OAAO;QAC9C0D,OAAO,CAAC+B,MAAM,CAAChC,aAAa,CAACD,IAAI,GAAG,CAAC,GAAG0B,OAAO,GAAGnB,IAAI,CAAC2B,GAAG,CAACT,MAAM,CAAC,EAChExB,aAAa,CAACD,IAAI,GAAG,CAAC,GAAG0B,OAAO,GAAGnB,IAAI,CAAC4B,GAAG,CAACV,MAAM,CAAC,CAAC;;;IAK1D,IAAI,IAAI,CAAC1F,KAAK,EAAE;MACd,IAAIqG,KAAK,GAAG,IAAI,CAACrG,KAAK,CAAC0D,QAAQ,EAAE;MACjC,IAAI2C,KAAK,KAAK,IAAI,EAAE;QAClBA,KAAK,GAAGtH,gBAAgB;;MAE1BoF,OAAO,CAACmC,SAAS,GAAG5H,WAAW,CAAC2H,KAAK,CAAC;MACtClC,OAAO,CAAClE,IAAI,EAAE;;IAEhB,IAAI,IAAI,CAACW,OAAO,EAAE;MAChBuD,OAAO,CAACX,WAAW,GAAGU,aAAa,CAACV,WAAW;MAC/CW,OAAO,CAACoC,SAAS,GAAGrC,aAAa,CAACT,WAAW;MAC7C,IAAIS,aAAa,CAACZ,QAAQ,EAAE;QAC1Ba,OAAO,CAACqC,WAAW,CAACtC,aAAa,CAACZ,QAAQ,CAAC;QAC3Ca,OAAO,CAACZ,cAAc,GAAGW,aAAa,CAACX,cAAc;;MAEvDY,OAAO,CAAChB,OAAO,+BAAiCe,aAAa,CAACf,OAAQ;MACtEgB,OAAO,CAACf,QAAQ,gCAAkCc,aAAa,CAACd,QAAS;MACzEe,OAAO,CAACd,UAAU,GAAGa,aAAa,CAACb,UAAU;MAC7Cc,OAAO,CAACtD,MAAM,EAAE;;IAElBsD,OAAO,CAACsC,SAAS,EAAE;;;;;;;yBAOrBlC,yBAAA,YAAAA,0BAA0BL,aAAa,EAAE;IACvC,IAAI,CAACjD,sBAAsB,GAAG,CAACiD,aAAa,CAACD,IAAI,EAAEC,aAAa,CAACD,IAAI,CAAC;IACtE,IAAI,IAAI,CAACjE,KAAK,EAAE;MACd,IAAI,CAACD,mBAAmB,GAAG,IAAI,CAACD,OAAO;MACvC;;;;;IAKF,IAAMqE,OAAO,GAAGxF,qBAAqB,CAACuF,aAAa,CAACD,IAAI,EAAEC,aAAa,CAACD,IAAI,CAAC;IAC7E,IAAI,CAAClE,mBAAmB,GAAGoE,OAAO,CAACC,MAAM;IAEzC,IAAI,CAACQ,uBAAuB,CAACV,aAAa,EAAEC,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC;;;;;;;;;;yBAU5DS,uBAAA,YAAAA,wBAAwBV,aAAa,EAAEC,OAAO,EAAEoB,CAAC,EAAEC,CAAC,EAAE;;IAEpDrB,OAAO,CAACyB,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;;IAGtCzB,OAAO,CAAC0B,SAAS,CAACN,CAAC,EAAEC,CAAC,CAAC;IAEvBrB,OAAO,CAAC2B,SAAS,EAAE;IAEnB,IAAI1F,MAAM,GAAG,IAAI,CAACD,OAAO;IACzB,IAAIC,MAAM,KAAK2F,QAAQ,EAAE;MACvB5B,OAAO,CAAC6B,GAAG,CACT9B,aAAa,CAACD,IAAI,GAAG,CAAC,EAAEC,aAAa,CAACD,IAAI,GAAG,CAAC,EAC9C,IAAI,CAAC5D,OAAO,EAAE,CAAC,EAAE,CAAC,GAAGmE,IAAI,CAACyB,EAAE,EAAE,IAAI,CAAC;KACtC,MAAM;MACL,IAAMxF,OAAO,GAAI,IAAI,CAACD,QAAQ,KAAKhB,SAAS,GAAI,IAAI,CAACgB,QAAQ,GACzD,IAAI,CAACH,OAAO;MAChB,IAAII,OAAO,KAAK,IAAI,CAACJ,OAAO,EAAE;QAC5BD,MAAM,GAAG,CAAC,GAAGA,MAAM;;MAErB,IAAIqF,CAAC,EAAEE,OAAO,EAAED,MAAM;MACtB,KAAKD,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIrF,MAAM,EAAEqF,CAAC,EAAE,EAAE;QAC5BC,MAAM,GAAGD,CAAC,GAAG,CAAC,GAAGjB,IAAI,CAACyB,EAAE,GAAG7F,MAAM,GAAGoE,IAAI,CAACyB,EAAE,GAAG,CAAC,GAAG,IAAI,CAACvF,MAAM;QAC7DiF,OAAO,GAAGF,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,IAAI,CAACpF,OAAO,GAAGI,OAAO;QAC9C0D,OAAO,CAAC+B,MAAM,CAAChC,aAAa,CAACD,IAAI,GAAG,CAAC,GAAG0B,OAAO,GAAGnB,IAAI,CAAC2B,GAAG,CAACT,MAAM,CAAC,EAChExB,aAAa,CAACD,IAAI,GAAG,CAAC,GAAG0B,OAAO,GAAGnB,IAAI,CAAC4B,GAAG,CAACV,MAAM,CAAC,CAAC;;;IAI1DvB,OAAO,CAACmC,SAAS,GAAG7H,QAAQ,CAACM,gBAAgB,CAAC;IAC9CoF,OAAO,CAAClE,IAAI,EAAE;IACd,IAAI,IAAI,CAACW,OAAO,EAAE;MAChBuD,OAAO,CAACX,WAAW,GAAGU,aAAa,CAACV,WAAW;MAC/CW,OAAO,CAACoC,SAAS,GAAGrC,aAAa,CAACT,WAAW;MAC7C,IAAIS,aAAa,CAACZ,QAAQ,EAAE;QAC1Ba,OAAO,CAACqC,WAAW,CAACtC,aAAa,CAACZ,QAAQ,CAAC;QAC3Ca,OAAO,CAACZ,cAAc,GAAGW,aAAa,CAACX,cAAc;;MAEvDY,OAAO,CAACtD,MAAM,EAAE;;IAElBsD,OAAO,CAACsC,SAAS,EAAE;;;;;;yBAMrB1B,WAAA,YAAAA,YAAA,EAAc;IACZ,IAAM2B,cAAc,GAAG,IAAI,CAAC9F,OAAO,GACjC,IAAI,CAACA,OAAO,CAACmE,WAAW,EAAE,GAAG,GAAG;IAClC,IAAM4B,YAAY,GAAG,IAAI,CAAC3G,KAAK,GAC7B,IAAI,CAACA,KAAK,CAAC+E,WAAW,EAAE,GAAG,GAAG;IAEhC,IAAM6B,WAAW,GAAG,CAAC,IAAI,CAAC/G,UAAU,IAC/B6G,cAAc,IAAI,IAAI,CAAC7G,UAAU,CAAC,CAAC,CAAC,IACrC8G,YAAY,IAAI,IAAI,CAAC9G,UAAU,CAAC,CAAC,CAAC,IAClC,IAAI,CAACQ,OAAO,IAAI,IAAI,CAACR,UAAU,CAAC,CAAC,CAAC,IAClC,IAAI,CAACW,QAAQ,IAAI,IAAI,CAACX,UAAU,CAAC,CAAC,CAAC,IACnC,IAAI,CAACa,MAAM,IAAI,IAAI,CAACb,UAAU,CAAC,CAAC,CAAC,IACjC,IAAI,CAACM,OAAO,IAAI,IAAI,CAACN,UAAU,CAAC,CAAC,CAAE;IAEvC,IAAI+G,WAAW,EAAE;MACf,IAAMC,QAAQ,GAAG,GAAG,GAAGH,cAAc,GAAGC,YAAY,IAC/C,IAAI,CAACtG,OAAO,KAAKb,SAAS,GAAG,IAAI,CAACa,OAAO,CAACyG,QAAQ,EAAE,GAAG,GAAG,CAAC,IAC3D,IAAI,CAACtG,QAAQ,KAAKhB,SAAS,GAAG,IAAI,CAACgB,QAAQ,CAACsG,QAAQ,EAAE,GAAG,GAAG,CAAC,IAC7D,IAAI,CAACpG,MAAM,KAAKlB,SAAS,GAAG,IAAI,CAACkB,MAAM,CAACoG,QAAQ,EAAE,GAAG,GAAG,CAAC,IACzD,IAAI,CAAC3G,OAAO,KAAKX,SAAS,GAAG,IAAI,CAACW,OAAO,CAAC2G,QAAQ,EAAE,GAAG,GAAG,CAAC;MAChE,IAAI,CAACjH,UAAU,GAAG,CAACgH,QAAQ,EAAEH,cAAc,EAAEC,YAAY,EACvD,IAAI,CAACtG,OAAO,EAAE,IAAI,CAACG,QAAQ,EAAE,IAAI,CAACE,MAAM,EAAE,IAAI,CAACP,OAAO,CAAC;;IAG3D,6BAA8B,IAAI,CAACN,UAAU,CAAC,CAAC;IAAC;GACjD;;EAjhBwBT,UAAA;AAqhB3B,eAAeC,YAAY"},"metadata":{},"sourceType":"module"}